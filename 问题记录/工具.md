# 工具

## IDEA

1. maven工程修改为idea标准web工程

> Project Strugture --> facets--> 添加web模块 -->修改上下两部分路径为：
>
> src\main\webapp-->修改web.xml版本号-->Create Artifact-->ok

2. 依赖未发布：编辑Artifacts--> 全部选中Put into/WEB-INF/lib 手动发布

## Maven

1. 依赖的scope

   去除部署不需要的jar包

```xml
<dependency>

    < groupId>javax.servlet</groupId>

    < artifactId>jsp-api</artifactId>

    < version>2.0</version>

    < scope>provided</scope>

< /dependency>
```

> **compile** 默认的scope，表示 dependency 都可以在生命周期中使用。而且，这些dependencies 会传递到依赖的项目中。适用于所有阶段，会随着项目一起发布 
>
> **provided** 跟compile相似，但是表明了dependency 由JDK或者容器提供，例如Servlet AP和一些Java EE APIs。这个scope 只能作用在编译和测试时，同时没有传递性。     
>
> **runtime** 表示dependency不作用在编译时，但会作用在运行和测试时，如JDBC驱动，适用运行和测试阶段。 
>
> **test** 表示dependency作用在测试时，不作用在运行时。 只在测试时使用，用于编译和运行测试代码。不会随项目发布。 
>
> **system** 跟provided 相似，但是在系统中要以外部JAR包的形式提供，maven不会在repository查找它。

```css
你通过maven引入的jar包，里面的类，都是已经编译好的字节码，跟runtime或者provided没关系。

简单来说，compile、runtime和provided的区别，需要在执行mvn package命令，且打包格式是war之类（而不是默认的jar）的时候才能看出来。

通过compile和provided引入的jar包，里面的类，你在项目中可以直接import进来用，编译没问题，但是runtime引入的jar包中的类，项目代码里不能直接用，用了无法通过编译，只能通过反射之类的方式来用。

通过compile和runtime引入的jar包，会出现在你的项目war包里，而provided引入的jar包则不会。
```

