# 位运算

## 负数二进制

正数二进制的反码即为负数二进制

```
1的二进制：0000 0001
1的反码：1111 1110
1的补码：1111 1111 （反码+1）
```

## 使用示例

- Java提供的位运算符：
  - 左移( << )、右移( >> ) 、无符号右移( >>> ) 
  - 位与( & ) 、位或( | )、位非( ~ )、位异或( ^ )

```java
System.out.println(5>>3);//结果是0
System.out.println(-5>>3);//结果是-1
System.out.println(-5>>>3);//结果是536870911

5：0000 0000 0000 0000 0000 0000 0000 0101
5右移3：0000 0000 0000 0000 0000 0000 0000 0000 // (用0进行补位)
-5： 1111 1111 1111 1111 1111 1111 1111 1011
-5右移3：1111 1111 1111 1111 1111 1111 1111 1111 // (用1进行补位)
-5无符号右移3：  0001 1111 1111 1111 1111 1111 1111 1111   // (用0进行补位)
```

## 异或操作

> - a= 0\^a = a\^0
> - 0=a\^a
> - 由上面两个推导出：a=a\^b\^b

# 复杂度

## 时间复杂度

书写规则：

> ①忽略常数项，用O(1)表示
>
> **③递归的时间复杂度=递归总次数 \* 每次递归中基本操作所执行的次数**

分类：

> O(1)常数型、O(log2 n)对数型、O(n)线性型、O(nlog2n)二维型、O(n^k)次幂型、 O(2^n)指数型

## 空间复杂度

==计算整个算法的辅助空间单元数，既：除问题模型外创建的额外空间；原地算法（无额外空间损耗）为O(1)==

书写规则：

> ①忽略常数项，用O(1)表示
>
> **②递归算法的空间复杂度=递归深度N*每次递归所要的辅助空间**（无辅助空间为O(N)）

# 递归算法

## 概念

> - 函数调用自己
> - 要有边界
> - 每次调用影响函数入参或变量
> - 在边界处跳出一次递归调用

## 调用栈

- JVM中的栈记录了线程的方法调用。每个线程拥有一个栈。

- 调用栈的基本单位：栈帧( frame )
  - 每次函数调用时， 都会相应地创建一帧， 在帧中，保存有该方法调用的参数、局部变量和返回地址
  - 在栈中，只保存有基本类型的变量和对象引用，而引用所指向的对象保存在堆中
  - 当被调用方法运行结束时，该方法对应的帧将被删除，参数和局部变量所占据的空间也随之释放。线程回到原方法，继续执行。当所有的栈都清空时，程序也随之运行结束

## 递归分类

### 线性递归

```java
// 计算阶乘
long Fact(long n)
{
    if (n<0) {return -1;}
    return n=-0?1: n* Fact(n - 1);
}
```

### 二分递归

```java
// fibonacci
int Fib(int n)
{
    return n < 2 ? n : (Fib(n-1) + Fib(n-2));
}
```

### 尾递归

> 1. 一个方法内部，递归调用后直接return，没有其他的指令
> 2. **尾递归每次调用都在收集结果；**比线性递归多一个参数，这个参数保存上次调用想要得到的结果
>
> ```java
>  public static int acc(int n){
>         if(n == 1){
>             return 1;
>         }
>         return n + acc(n - 1);
>         --- 相当于如下，在递归调用之后还有一个add操作，所以这里不是尾递归
>         int r = acc(n - 1);
>         return n + r;
>     }
> ```

- **尾递归优化**

> 由于尾递归调用发生在函数末尾，它自己的栈帧中已经没有需要被使用的东西了，也就可以让**下次递归调用直接覆盖使用当前的栈帧**，从而优化栈空间
>
> **Java没有尾调用优化**；调用到最深层直接弹出递归调用的所有栈，而不是线性递归一层一层返回

### 互递归

- FunA调用FunB, FunB递归调用FunA；多个函数相互调用

```java
bool IsOddNumber(int n)
{
    if (0 == n){return false;}
    else{return IsEvenNumber(n - 1);}
}
bool IsEvenNumber(int n)
{
    if (0 == n){return true;}
    else{return IsOddNumber(n - 1);}
}
```

### 嵌套递归

- 参数中递归调用
- 除嵌套递归外，所有递归都可以转换为迭代
- 阿克曼函数：

$$
A(m,n)\left\{
\begin{aligned}
&n+1;&m=0,n>0\\
&A(m-1,1);&n=0,m>0\\
&A(m-1,A(m,n-1));&n>0,m>0 
\end{aligned}
\right.
$$

```java
int Ackermann(int x, int y)
{
    if (x < 0 || y < 0)
    {
        return -1;
    }
    if (0 == x)
    {
        return y + 1;
    }else if (x > 0 && 0 == y)
    {
        return Ackermann(x - 1, 1);
    }else
    {
        return Ackermann(x - 1, Ackermann(x, y - 1));
    }
}
```

# 动态规划

==核心：大事化小，小事化了 --> 复杂问题简单化==

> 三个重要概念：
>
> 1. 边界
> 2. 最优子结构
> 3. 状态转移公式

## 爬楼梯

有一座高度是**10**级台阶的楼梯，从下往上走，每跨一步只能向上**1**级或者**2**级台阶。要求用程序来求出一共有多少种走法？

### 迭代求解

==自底向上==

![image-20210430162518662](https://tva1.sinaimg.cn/large/008i3skNly1gq1ulbq3h2j30gi06waag.jpg)

```java
// 迭代法
public static int stairs(int num) {
    if (num < 1) {
      return 0;
    }
    if (num == 1) {
      return 1;
    }
    if (num == 2) {
      return 2;
    }
    int a = 1, b = 2, sum = 0;
    for (int i = 3; i <= num; i++) {
      sum = a + b;
      a = b;
      b = sum;
    }
    return sum;
  }
```

> 时间复杂度：O(N)
>
> 空间复杂度：O(1)

### 递归求解

==自顶向下==

![image-20210501214853244](https://tva1.sinaimg.cn/large/008i3skNly1gq39kbd4nxj30dt07e3z1.jpg)

```java
public static int recursive(int num) {
    return n < 2 ? n : recursive(n - 1) + recursive(n - 2);
}

public static int tailRecursive(int num, int a, int b) {
    return num < 3 ? b : tailRecursive(num - 1, b, a + b);
}
```

> 时间复杂度：O(2^N^)
>
> 空间复杂度：O(N)

![image-20210430162748543](https://tva1.sinaimg.cn/large/008i3skNly1gq1unxebs5j30ot0c20x0.jpg)

### 备忘算法

==优化递归==

> 将递归过程中，重复的函数只执行一次，其结果存在HashMap中，在需要时进行读取

```java
Map<Integer, Integer> map = new HashMap<Integer, Integer>();
  public static int memo(int num, Map<Integer, Integer> map) {
   if (num < 3) {
      return num;
    }
    if (map.containsKey(num)) {
      return map.get(num);
    } else {
      int value = memo(num - 1, map) + memo(num - 2, map);
      map.put(num, value);
      return value;
    }
  }
```

> 时间复杂度：O(N)
>
> 空间复杂度：O(N)

![image-20210430163352795](https://tva1.sinaimg.cn/large/008i3skNly1gq1uu8flrtj30n60c3tcz.jpg)

## 挖金矿

有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？

### 问题简化

![image-20210501223802740](https://tva1.sinaimg.cn/large/008i3skNly1gq3azh3akkj30xq0nwdzh.jpg)

### 动规分析

![image-20210501223723744](https://tva1.sinaimg.cn/large/008i3skNly1gq3ays6o2gj30iw0asta0.jpg)

### 结果表格

![image-20210501223835249](https://tva1.sinaimg.cn/large/008i3skNly1gq3b00wvg8j30xp07qwmq.jpg)

![image-20210501223907670](https://tva1.sinaimg.cn/large/008i3skNly1gq3b0lehqkj30gr087wfg.jpg)

### 代码实现

```java
//不需要存储整个表格,只需要存储前一行的结果,就可以推导出新的一行
public static int dynamic(int n, int w, int[] g, int[] p) {
    int[] preLineResults = new int[w + 1];
    int[] results = new int[w + 1];
    // 填充边界格子(第一行)的值
    for (int i = 0; i <= w; i++) {
        if (i < p[0]) {
            preLineResults[i] = 0;
        } else {
            preLineResults[i] = g[0];
        }
    }
    // 填充其余格子的值, 外层循环是金矿数量, 内层循环是工人数
    for (int i = 1; i < n; i++) {
        for (int j = 0; j <= w; j++) {
            if (j < p[i]) {
                results[j] = preLineResults[j];
            } else {
                results[j] = Math.max(preLineResults[j], preLineResults[j - p[i]] + g[i]);
            }
        }
        preLineResults = results.clone();
    }
    return results[w];
}

public static void main(String[] args) {
    int[] w = {400, 500, 200, 300, 350};
    int[] p = {5, 5, 3, 4, 3};
    int res = dynamic(5, 10, w, p);
    System.out.println(res);
}
```

> 时间复杂度：O(N*W)
>
> 空间复杂度：O(W)

# 斐波那契

$$
F(n)\left\{
\begin{aligned}
&1，当n=0\\
&1，当n=1\\
&F(n-1)+F(n-2)，当n>1
\end{aligned}
\right.
$$

## 递归求解

```java
// 线性递归；O(2^N)
int Fib(int n)
{
    return n < 2 ? 1 : (Fib(n-1) + Fib(n-2));
}

// 尾递归；O(N)
 int tailRecursive(int n, int one, int two) {
    return n < 2 ? two : tailRecursive(n - 1, two, one + two);
  }
```

## 迭代求解

```java
// 动态规划,{0,1,1,2...}
int Fib(int n)
{
    int one = 0, two = 1, res = 0;
    for (int i = 2; i <= n; i++) {
      res = one + two;
      one = two;
      two = res;
    }
    return res;
}
```

# 排序

# 查找

# 数组

# 链表

# 树

# 图

# 经典算法

- 汉诺塔
- 八皇后

# 问题收集

## x的n次方

1. 迭代法，O(n)

```java
int function1(int x, int n) {
    int result = 1;  // 注意 任何数的0次方等于1
    for (int i = 0; i < n; i++) {
        result = result * x;
    }
    return result;
}
```

2. 递归法，O(n)

```java
int function2(int x, int n) {
    if (n == 0) {
        return 1; // 同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}
```

3. 优化递归，O(logn)

```java
// 二分法
int function4(int x, int n) {
    if (n == 0) {
        return 1;
    }
    int t = function4(x, n/2);
    if (n % 2 == 1) {
        return t*t*x;
    }
    return t*t;
}
```

## 两数交换

- 异或

```java
a = a ^ b
b = a ^ b
a = a ^ b
```

- 加减法

```java
a = a + b;
b = a - b;
a = a - b;
```

## 字符串交换

```java
s1 = s1 + s2;
s2 = s1.substring(0, s1.length() - s2.length());
s1 = s1.substring(s2.length());
```

