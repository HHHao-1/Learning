![image-20210904183615825](https://tva1.sinaimg.cn/large/008i3skNly1gu4s2c40tmj60o20cw0ti02.jpg)



# 如何设计一个关系型数据库

存储的对象是块或者页，它们由多行数据组成

存储管理：数据的逻辑关系转换为物理存储关系的存储管理模块

缓存机制：优化执行效率缓存模块

SQL解析模块：sql语句解析

日志管理：记录操作的日志管理模块

权限划分：进行多用户管理

容灾机制：灾难恢复模块

索引管理：优化数据查询效率

锁管理：使得数据库支持并发操作

![image-20210904203311451](https://tva1.sinaimg.cn/large/008i3skNly1gu4vg06t1wj60ou0fgt9y02.jpg)

# 索引

![image-20210904203348358](https://tva1.sinaimg.cn/large/008i3skNly1gu4vgmhb4sj30qs0kq75f.jpg)

1. 最简单的方式进行数据查询，他便是全表扫描，既整张表的数据全部或者分批 次加载到内存当中。然后逐个块轮询并返回，非常慢。也有适用的地方，如果数据量很小只有几行，那么比索引方式快，存在即合理。

   索引灵感来自于字典，将主要部分组织起来，如偏旁部首，便很快就能定位到

![image-20210904203934844](https://tva1.sinaimg.cn/large/008i3skNly1gu4vmodo34j30tm0ekjrv.jpg)

2. 能把该记录限定在一定查找范围的字段

![image-20210904204059898](https://tva1.sinaimg.cn/large/008i3skNly1gu4vo3x672j60s609ugm602.jpg)

3. 怎么把索引组织起来才能检索的更高效

![image-20210904204243426](https://tva1.sinaimg.cn/large/008i3skNly1gu4vpx3exqj60u20gyjsr02.jpg)

mysql主要通过b+树实现

二叉查找树：平衡二叉树，左右子树高度差不能超过1

# 时间复杂度，最坏和最优？

![image-20210904204941316](https://tva1.sinaimg.cn/large/008i3skNly1gu4vx61ndoj61b80p6gnm02.jpg)

这样每读入一个节点就要进行一次IO，树很深的话就会有很多次IO，效率就很慢，这时有用到B tree了

# Btree

平衡多路查找树

每个节点最多为m个孩子，这样的树就是m阶b树

示例为3阶b树，现实中远大于三

![image-20210904205642980](https://tva1.sinaimg.cn/large/008i3skNly1gu4w4hky0bj617e0pm41h02.jpg)

ceil（）函数表示取上限 3/2 =2

![image-20210904205836772](https://tva1.sinaimg.cn/large/008i3skNly1gu4w6funu0j616w0jygn302.jpg)

既让每个索引块存储尽可能多的信息，让树的高度尽可能减少IO次数

![image-20210904210357981](/Users/hao/Library/Application Support/typora-user-images/image-20210904210357981.png)

非终端节点关键字，左<右（关键字顺序）

关键字个数比子节点数少1（关键字个数）

如示例：左子树：最左边3、5小于8，最右边13、15>12（既大于所有关键字），9、10处于相邻两个节点之间（子树排列方式）

时间复杂度O（logN）

有新数据插入 结构就会变化

比平衡二叉树矮的多，也不会变成现线性的

# B+树

![image-20210904214337058](https://tva1.sinaimg.cn/large/008i3skNly1gu4xhaaprjj617e0n8gpo02.jpg)

所有数据在叶子节点，必须从根节点检索到叶子节点；

叶子节点按大小顺序连接

![image-20210904214742494](https://tva1.sinaimg.cn/large/008i3skNly1gu4xlj947nj61ao0k6mzj02.jpg)

这个大于或等于ki不是硬性要求

b树知识解决了磁盘io，b+树只需遍历叶子节点就可以解决对全部关键字的扫描，在做范围查询有更高的性能

每条查询效率几乎都是相同的，都是从根节点到叶子节点

![image-20210904215425970](https://tva1.sinaimg.cn/large/008i3skNly1gu4xsj1djej30tk0ja3zn.jpg)

# HASH数据结构

# hash结构？

根须哈希函数的运算，只需一次运算就能找到数据的头指针

查询效率理论上比B+索引高

![image-20210904215653850](https://tva1.sinaimg.cn/large/008i3skNly1gu4xv3j14qj60we0p00vu02.jpg)

排序，不同索引建存在相同哈希值

组合索引中是所有索引字段的hash，不能使用部分索引，b+树支持

表扫描，不同索引建存在相同哈希值，取出bucket中实际数据进行扫描确认

大量：有可能线性

不稳定

![image-20210904220330078](https://tva1.sinaimg.cn/large/008i3skNly1gu4y1yy3wlj618i0o6di302.jpg)

（1）Hash索引仅仅能够满足“=”，“IN”和“<=>”查询，不能使用范围查询。

由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理之后的Hash值得大小关系，并不能保证和Hash运算前完全一样。

（2）Hash索引无法被用来避免数据的排序操作。

由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值得大小关系并不一定和Hash运算之前的值完全一致，所以数据库无法利用索引的数据来避免任何排序运算。

（3）Hash索引不能利用部分索引键查询。

对于组合索引，Hash索引在计算Hash值的时候是组合键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。

（4）Hash索引在任何时候都不能避免表扫描。

前面都已经知道，Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的真实数据进行相应的比较，并得到相应的结果。

（5）Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。

对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。

# 除hash和b+树外

![image-20210904220803839](https://tva1.sinaimg.cn/large/008i3skNly1gu4y6pnntuj608q042t8m02.jpg)

位图索引

表中的某个字段只有几种值的时候，如性别：男女，仅为在这个字段上实现高效的统计

弊端：锁的力度非常大，新增或修改数据时，通常与它在同一个位图的数据都会被锁住

不适合并发多，是合并发少、且统计较多的系统

**通常索引的数据结构就是B+树**

![image-20210904221236639](https://tva1.sinaimg.cn/large/008i3skNly1gu4ybfsinfj610w0godh602.jpg)

密集索引，叶子节点不仅保存建的值，还保存其他列的信息

稀疏：叶子节点仅保存建的值，和该行数据的地址（或主键 ）

![image-20210904221554923](https://tva1.sinaimg.cn/large/008i3skNly1gu4yew6stgj61ao0q20up02.jpg)

mysql存储引擎：

mysia：主键索引、唯一建索引、普通索引，都是稀疏索引

innodb：有且只有一个密集索引

innodb必须有一个主键（密集索引）

问什么必须有主键索引：既非主键索引...

![image-20210904221845966](https://tva1.sinaimg.cn/large/008i3skNly1gu4yhv1ozgj317q0h8763.jpg)

![image-20210904222109852](https://tva1.sinaimg.cn/large/008i3skNly1gu4yke2jhzj61c40ik0uy02.jpg)

![image-20210904222310494](https://tva1.sinaimg.cn/large/008i3skNly1gu4ymh7gd0j616c0nsq5o02.jpg)

innodb：除主键索引外通过两次索引，一次是普通索引稀疏索引自身，一次是主键索引；普通索引数据包括字段值和主键值，主键索引数据包括主键值和行数据，主键索引和对应数据保存在同一个文件当中；所以在加载叶子节点的主键进内存时也加载了对应数据。

myisam： 索引和表数据分开存储，叶子节点存储数据地址，通过辅助索引检索无需访问主键

mysql根目录data目录下

表结构信息存储早**.frm文件，innodb索引和数据在一块，myisam分开存储

![image-20210904224619792](https://tva1.sinaimg.cn/large/008i3skNly1gu4zajh3ggj60ve0g0q5k02.jpg)

![image-20210905190834059](/Users/hao/Library/Application Support/typora-user-images/image-20210905190834059.png)

1. 索引避免全表扫描去查找数据
2. 主键、唯一键等，只要是能让数据具备一定区分性的字段
3. 主流B+-Tree，还有hash，bitMap（mysql不支持）等，mysql，innodb，myisa引擎不显式支持hash
4. ？？

![image-20210905191752618](https://tva1.sinaimg.cn/large/008i3skNly1gu5yvwe6d5j60u20hyq4302.jpg)

![image-20210905191843700](https://tva1.sinaimg.cn/large/008i3skNly1gu5ywtb5bqj60wa0h2abl02.jpg) 1. 慢日志：记录执行比较慢的sql

![image-20210905192041802](https://tva1.sinaimg.cn/large/008i3skNly1gu5yyu4dvjj611c0hydhi02.jpg)

查询系统变量

long_query_time：执行多久会被记录，一般1s

slow_query_log: off关闭状态

slow_query_log_file:日志文件路径

查询系统状态：慢sql条数，只针对本次连接，重新连接清零

![image-20210905192659794](https://tva1.sinaimg.cn/large/008i3skNly1gu5z5tdwlrj61240awaau02.jpg)

设置变量（有些需要重新连接数据库才会刷新），这个重启数据库会恢复初始

或者去配置文件设置---m.cnf，这个是永久设置

![image-20210905192615187](https://tva1.sinaimg.cn/large/008i3skNly1gu5z4maspej60gs038mxb02.jpg)

explain：分析查询性能，一般放在select签名，用于描述mysql如何执行查询操作，以及mysql成功返回结果集需要执行的行数

![image-20210905193639889](https://tva1.sinaimg.cn/large/008i3skNly1gu5zffzgmfj60wq080wf602.jpg)

id：sql执行顺序，id越大，越先执行，如复合查询语句（里面的查询先被执行，id大）

type：mysql找到数据行的方式，性能从最优到最差，index?和all表示走的全表扫描，需要优化

![image-20210905193823158](https://tva1.sinaimg.cn/large/008i3skNly1gu5zh9rs12j619c09kab902.jpg)

extra：

![image-20210905193854526](https://tva1.sinaimg.cn/large/008i3skNly1gu5zhtj5i9j61320fo76802.jpg)

![image-20210905200424995](https://tva1.sinaimg.cn/large/008i3skNly1gu608dnmqjj60xs0baq5802.jpg)

数据表结构操作sql不会进入慢查询，增删改查数据才会

![image-20210905200916964](https://tva1.sinaimg.cn/large/008i3skNly1gu60der05jj611w09e0uy02.jpg)

![image-20210905201039278](https://tva1.sinaimg.cn/large/008i3skNly1gu60etjh5gj60v403mgm102.jpg)

由查询优化器决定使用哪个索引，这里由于主键密集索引存储了其他列的内容，而稀疏索引只存储了地址，计数效率稀疏索引更高。

强制使用主键索引

![image-20210905201353335](https://tva1.sinaimg.cn/large/008i3skNly1gu60i6cyf4j30v803iaam.jpg)

![image-20210905201632655](https://tva1.sinaimg.cn/large/008i3skNly1gu60kz6infj6100042aak02.jpg)

联合索引：多列组成的索引

最左匹配原则：A、B设置为联合索引，where A=? AND WHERE B=?，就会走这个联合索引；如果where A=? 也会走，但WHERE B=?不走

![image-20210905202048193](https://tva1.sinaimg.cn/large/008i3skNly1gu60pf5nerj30x40b076g.jpg)

![image-20210905203601535](/Users/hao/Library/Application Support/typora-user-images/image-20210905203601535.png)

最左匹配原则成因：mysql创建复合索引的规则是，首先对复合索引最左边的索引进行排序，就像order by，再对第二个字段进行排序，依次进行，所以第一个索引排序是绝对有序的，第二个就不是，所以不适用第一个字段是用不到复合索引的

![image-20210905211539521](https://tva1.sinaimg.cn/large/008i3skNly1gu62ah150pj31a20kmq5i.jpg)

![image-20210905211555432](https://tva1.sinaimg.cn/large/008i3skNly1gu62aqorfbj60qu04o74r02.jpg)

1. 相当于看个两页的宣传单，谁会去看目录呢
2. 相当于100页的书有50页目录

![image-20210905211752333](https://tva1.sinaimg.cn/large/008i3skNly1gu62ctvdk3j317m0hk76h.jpg)

# 主键、唯一键、普通索引、联合索引、外键？

# 锁

 

![image-20210905212001445](https://tva1.sinaimg.cn/large/008i3skNly1gu62f2svhqj612m0p0mzc02.jpg)

![image-20210905212032626](https://tva1.sinaimg.cn/large/008i3skNly1gu62fkhmlaj61760du40a02.jpg)

myisam不支持事务

mysiam在查询时会自动加上一个表级读锁，阻塞其他会话对表数据的更新

增删改会加上表级别的写锁

有读锁时另一个session想加上写锁就会被阻塞，直到所有读锁被释放为止

显式加锁，释放锁

![image-20210905213453722](https://tva1.sinaimg.cn/large/008i3skNly1gu62uhtqqpj60ne034aa602.jpg) 

读锁是共享锁，不阻塞其他读锁（读操作），既上读锁再上读锁

写锁不是共享的，排它锁，不能再加其他写锁

读操作上排它锁： for update

![image-20210905213930965](https://tva1.sinaimg.cn/large/008i3skNly1gu62zapwqej612u07smys02.jpg)

innodb也有共享锁和排他锁

innodb支持事务，默认自动提交事务

innodb用的二段锁，加锁和解锁分成两个步骤来进行的，既先对一个事务里的一批操作分别进行加锁，commit后再统一解锁，innodb commit是自动提交的，所以看起来和myisam没什么区别

设置自动提交为关，仅适合当前session

innodb默认select不加锁

查询走索引时行级锁以及gap锁（走普通非唯一索引时），不走索引时表级锁 

还有共享读锁IS、排他写锁IX、和没意思吗、差不多，为了表级别的操作时，不去轮询看哪一行加了锁

![image-20210905215124376](https://tva1.sinaimg.cn/large/008i3skNly1gu63bnoaksj60v2060ab102.jpg)

![image-20210905215147177](https://tva1.sinaimg.cn/large/008i3skNly1gu63c2423aj60q805swf802.jpg)

# 增删改用索引吗？显示排它锁？

![image-20210905220258108](https://tva1.sinaimg.cn/large/008i3skNly1gu63npvhc9j60rm0gaab502.jpg)

行级锁一定比表级锁好?

锁的粒度越细代价越高,表级锁在表的头部直接加锁,行级锁还要在扫描到某行时对其上锁

innodb支持事务的同时也带来了更大的开销

![image-20210905220932832](https://tva1.sinaimg.cn/large/008i3skNly1gu63ujicrrj30uc04e74k.jpg)

myisam用一个变量记录里表的行数

![image-20210905221118523](https://tva1.sinaimg.cn/large/008i3skNly1gu63wdgafuj60ys0iqdh302.jpg)

不常用的bdb引擎支持页级锁

# innodb在加锁前会加一个表级别的意向锁？

![image-20210905221745548](https://tva1.sinaimg.cn/large/008i3skNly1gu6432zvhpj60xu0nodi002.jpg)

悲观锁：排它锁；并发访问，先取锁后访问，并一直占用锁直到释放，保守策略

效率方面：处理加锁的机制会产生额外的开销，增加产生死锁的几率

只读程序程序中也没必要上锁，会增加系统负担，降低并行性

乐观锁：认为数据一般不会造成冲突，所以在数据进行提交更新时才会正式对数据的冲突与否进行检测，如果冲突则返回用户错误的信息，让用户决定如何去做

不会使用用户提供的锁机制，实用程序实现，一般乐观锁的实现就是记录数据版本，记录版本两种方式：1.版本号，2.时间戳

不会死锁

悲观锁实现：session之间互锁

乐观锁实现方式：基于数据版本号

![image-20210905222735328](https://tva1.sinaimg.cn/large/008i3skNly1gu64daw107j60x808475j02.jpg)

每更新一次，version+1，提交更新时判断数据库表对应记录的当前版本信息与第一次取出的version值进行比对，如果相等更新，否则认为是过期数据

![image-20210905223502462](https://tva1.sinaimg.cn/large/008i3skNly1gu64l27e5uj616a086wgr02.jpg)

![image-20210905223534089](https://tva1.sinaimg.cn/large/008i3skNly1gu64lm05u3j612k03edgh02.jpg)

# 事务

作为单个逻辑工作单元执行的一系列操作，要么全部执行，全部不执行

原子性：事务包含的全部操作，要么全部执行，要么全部不执行回滚

一致性：数据库的状态从一个一致的状态转变为另外一个一致状态；一致状态：数据应满足完整性约束；A和B的钱加起来一共是2000，不管他两如何转账，最终还是2000

（重点）隔离性：多个事务不并发执行时，一个事务的执行不应该影响其他事务的执行

持久性：一个事务一旦提交，它对事务的修改应该永久保存在数据库中；意味着当系统故障时，已提交事务的更新不能丢失，对已提交事务的更新能恢复，持久性主要在于ddms的恢复性能；如innodb：将所有数据的修改操作写入一个专门的文件，并在数据库启动时从此文件进行恢复操作

# 事务隔离

mysql会利用锁机制创建出不同的事务隔离级别

![image-20210906155446667](https://tva1.sinaimg.cn/large/008i3skNly1gu6ymuibgdj61780awgnl02.jpg)

1. 各种事务隔离级别mysql已经做好,数据库层面层不好模拟

![image-20210906155339591](https://tva1.sinaimg.cn/large/008i3skNly1gu6ylpk114j615a0gqgo302.jpg)

2. 脏读:一个事务读到另一个事务未提交的更新数据;避免:已提交-读  事务隔离级别

   未提交读--最低的隔离级别,既会读到未提交数据

   查看隔离级别、设置隔离级别、开启事务（这里是用start（每次都要执行一遍）、之前是取消自动提交）

   ![image-20210906160008598](https://tva1.sinaimg.cn/large/008i3skNly1gu6ysfu27zj60r603oq3a02.jpg)

![image-20210906160159738](https://tva1.sinaimg.cn/large/008i3skNly1gu6yucq7i5j60va06w75c02.jpg)

改变隔离级别：![image-20210906163442995](https://tva1.sinaimg.cn/large/008i3skNly1gu6zseq8zej60ok018dfw02.jpg)

#DDL\DML?

3.不可重复读：事务A对数据的多次读取中，B对数据进行了修改，A多次夺取数据不一致，A取出的值并不可靠。如果我要以这个值进行操作呢。

解决：设置mysql默认事务隔离级别：repeatable read：这时不管B是否修改，A读的数据都和第一次一样

那这样并发数据就不一致了，怎么解决？

 ![image-20210906165203585](https://tva1.sinaimg.cn/large/008i3skNly1gu70agf9qoj60te01e0su02.jpg)

4. 幻读：事务A读取与搜索条件相匹配的若干行，事务B以插入或删除行等方式来修改事务A的结果集，导致事务A看起来像出现幻觉一样

   在 repeatable-read 级别下，mysql虽然用的行级锁，但插入数据时，在有共享读锁的情况下也被block住，read commit级别就不行了

![image-20210906170646170](https://tva1.sinaimg.cn/large/008i3skNly1gu70pr4bbjj60oa05eq3t02.jpg)

![image-20210906170721548](https://tva1.sinaimg.cn/large/008i3skNly1gu70qd1wybj60os05e0te02.jpg)

完全避免幻读：A、B设置串读隔离级别，最高级别，可以去掉lock share mode了，只有在这个级别下所有的sql执行都会加上锁

![image-20210906170836311](https://tva1.sinaimg.cn/large/008i3skNly1gu70rnpviqj60m0016t8q02.jpg)

### ![image-20210906171122001](https://tva1.sinaimg.cn/large/008i3skNly1gu70ujr2zuj617e0ju0w802.jpg)

![image-20210906171142968](https://tva1.sinaimg.cn/large/008i3skNly1gu70uw72xtj617w0o4q7402.jpg)

更新丢失在数据库层面很难复现，实际一般出现在程序层面

事务隔离级别越高，串行化越高，并发性能越差

# 可重复读，怎么避免幻读的？

![image-20210906171632794](https://tva1.sinaimg.cn/large/008i3skNly1gu70zxbsvij61300dedhb02.jpg)

当前读：读取记录的最新版本，加锁，其他并发不能修改此记录

这里程序实例是指mysql sever的实例

![image-20210906183116388](https://tva1.sinaimg.cn/large/008i3skNly1gu735qgk89j60tm0q076202.jpg)

这里快照读不加锁是指，事务隔离级别不在serializable级别下；rr级别（read commit）快照读可能读到的不是数据最新版本 而是历史版本，先读后操作，读的事历史；先操作后读，读的事最新；

![image-20210906192038351](https://tva1.sinaimg.cn/large/008i3skNly1gu74l1ubfoj614k0k8gn002.jpg)

如何实现快照读？

![image-20210906192948231](https://tva1.sinaimg.cn/large/008i3skNly1gu74ukt7thj61880dm75q02.jpg)

事务对行记录的更新过程

这里的DB_ROE_ID就是之前没创建主键时，innodb自己创建的隐藏主键

1. 加排它锁
2. 原来的数据拷贝一份到undo log
3. 填写当前行的值
4. 修改事务id
5. 使用回滚指针指向修改前的行
6. 在这之后还有别的事务在用快照读，读取该日志记录，对应的undo log还没有被清除，此时某个事务又对同一行数据做了修改，就又多了一条undo log记录，数据的多个版本就是这样实现的，数据的从近到远有DB_ROLL_PTR连接起来

![image-20210906193011766](https://tva1.sinaimg.cn/large/008i3skNly1gu74v05khkj616m0eota702.jpg)

![image-20210906193535423](https://tva1.sinaimg.cn/large/008i3skNly1gu750lpdekj61720ju0ut02.jpg)

![image-20210906193634932](https://tva1.sinaimg.cn/large/008i3skNly1gu751mvhgmj616k0h0q4j02.jpg)

read view 可见性判断，执行select快照读时，会根据所读数据创建一个read view，来决定当前事务能看到的是哪个版本的数据

read view遵循一个可见性算法，将要修改的数据的DB_TRX_ID,取出来与系统其他活跃事务id作对比，如果大于或者等于这些id，就通过db_roll_ptr指针取出undo log上一层的DB_TRX_ID直到小于这些活跃事务id为止，这样就保证了我们看到的数据版本是当前可见的最稳定的版本

rc下每次操作都会创建一个read view，使用可以快照读，看到别的事务的更改

rr下第一次创建read view，之后一直使用这个，如果在修改之前创建就读不到最新的

读取数据时的非阻塞就是所谓的mvcc多版本并发控制，这里innodb实现了伪mvcc，读不加锁，读写不冲突，在读多写少的应用中读写不冲突很重要；

![image-20210906194956756](https://tva1.sinaimg.cn/large/008i3skNly1gu75fj89ynj614q0e0dhb02.jpg)

gap锁，间隙锁，索引树中插入新纪录的空隙

锁定一个范围，但不包括记录本身

gap锁就是rr及以上级别避免幻读的原因

![image-20210906195528800](https://tva1.sinaimg.cn/large/008i3skNly1gu75lakl07j615q0dkgnd02.jpg)

![image-20210906195609702](https://tva1.sinaimg.cn/large/008i3skNly1gu75lztsdaj619k0d80u102.jpg)

![image-20210906195658618](/Users/hao/Library/Application Support/typora-user-images/image-20210906195658618.png)

# 语法

avg：求平均值

![image-20210906195818316](https://tva1.sinaimg.cn/large/008i3skNly1gu75o8aao3j60zw0ik75502.jpg)

group by：

select中用到的列要么在group by里，要么是用到上述统计函数的列，该条件只对同一张表成立

![image-20210906200054151](https://tva1.sinaimg.cn/large/008i3skNly1gu75qxfjkrj612209sq3s02.jpg)

![image-20210906200124168](https://tva1.sinaimg.cn/large/008i3skNly1gu75rgxli1j60r80j8aap02.jpg)

![image-20210906200155968](https://tva1.sinaimg.cn/large/008i3skNly1gu75s05yb2j60sa07ujss02.jpg)

![image-20210906200205069](https://tva1.sinaimg.cn/large/008i3skNly1gu75s5huglj60we06a0ts02.jpg)

![image-20210906200217176](https://tva1.sinaimg.cn/large/008i3skNly1gu75sdbmmqj60r6074q3r02.jpg)

![image-20210906200637782](https://tva1.sinaimg.cn/large/008i3skNly1gu75ww49yoj60j803sgm002.jpg)

![image-20210906200649919](https://tva1.sinaimg.cn/large/008i3skNly1gu75x384esj60ku05mq3e02.jpg)

这个就会报错，group by里没有course_id

select里不能有group by里不包含的列，除非加了统计函数，这个条件只适合同一张表

![image-20210906201403289](https://tva1.sinaimg.cn/large/008i3skNly1gu764mc7j5j611003ajsd02.jpg)

![image-20210906201638203](https://tva1.sinaimg.cn/large/008i3skNly1gu767b9e4uj60r008i75202.jpg)

where一定要在group by前面

![image-20210906201719700](https://tva1.sinaimg.cn/large/008i3skNly1gu7680zn6yj612202kt9702.jpg)

# jion联合查询和不加区别？

![image-20210906201805149](https://tva1.sinaimg.cn/large/008i3skNly1gu768tjr08j61180g8gmr02.jpg)

![image-20210906202140143](https://tva1.sinaimg.cn/large/008i3skNly1gu76cj9gi9j60ja02ywer02.jpg)

如果没有group by，having和where一样

select s.id,stu.name from score s,student stu where s.stuid=stu.stuid group by s.id having count(\*)<(select count(\*) from course)

复杂sql要想到三点

# 总结

![image-20210906202954564](https://tva1.sinaimg.cn/large/008i3skNly1gu76l3rrd8j612i0m2q4902.jpg)

![image-20210906202943007](https://tva1.sinaimg.cn/large/008i3skNly1gu76kwxsoaj60ra0k63zl02.jpg)

![image-20210906203002175](https://tva1.sinaimg.cn/large/008i3skNly1gu76l8z5lrj30rk0hy75f.jpg)

![image-20210906203010171](https://tva1.sinaimg.cn/large/008i3skNly1gu76le30zzj60xm0mqtam02.jpg)

![image-20210906203038264](https://tva1.sinaimg.cn/large/008i3skNly1gu76lvqpqqj60oy09yaa702.jpg)

如何从题目剥离关键语句，进而拼接

