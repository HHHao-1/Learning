![image-20211001214142929](https://tva1.sinaimg.cn/large/008i3skNly1gv05605zrqj60xg0jwdhc02.jpg)

![image-20211001214231140](https://tva1.sinaimg.cn/large/008i3skNly1gv056u17t7j30za0heab4.jpg)

error：系统致命错误，一般指与jvm相关的问题，如：系统崩溃，虚拟机错误，内存空间不足方法调用栈溢出等；

![image-20211001214526104](https://tva1.sinaimg.cn/large/008i3skNly1gv059vq041j317c0gwjtq.jpg)

runtimeException：数组下标越界，访问空指针等

非runtimeException：如ioexception，sqlexception

![image-20211001214648122](https://tva1.sinaimg.cn/large/008i3skNly1gv05bao6c0j615c0lwac302.jpg)

![image-20211001214806698](https://tva1.sinaimg.cn/large/008i3skNly1gv05cnytlpj612k0komz902.jpg)

  ![image-20211001220023171](https://tva1.sinaimg.cn/large/008i3skNly1gv05pfmqwuj31420m441m.jpg)

![image-20211001220245240](https://tva1.sinaimg.cn/large/008i3skNly1gv05rw98gbj611c0jsq4n02.jpg)

![image-20211001220824456](https://tva1.sinaimg.cn/large/008i3skNly1gv05xrscguj612g0hadi302.jpg)

![image-20211001221114049](https://tva1.sinaimg.cn/large/008i3skNly1gv060pk15mj613y0j0q5h02.jpg)

![image-20211001221058862](https://tva1.sinaimg.cn/large/008i3skNly1gv060gb3p9j30wk0jc40d.jpg)

![image-20211001221319921](https://tva1.sinaimg.cn/large/008i3skNly1gv062wct7ij313s0ck75d.jpg)

![image-20211001221433042](https://tva1.sinaimg.cn/large/008i3skNly1gv064690wzj30xg08amy0.jpg)

![image-20211001221513912](https://tva1.sinaimg.cn/large/008i3skNly1gv064veh0oj613m0gudhg02.jpg)

![image-20211001221558368](https://tva1.sinaimg.cn/large/008i3skNly1gv065n4gzij31320mc76t.jpg)

![image-20211001221640581](https://tva1.sinaimg.cn/large/008i3skNly1gv066dtx52j60va0l076m02.jpg)

![image-20211001221745756](https://tva1.sinaimg.cn/large/008i3skNly1gv067inz13j60pi0qi40r02.jpg)

![image-20211001221841095](https://tva1.sinaimg.cn/large/008i3skNly1gv068grgdrj318a0mwq4u.jpg)

![image-20211001222503594](https://tva1.sinaimg.cn/large/008i3skNly1gv06f3jlzij60wm03awev02.jpg)

vector线程安全动态数组，对外提供的方法基本都是加了sybchronized，需要串行执行，不适用于高并发且性能比较高；故现在很少用

hashset底层用hashmap实现

![image-20211001222638098](https://tva1.sinaimg.cn/large/008i3skNly1gv06gqlnbyj30zg0f4jtq.jpg)

考虑排序用treeset

compareto大于0，则custom1要大于custom2

![image-20211001223231092](https://tva1.sinaimg.cn/large/008i3skNly1gv06mv0oy0j30ys0eg0ug.jpg)

![image-20211001223434692](https://tva1.sinaimg.cn/large/008i3skNly1gv06p0i98uj614i0m2n0o02.jpg)

![image-20211001223557028](https://tva1.sinaimg.cn/large/008i3skNly1gv06qfwdchj61aa05i3zq02.jpg)

tom重复，库护花排序优先于自然排序。

# MAP

KEY:SET

VALUE:LIST

![image-20211002125607412](https://tva1.sinaimg.cn/large/008i3skNly1gv0vlfsrzyj612q0raac002.jpg)

# hashmap默认初始容量16

![image-20211002125956782](https://tva1.sinaimg.cn/large/008i3skNly1gv0vpex1ctj61ee0q2acr02.jpg)

数组每个元素存储链表的头结点

![image-20211002130615508](https://tva1.sinaimg.cn/large/008i3skNly1gv0vvzn1gtj61dg0lmwie02.jpg)

hashmap 大于=8-1树化，低于=6链表化

concurrentmap 大于=8树化，低于=6链表化

![image-20211002132145531](https://tva1.sinaimg.cn/large/008i3skNly1gv0wc3z68bj60ty05cgm002.jpg)

每一个数组元素空间就是一个bucket

get方法，使用hashcode找到bucket位置，再使用equals方法找到正确的节点，最终找到要找的值并返回。

使用final对象作为键是有必要的，因为键不能再放入后发生改变，如String，它也重写了equals和hashcode

![image-20211002133202531](https://tva1.sinaimg.cn/large/008i3skNly1gv0wmtk436j61d80f80uw02.jpg)

负载因子，0.75，超过容量0.75，扩容到原来的两倍

容量是容量因子进行运算，取离得最近的2的倍数

![image-20211002133853515](https://tva1.sinaimg.cn/large/008i3skNly1gv0wtxnuupj60we04ajro02.jpg)

![image-20211002133934849](https://tva1.sinaimg.cn/large/008i3skNly1gv0wunsyxsj61a20j876202.jpg)

```
Node<K,V>[] tab; 
n = (tab =resize()).length;
```

![image-20211002134742412](https://tva1.sinaimg.cn/large/008i3skNly1gv0x342fmnj618g0ca0to02.jpg)

copy移动，耗时

![image-20211002134914601](https://tva1.sinaimg.cn/large/008i3skNly1gv0x4pf1pmj61aq0kaac002.jpg)

![image-20211002135038239](https://tva1.sinaimg.cn/large/008i3skNly1gv0x65ow4wj60mc09k3zf02.jpg)

首次使用时才初始化

![image-20211002135152689](https://tva1.sinaimg.cn/large/008i3skNly1gv0x7g9psnj60v205yt9r02.jpg)

put时，resize初始化table

resize方法：作用：初始化：扩容

![image-20211002140058714](https://tva1.sinaimg.cn/large/008i3skNly1gv0xgwxkstj61500mkad802.jpg)

如果给定了initialCapacity，由于HashMap的capacity都是2的幂，因此这个方法用于找到大于等于initialCapacity的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。

# HashMap：为什么容量总是为2的次幂
HashMap是根据key的hash值决策key放入到哪个桶（bucket）中，通过 tab=[(n - 1) & hash] 公式计算得出。其中tab是一个哈希表

1. 为什么要保证 capacity 是2的次幂呢？
（1）在get方法实现中，实际上是匹配链表中的 Node[] tab 中的数据。
(n - 1) & hash实际上是计算出 key 在 tab 中索引位置，当key的hash没有冲突时，key在HashMap存储的位置就是匹配的node中的第一个节点。如果hash有冲突，就会在node里面节点中查询，直至匹配到相等的key。


（2）因为 n 永远是2的次幂，所以 n-1 通过 二进制表示，永远都是尾端以连续1的形式表示（00001111，00000011）
当(n - 1) 和 hash 做与运算时，会保留hash中 后 x 位的 1，
例如 00001111 & 10000011 = 00000011

这样做有2个好处

&运算速度快，至少比%取模运算块
能保证 索引值 肯定在 capacity 中，不会超出数组长度
(n - 1) & hash，当n为2次幂时，会满足一个公式：(n - 1) & hash = hash % n
2.为什么要通过 (n - 1) & hash 决定桶的索引呢？

（1）key具体应该在哪个桶中，肯定要和key挂钩的，HashMap顾名思义就是通过hash算法高效的把存储的数据查询出来，所以HashMap的所有get 和 set 的操作都和hash相关。
（2）既然是通过hash的方式，那么不可避免的会出现hash冲突的场景。hash冲突就是指 2个key 通过hash算法得出的哈希值是相等的。hash冲突是不可避免的，所以如何尽量避免hash冲突，或者在hash冲突时如何高效定位到数据的真实存储位置就是HashMap中最核心的部分。
（3）首先要提的一点是 HashMap 中 capacity 可以在构造函数中指定，如果不指定默认是2 的 (n = 4) 次方，即16。

public HashMap(int initialCapacity) {
    this(initialCapacity,DEFAULT_LOAD_FACTOR);

（4）HashMap中的hash也做了比较特别的处理，(h = key.hashCode()) ^ (h >>> 16)。
先获得key的hashCode的值 h，然后 h 和 h右移16位 做异或运算。
实质上是把一个数的低16位与他的高16位做异或运算，因为在前面 (n - 1) & hash 的计算中，hash变量只有末x位会参与到运算。使高16位也参与到hash的运算能减少冲突。

例如1000000的二进制是 00000000 00001111 01000010 01000000
右移16位： 00000000 00000000 00000000 00001111
异或 00000000 00001111 01000010 01001111

static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
3.capacity 永远都是 2 次幂，那么如果我们指定 initialCapacity 不为 2次幂时呢，是不是就破坏了这个规则？
答案是不会的，HashMap的tableSizeFor方法做了处理，能保证n永远都是2次幂。 

# hashmap不是线程安全的

hashtable：线程安全；同步

sychronizedMap：线程安全，同步

这两个串行执行，效率比较低；多线程并发情况下，都要竞争通一把锁，导致效率极其低下；

java5后为改进hashtable，concurrenthashmap应运而生

![image-20211002141441476](https://tva1.sinaimg.cn/large/008i3skNly1gv0xv74rqjj60p006ojs502.jpg)

![image-20211002141815898](https://tva1.sinaimg.cn/large/008i3skNly1gv0xywjx7dj610408igmj02.jpg)

![image-20211002141844406](https://tva1.sinaimg.cn/large/008i3skNly1gv0xzipgt5j60z20h0q4d02.jpg)

默认16个segment，既比hashtable效率提高了16倍

将数组逻辑上分为多个子数组，每个子数组分配一把锁，占用此锁，其他数字依旧可以被访问

![image-20211002142728192](https://tva1.sinaimg.cn/large/008i3skNly1gv0y8ht5dtj60zy0juwgk02.jpg)

synchronized只锁定当前链表或者红黑树的首节点

concurrenthashmap不允许插入null键null值，而hashmap允许

concurrenthashmap有本地缓存

![image-20211002144017719](https://tva1.sinaimg.cn/large/008i3skNly1gv0ylu2il6j60wm0ei40j02.jpg)

这里for循环，失败重试，使用CAS机制

使用cas添加，如果失败，break，使用for重试

![image-20211002144549095](https://tva1.sinaimg.cn/large/008i3skNly1gv0yrkpwdhj60wa0goadc02.jpg)

![image-20211002144730353](https://tva1.sinaimg.cn/large/008i3skNly1gv0ytbrgvrj60yc08ut9o02.jpg)

![image-20211002145014698](https://tva1.sinaimg.cn/large/008i3skNly1gv0yw733bwj610u0data302.jpg)

![image-20211002145103914](https://tva1.sinaimg.cn/large/008i3skNly1gv0yx16u7cj60wq0dydh502.jpg)

- **发生冲突关于entry节点插入链表还是链头呢？**
  JDK7:插入链表的头部，头插法
  JDK8:插入链表的尾部，尾插法

Semophore：信号量计数器

Semaphore 只有3个操作：

1. 初始化
2. 增加
3. 减少

```java
 public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        
        //信号量，只允许 3个线程同时访问
        Semaphore semaphore = new Semaphore(3);

        for (int i=0;i<10;i++){
            final long num = i;
            executorService.submit(new Runnable() {
                @Override
                public void run() {
                    try {
                        //获取许可
                        semaphore.acquire();
                        //执行
                        System.out.println("Accessing: " + num);
                        Thread.sleep(new Random().nextInt(5000)); // 模拟随机执行时长
                        //释放
                        semaphore.release();
                        System.out.println("Release..." + num);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }

        executorService.shutdown();
    }
```

![image-20211002153647342](https://tva1.sinaimg.cn/large/008i3skNly1gv108m0uowj612a0hqmze02.jpg)

Lock将锁对象化，进行更细粒度的控制。

Condition对象由Lock对象创建，一个Lock对象可以创建多个Condition对象，主要用于线程的等待和唤醒， 既将wait，notify，notifyall进行对象化

Lock、Condition基于AQS来实现的，AQS底层是调用Locksupport.unpark和Locksupport.park去实现线程的阻塞和唤醒

AQS中实现线程挂起的方法，就是park,对应唤醒就是unpark

LockSupport提供的是一个许可，如果存在许可，线程在调用`park`的时候，会立马返回，此时许可也会被消费掉，如果没有许可，则会阻塞。调用unpark的时候，如果许可本身不可用，则会使得许可可用

可重入读写锁：读锁可以共存

原子类，具有原子操作特征的类:CAS，线程执行atomic方法时不会被别的线程打断：软件层面上非阻塞的，它是在底层硬件上借助处理器的原子指令来保证原子性的

原子更新基本类型，原子更新引用，原子更新数组，原子更新字段

常用：多线程，变量的累加操作

![image-20211002155456607](https://tva1.sinaimg.cn/large/008i3skNly1gv10ri3ornj60ra0gkdgl02.jpg)

四个同步器，作用：协助线程的同步

![image-20211002155747203](https://tva1.sinaimg.cn/large/008i3skNly1gv10ugdrnij614y0ja40002.jpg)

![image-20211002155820545](https://tva1.sinaimg.cn/large/008i3skNly1gv10v1rillj616e0la42n02.jpg)

![image-20211002160104957](https://tva1.sinaimg.cn/large/008i3skNly1gv10xvzbqzj61080ncjts02.jpg)

![image-20211002160336552](https://tva1.sinaimg.cn/large/008i3skNly1gv110ipwm5j616i0m2djt02.jpg)

用于：等待一组任务执行完再执行下一组，且计数器可以重复使用；既再等待一组，再去执行下一组

每次await都阻塞调用线程，计数器为零时，多个线程同时执行

CyclicBarrier也能实现countDownLatch的功能，并且它的计数器n是可以被重置的，也就是说n=0线程被唤醒后，n又能重新回到原有值。

```
CyclicBarrier cyclicBarrier = new CyclicBarrier(3, // 当计数器为0时，立即执行
         () -> System.out.println(Thread.currentThread().getName() + "main end"));
    Runnable run = () -> {
      System.out.println(Thread.currentThread().getName() + "start");
      try {
        cyclicBarrier.await();
      } catch (InterruptedException | BrokenBarrierException e) {
        e.printStackTrace();
      }
      System.out.println(Thread.currentThread().getName() + "end");
    };
    new Thread(run).start();
    new Thread(run).start();
    new Thread(run).start();
```

![image-20211002162623070](https://tva1.sinaimg.cn/large/008i3skNly1gv11o7mbu4j611e0gqwg902.jpg)

![image-20211002162637850](https://tva1.sinaimg.cn/large/008i3skNly1gv11ogxovvj60vi0keacc02.jpg)

作用：限流

![image-20211002162738991](https://tva1.sinaimg.cn/large/008i3skNly1gv11pj278qj61060dwmyc02.jpg)

只能用于两个线程互相交换数据

到达同步点，交换数据

![image-20211002163052360](https://tva1.sinaimg.cn/large/008i3skNly1gv11svyor7j60vy0lm0vk02.jpg)

![image-20211002163231118](https://tva1.sinaimg.cn/large/008i3skNly1gv11um1w2wj613a05o75m02.jpg)

# collections

### blockingqueue接口

![image-20211002163307606](https://tva1.sinaimg.cn/large/008i3skNly1gv11v86z2ij615i0g00ty02.jpg)

如果队列满，入队操作阻塞；

如果队列空了，出队操作    阻塞

![image-20211002164249981](https://tva1.sinaimg.cn/large/008i3skNly1gv125bw6a3j6158096q4h02.jpg)

![image-20211002164421661](https://tva1.sinaimg.cn/large/008i3skNly1gv126x628yj615u0hgq7202.jpg)

 3.元素按优先级被移出队列

4.只有延迟期满此元素才能被获取

5.队列只有一个元素

6，2、5合体

7.双端队列

# IO

传统io流，基于字节流和基于字符流

![image-20211002185156736](https://tva1.sinaimg.cn/large/008i3skNly1gv15vpics3j613e0n640p02.jpg)

java4引入nio

![image-20211002185555509](https://tva1.sinaimg.cn/large/008i3skNly1gv15zt6epmj614g0mi77802.jpg)

![image-20211002185627186](https://tva1.sinaimg.cn/large/008i3skNly1gv160cphphj61480gwdgl02.jpg)

![image-20211002185750365](https://tva1.sinaimg.cn/large/008i3skNly1gv161spy0jj615m0fmabi02.jpg)

![image-20211002185828997](https://tva1.sinaimg.cn/large/008i3skNly1gv162h0l1ej60zq0m6jsk02.jpg)

![image-20211002185937594](https://tva1.sinaimg.cn/large/008i3skNly1gv163nmijxj612k0nw3zt02.jpg)

![image-20211002190253957](https://tva1.sinaimg.cn/large/008i3skNly1gv16727mo0j612k0jijto02.jpg)

![image-20211002190542718](https://tva1.sinaimg.cn/large/008i3skNly1gv169zrq5wj610c0no78o02.jpg)

![image-20211002190626185](https://tva1.sinaimg.cn/large/008i3skNly1gv16ar2bvuj611o0mgdjm02.jpg)

![image-20211002190647793](https://tva1.sinaimg.cn/large/008i3skNly1gv16b4f29wj612e0hajtc02.jpg)

![image-20211002190757649](https://tva1.sinaimg.cn/large/008i3skNly1gv16cc0vmfj613a0p2mzm02.jpg)

![image-20211002190945501](https://tva1.sinaimg.cn/large/008i3skNly1gv16e7ci33j617a0csmym02.jpg)

![image-20211002191023758](https://tva1.sinaimg.cn/large/008i3skNly1gv16evddwsj616s0kan0w02.jpg)

![image-20211002191221871](https://tva1.sinaimg.cn/large/008i3skNly1gv16gxat5pj615i0jg0wa02.jpg)

![image-20211002191407864](https://tva1.sinaimg.cn/large/008i3skNly1gv16ircvxnj615k0lcdkc02.jpg)

nio：利用单线程轮询事件的机制，通过高效的定位就绪的channel来决定作什么，仅selector阶段是阻塞的

![image-20211002192202588](https://tva1.sinaimg.cn/large/008i3skNly1gv16qzoxvvj614a0mewiz02.jpg)

aio

![image-20211002192453064](https://tva1.sinaimg.cn/large/008i3skNly1gv16ty1lv6j613a0miq7h02.jpg)

![image-20211002192653480](https://tva1.sinaimg.cn/large/008i3skNly1gv16w0v6e6j60y20g20tt02.jpg)

aio：java7之后支持

![image-20211002192826751](https://tva1.sinaimg.cn/large/008i3skNly1gv16xnbikyj60la0hcdg502.jpg)