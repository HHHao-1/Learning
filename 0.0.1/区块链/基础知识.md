# 区块链

**简介**

> 区块链就像是一个唯一的帐簿，或者说是数据库，记录了该网络中所有交易历史。
>

**区块链名词的由来**

> 比特币数据由一个个区块来存储，并通过哈希的方式将一个个区块连接起来，形成一个区块的链条，所以称之为区块链。
>

**区块链应用场景**

> 资产：数字资产发行、支付(跨境支付)、交易、结算
>
> 记账：股权交易、供应链金融、商业积分、
>
> 不可篡改：溯源、众筹、医疗证明、存在性证明
>
> 点对点：共享经济、物联网
>
> 隐私：匿名交易
>

# 比特币

## 简介

**什么是比特币：**

1. 比特币是数字货币

> 什么是货币：
>
> ```
> 凯恩斯《货币论》货币是可以承载价值的一般等价物
> ```
>
> 什么是数字货币：
>
> ```
> 一串数字（数字被认可，共识）
> ```
>
> 数字货币信任从何而来：
>
> ```
> 财产只受自己控制
> 无通胀（比特币总量2100万个）
> 没有假钞
> 流通性好
> ```

2. 比特币是去中心化记账系统

> 每个节点都存有一份账本数据
>
> 若节点间账本数据不同以谁的为准？-----比特币原理

## 历史

### 密码朋克组织

该组织是一个邮件组

**成员：**

> 维基解密的创始人阿桑奇
>
> BT下载的作者的布莱姆-科恩
>
> ```css
> BT下载是互联网下载方式之一。BT是一种互联网的P2P传输协议，全名"BitTorrent"，中文名"比特流" 
> ```
>
> www的发明者蒂姆伯纳斯-李
>
> 智能合约概念的提出者:尼克萨博
>
> Facebook创始人:肖恩帕克
>
> 比特币之父中本聪
>

**讨论话题：**

> 数学、加密技术、计算机技术、数字货币等

### 比特币的提出

> Adam Back发明了Hashcash，使用了POW（工作量证明）
>
> ```
> hashcash是一个基于hash算法的系统
> 用途：
> 1. 邮件过滤：邮件过滤是hashcash最广泛的应用。
> 2. 比特币：比特币上的应用是为了防止双重支付（double-spending），这个是比特币得以运行的根本，可以防止伪造交易。 
> ```
>
> Haber /Stornetta 提出时间戳方法保证数字文件安全的协议
>
> 戴伟发明了B-money ,强调点对点交易和不可更改记录
>
> 哈尔-芬尼推出了"加密现金"
>
> 2008年中本聪 《比特币:一个点对点的电子现金系统》

## 原理

### 账本如何验证?

如下图账本中：张三偷偷改了数据

![12E611B1-471D-4C29-BE01-B34FE4D71E2B](https://tva1.sinaimg.cn/large/007S8ZIlly1ghg6gg7hbxj30ac07dmyf.jpg)

#### Hash

**简介：**

哈希函数: Hash (原始信息) =摘要信息

> 原始信息包括序号时间和交易记录

通过哈希之后任意的原始信息可以得到一个简短的摘要信息（hash值是一个十六进制字符串）

**特点：**

1. 同样的原始信息用同一个哈希函数总能得到相同的摘要信息

2. 原始信息任何微小的变化都会哈希出面目全非的摘要信息

3. 从摘要信息无法逆向推算出原始信息

> MD5就是一个哈希函数
>

#### 判断账本是否改变

对比摘要信息，就可知道账本是否改变

![2505BAD1-5588-466E-BE18-898E4FD89411](https://tva1.sinaimg.cn/large/007S8ZIlly1ghg6jzjgkpj30f705egmz.jpg)

#### 区块链的形成

1. 接上图，这些信息保存下来就形成了一个区块，序号时间戳hash值称为区块的头

![FA5F1BB8-65A7-4BF1-B7B5-9AFE18E1712A](https://tva1.sinaimg.cn/large/007S8ZIlly1ghel9u80q7j30c505xjrm.jpg)

2. 这时来了第二个账本（比特币每十分钟记账一次）

对这个账本进行hash时会加入第一个账本的hash值进行hash

![266DF037-9A1D-401F-AC18-1F63F3D80E53](https://tva1.sinaimg.cn/large/007S8ZIlly1gheld7m3ojj30gp05oab4.jpg)

3. 以此，就可形成一个区块链，每个节点核对信息的时候只用核对最后一个区块的摘要信息即可

![BD9D80FC-5D9E-4CC8-8D8F-320E28218656](https://tva1.sinaimg.cn/large/007S8ZIlly1ghelghych5j30cd04cq3c.jpg)



### 账户所有权问题?

#### 账户

银行系统（第三方中心化系统）：

> 通过用户开户信息确定账户的所有权

比特币系统：

> 点对点交易（没有第三方）：

比特币账户：

> 由一个地址表示
>
> 转账的过程是把比特币由一个地址转移到另一个地址，账本上不保存任何的个人信息
>
> 以下就是一条转账记录

![32DD5AAB-01C7-4D07-A9E1-69A25ACF4EEB](https://tva1.sinaimg.cn/large/007S8ZIlly1ghellvajdfj30dj06ywf5.jpg)

#### 判断账户所有权

##### 私钥

> 谁拥有私钥谁就能用这个地址进行指支付
>
> 私钥可以推出账户地址（如下图）
>
> 丢失私钥就丢失了地址及地址所有比特币

![DA95231B-E595-4CC8-ACFA-5E201FD505F0](https://tva1.sinaimg.cn/large/007S8ZIlly1ghem0j2l5nj30lu06rjth.jpg)

##### 签名

**如何在不泄露私钥的情况下证明我们拥有某个地址？**

使用非对称加密技术(交易签名)

> 1. 交易进行hash得到摘要
>
> 2. 用私钥对摘要进行签名

![9B4AD7A7-59CF-4684-B20F-00EFF25A8394](https://tva1.sinaimg.cn/large/007S8ZIlly1ghem6kyjq9j30h9089769.jpg)

> 运算：hash运算、签名运算
>
> 信息：摘要信息，私钥，签名信息

##### 广播

签名运算之后付款的节点就会在整个网络里进行广播，广播内容会包含交易的原始信息和交易的签名信息

![069FD0A4-A6E4-4807-8ABE-54751606C489](https://tva1.sinaimg.cn/large/007S8ZIlly1ghemavu5s9j30e209dt9l.jpg)

广播是一个循环的过程，当节点收到广播信息验证成功之后写入账本，然后再向已知相邻的节点进行广播

##### 交易信息验证 

![8E9457F2-9D91-4C70-85A1-F2796825446D](https://tva1.sinaimg.cn/large/007S8ZIlly1ghembd737jj30ij09wmzu.jpg)

> 验证的过程其实还会验证账户是否有足够的余额
>

**补充：**

> 关于用户隐私（账户无个人信息）
>
> 账户安全（私钥不泄露就安全）
>

### 为什么记账? (挖矿)

#### 记账

Hash打包过程（消耗资源）

记账产生奖励（比特币的发行）

**记账规则：**

> 1. 一段时间内只有一人可以记账成功（比特币是10分钟）
>
> 2. 通过解决密码学难题(即工作量证明)竞争获得唯一记账权
>
>    ```
>    解决密码学难题有一定随机性，所以形象的称为挖矿
>    ```
>
> 3. 其他节点只复制第二步记账结果

#### 工作量证明

**普通哈希：Hash(上一Hash值，交易记录集) = 456635BCD**

> 这样的过程太简单，那么人人可记账，所以提高难度

**比特币哈希：Hash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD**

> 比特币要求hash值必须要以n个0开头
>
> 加入随机数，不断改变随机数的值，以得到若干个0开头的hash值---既解决密码学难题（两年前已达到18个0）

**交易记录集：**

> 1. 收集广播中还没有被记录账本的交易
>
> 2. 交易的有效性验证
>
> 3. 添加一笔给自己转账的交易(挖矿奖励)
>
>    ```
>    如果一个节点比其他人更快的找到hash值，整个这个交易会被打包成区块，进入区块链中，这样打包的这个节点获得奖励
>    ```

**工作量分析：**

如下这是一个真实的区块，可在block info上查到

![Voila_Capture 2020-08-05_08-55-47_PM](https://tva1.sinaimg.cn/large/007S8ZIlly1ghg8dozxodj30mv07vdj3.jpg)

> **得到1个0的概率:1/16  .........，消耗巨大，现在都是旷工联合组成矿池，按照算力的百分比进行收益的分成**

#### 总结

因为记账消耗资源，因此比特币系统会奖励参与记账的人，同时引入工作量证明解决了记账冲突的问题

**经济角度：**

只要挖矿还有收益，就会有新的矿工加入，加剧竞争、提高算力的难度，而挖矿就要耗费更多的算力和电力，相互作用，最终的成本接近收益，因我国电力成本较低，相对收益更高，所以中国的算力占据整个网络现在一半以上

### 以谁的账本为准? (共识机制)

#### 同时完成的节点

1. 两个节点同时完成工作量证明,使用谁的区块?

> 无仲裁机构裁决
>
> 都说用我的区块
>

2. 为什么要遵守协议?

> 节点工作量只有在其他的节点认同时是有效的
>

3. 产生分叉时选谁？

> 区块链产生分叉
>
> 选累计工作量最大的区块链-----既独立的、延长最长链

#### 区块链分叉

![8408555E-49F9-4185-8E93-46E6526246AE](https://tva1.sinaimg.cn/large/007S8ZIlly1ghew98e7lcj30v70adgn8.jpg)

> \#3459A和#3459B号区块同时接入区块链
>
> 区块链也有可能先收到#3459B，形成孤块等待#3458B

<u>**选谁：工作量证明+最长链**</u>

### 课外进阶备注

```css
1. 比特币P2P网络

2. 区块结构Merkle树

3. 比特币UTXO及交易脚本

4. 比特币白皮书
```



# 以太坊

## 简介

> 去中心化应用平台
>
> 区块链2.0
>
> 是一个全新开放的区块链平台，允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。就像比特币一样，以太坊不受任何人控制，也不归任何人所有——它是一个开放源代码项目。和比特币协议有所不同的是，以太坊的设计十分灵活，极具适应性，在以太坊平台上创立新的应用十分简便。

## 详述

> 以太坊是可编程的区块链。它并不是给用户一系列预先设定好的操作（例如比特币交易），而是允许用户按照自己的意愿创建复杂的操作。这样一来，它就可以作为多种类型去中心化区块链应用的平台，包括加密货币在内但并不仅限于此。
>
> 以太坊狭义上是指一系列定义去中心化应用平台的协议，它的核心是**以太坊虚拟机（“EVM”）**，可以执行任意复杂算法的编码。在计算机科学术语中，以太坊是“图灵完备的”。开发者能够使用现有的JavaScript和Python等语言为模型的其他友好的编程语言，创建出在以太坊模拟机上运行的应用。
>
> 和其他区块链一样，以太坊也有一个点对点网络协议。以太坊区块链数据库由众多连接到网络的节点来维护和更新。每个网络节点都运行着以太坊模拟机并执行相同的指令。因此，人们有时形象地称以太坊为“世界电脑”。
>
> 这个贯穿整个以太坊网络的大规模并行运算并不是为了使运算更高效。实际上，这个过程使得在以太坊上的运算比在传统“电脑”上更慢更昂贵。然而，每个以太坊节点都运行着以太坊虚拟机是为了保持整个区块链的一致性。去中心化的一致使以太坊有极高的故障容错性，保证零停机，而且可以使存储在区块链上的数据保持永远不变且抗审查。
>
> 以太坊平台本身没有特点，没有价值性。和编程语言相似，它由企业家和开发者决定其用途。不过很明显，某些应用类型较之其他更能从以太坊的功能中获益。以太坊尤其适合那些在点与点之间自动进行直接交互或者跨网络促进小组协调活动的应用。例如，协调点对点市场的应用，或是复杂财务合约的自动化。比特币使个体能够不借助金融机构、银行或政府等其他中介来进行货币交换。以太坊的影响可能更为深远。理论上，任何复杂的金融活动或交易都能在以太坊上用编码自动且可靠地进行。除金融类应用外，任何对信任、安全和持久性要求较高的应用场景——比如资产注册、投票、管理和物联网——都会大规模地受到以太坊平台影响。

## 区块链

> 区块链技术是比特币的底层技术，一个区块链是一个分布式计算架构，里面的每个网络节点执行并记录相同的交易，交易被分组为区块。一次只能增加一个区块，每个区块有一个数学证明来保证新的区块与之前的区块保持先后顺序。这样一来，区块链的“分布式数据库”就能和整个网络保持一致。个体用户与总账的互动（交易）受到安全的密码保护。由数学执行并编码到协议中的经济激励因素刺激着维持和验证网络的节点。
>
> 在比特币中，分布式数据库被设想为一个账户余额表，一个总账，交易就是通过比特币的转移以实现个体之间无需信任基础的金融活动。但是随着比特币吸引了越来越多开发者和技术专家的注意，新的项目开始将比特币网络用于有价代币转移之外的其他用途。其中很多都采用了“代币”的形式——以原始比特币协议为基础，增加了新的特征或功能，采用各自加密货币的独立区块链。

## 核心概念

### 账户

- 外部账户（externally owned accounts），由密钥控制。
- 合约账户（contract accounts），由智能合约的代码控制。

![3059F404-FBE5-4113-A245-34965CF32A1C](https://tva1.sinaimg.cn/large/007S8ZIlly1gh86l6ro5qj30cs07u414.jpg)

**账户里有什么和交易过程**

> 以太坊的账户包括四个字段：一个随机数、账户的余额、合约代码（如果有的话）、存储（通常为空）。
>
> 只有合约账户才有代码，其中存储的是 codeHash（这个账户的以太坊虚拟机代码的哈希值）。这个字段在生成后是不可修改的，这意味着智能合约代码是不可修改的。
>
> 外部账户可以触发交易，而合约账户不能主动发起交易，只能在被触发后按预先写的智能合约代码执行。
>
> 合约账户可以设置多重签名，比如一个简单示例是：现有一个合约账户，它要求一个转账由发起转账的人（Alice）和另一个人（Charles）签名均可。因此，当 Alice 通过这个合约向 Bob 转账 20 个 ETH 时，合约会通知 Charles 签名，在他签名后，Bob 才可以收到这 20 个 ETH（如下图）。

​                                       ![以太坊合约账户的多重签名](http://c.biancheng.net/uploads/allimg/190109/1-1Z109153151442.gif)		

**以太坊的交易和它的区块中存的是什么**

> 和比特币一样，以太坊的区块中存储的也是交易（transaction），它包括的字段主要有：接受者（接受的账户）、发送者的签名、发送者发给接受者的以太币金额等。
>
> 与比特币的区块中存储的是交易不同，以太坊的区块中以梅克尔帕特里夏树（Merkle Patricia Tree,MPT）形式存储的是相应的以太坊账户的状态。
>
> 以太坊的交易是所谓的状态转换函数，一个交易触发它的执行，它将相应的账户从一个状态转变成新状态，然后新状态被存储在区块链的数据区块中。

### 钱包

**功能**

> 获取用户余额，管理地址和密钥，转账、智能合约调用。以太坊钱包一般不用在本地维护区块链数据，只需要使用JSON-RPC访问。

**类型**

> Geth：终端命令行；go-ethereum
>
> MetaMask：浏览器插件
>
> Mist：已停止运营
>

**JSON-RPC**

> JSON-RPC，是一个无状态且轻量级的远程过程调用（RPC）传送协议，其传递内容透过 JSON为主。相较于一般的 REST透过网址（如 GET /user）调用远程服务器，JSON-RPC 直接在内容中定义了欲调用的函数名称（如 {"method": "getUser"}），这也令开发者不会陷于该使用 PUT 或者 PATCH 的问题之中。 本规范主要定义了一些数据结构及其相关的处理规则。它允许运行在基于 Socket、HTTP等诸多不同消息传输环境的同一进程中。其使用 JSON作为数据格式。

### Gas

**交易手续费 gas**

> 费用：Gas价格(用以太币计价) * Gas数量

**以太币单位**

> 最小单位: 1Wei (伟)
>
> 10^9 Wei = 1 Gwei
>
> 10^12 Wei = 1 szabo (萨博)
>
> 10^15 Wei = 1 finey(芬尼)
>
> 10^18 Wei = 1 Ether

### 以太坊网络

**主网（生产网络）： **

- 以太坊官方提供；产生真正有价值的 的以太币的网络

- 优点
  1.全球化的，部署在Internet环境上的，
  2.智能合约的代码，执行，区块的调用，都可以清晰的查看到。
  3.部署在生产环境上的智能合约，全世界任何应用都可以调用
- 缺点：
  1.任何合约执行都会消耗真实的以太币，也就是真实的现金。不适合开发、调试和测试，
  2.所有节点是全球化的，速度较慢
  3.且对于部分商业应用来说，只需要一部分节点，例如分布式部署的10-20台服务器即可。而不需要遍布全球的网络。

**测试网络：**

- 以太坊官方提供；专供用户来开发、调试和测试的网络。 上面的合约执行不消耗真实以太币

- 优点
  1.合约执行不消耗真实货币
  2.全球化的，部署在Internet环境上的，
  3.智能合约的代码，执行，区块的调用，都可以清晰的查看到。
  4.部署在测试环境上的智能合约，全世界任何应用都可以调用
  缺点：
  1.所有节点是全球化的，速度较慢
  2.测试网络不可能作为商业应用的实际落地环境

**私有网络：**

- 由用户自己通过Geth创建的私有网络，是一个非常适合开发、调试和测试的网络

- 优点
  1.方便开发者深入理解以太坊的技术底层
  2.因为节点相对较少，速度较快
  3.用户可以随时创建，随时销毁，随时重建一个以太坊网络
  4.随意的增加节点数目，或者删除节点，
  5.既可以在服务器上建立，也可以在自己的windows或者Mac机器上建立，
  6.甚至一台机器可以建立多个节点，在一台机器上实现多节点的私有网络。
- 缺点
  1.因为不是全球化的，只有在私有网络内的节点才能查看智能合约的执行、调用等。

### 区块链分类

**公有链：**

> 是指对全世界所有人开放的，任何人都可以读取数据、发送交易且交易能够获得有效确认的共识区块链。它不受任何人控制，也不归任何人所有，被认为是“完全去中心化”的区块链。比如ETH、EOS、TRON等
>
> 共有链的特性是公开、透明、去中心化，每个人都可以记账；这样，导致“挖矿”的人越来越多，效率变得更低，验证和完成交易需要更多的时间。例如，以太坊目前的交易速度只有20次每秒。而后起之秀TRON（波场）显得更有优势，每秒处理速度达到了2000次。

**联盟链：**

> 联盟链的各个节点通常有与之对应的实体机构组织，通过授权后才能加入与退出网络。各机构组织组成利益相关的联盟，共同维护区块链的健康运转。
>
> 联盟链和私有链类似，由于节点少，处理速度很快。场景不仅限于交易，也可能是行业信息储存共享等。
>
> 例如物流行业，最早有行业的龙头带领建立区块链联盟，有很多行业企业加入联盟，共同组建物流行业的区块链联盟。每个企业都运行一个节点，要使链上每个区块生效，就得获得51%或者更多的企业节点确认，所有加入的节点都在联盟内以有效或者有限的去中心化形式运行。

**私有链：**

> 区别于共有链开放的特性，私有链就更加私密，仅限在一个企业、组织以及机构内的用户访问和交易。如果把公链当做互联网，那私链就是封闭的局域网。在银行等金融机构应用比较多，用来存放账本和数据库。
>
> 私有链能够防止机构内单节点故意篡改数据，即使发生错误，也能够迅速找到来源。它有交易速度快、成本低，隐秘性高，以及无法篡改的优点。但也有其缺点，权限被少数节点控制，不能根本解决作弊问题，背离了去中心化的初衷等。

## Dapp

**简介**

> 传统互联网应用：中心化,容易更新,数据完全掌控
>
> 去中心化应用：去中心化,按规则运行

**去中心化应用架构**

> 把核心数据放在区块链上，用智能合约管理起来
>
> ![465ECA00-D2A9-4603-B970-5CDAAC53E894](https://tva1.sinaimg.cn/large/007S8ZIlly1gh935pxby2j30g508740z.jpg)
>
> 去中心化应用通过http-rpc访问智能合约，发送交易，交易经矿工打包后确认后，记入区块链，并返回响应消息。而常见的web应用的架构与之非常的相似，UI发送http请求，请求的信息，经过web服务后，请求的信息记入数据库，web服务向客户端返回响应的消息。

 **去中心化应用的开发过程**

> 1. 根据业务场景编写智能合约，编写完成把合约发布到区块链上。
>
> 2. 编写Dapp的 UI界面，使用web3js，经过http-rpc协议访问智能合约。
>
> 3. Dapp发送的每一笔交易，导致合约状态变化，会自动永久记录到区块链上。

**Web** **应用开发过程**

> 1.   编写web 服务，发布web服务。
> 2.    编写UI界面。
> 3.   实现数据持久化。在Web服务里，人工开发实现数据持久化到数据库。

**Dapp与Web应用不同点**

> 1. 界面逻辑：dapp实现了http-rpc、web3js与智能合约进行数据交互；而web app 基于ajax库与web服务进行交互。     
>
> 2. 业务逻辑层：智能合约运行在evm上的，其与系统资源完全隔离的，智能合约不能访问系统的文件、网络。而web 服务不但可以访问到文件，网络，甚至可以访问外部的服务。 
>
> 3.  数据持久化：智能合约拥有独立的存储空间，内存和堆栈。合约变量状态自动地被记录区块链上被持久化。而web服务需要人工开发实现数据的持久化。
>
> 4. web 应用不具备区块链技术特性。智能合约一旦发布即不可更改；区块链数据不可篡改、不可伪造；分布式系统共识算法等特点。

**补充：**

> 1. Web3.js是以太坊提供的一个JavaScript库,它封装了以太坊的RPC通信API,提供了一系列与区块链交互方法,使JavaScript与以太坊交互变得简单。
>
>    以太坊节点通过JSON-RPC提供外部访问接口, Web3.js是基于JavaScript和Node.js的JSON-RPC封装。
>
> 2. 去中心化应用案例：预测平台: Augur；谜恋猫: https://www.cryptokitties.co/

## 客户端分类

进入到Homestead阶段以后，Go客户端占据了主导地位，但情况并不一直是这样，将来也并不必然如此。除了EthereumH，其他客户端都有Homestead兼容的版本。

| 客户端         | 语言       | 开发者       | 最新版本                        |
| -------------- | ---------- | ------------ | ------------------------------- |
| go-ethereum    | Go         | 以太坊基金会 | go-ethereum-v1.4.9              |
| Parity         | Rust       | Ethcore      | Parity-v1.2.1                   |
| cpp-ethereum   | C++        | 以太坊基金会 | cpp-ethereum-v1.2.9             |
| pyethapp       | Python     | 以太坊基金会 | pyethapp-v1.2.3                 |
| ethereumjs-lib | Javascript | 以太坊基金会 | ethereumjs-lib-v3.0.0           |
| Ethereum(J)    | Java       |              | ethereumJ-v1.3.0-RC3-daoRescue2 |
| ruby-ethereum  | Ruby       | Jan Xie      | ruby-ethereum-v0.9.3            |
| ethereumH      | Haskell    | BlockApps    | 尚无Homestead 版本              |

# Solidity

## 简介

> 静态语言
>
> 以太坊Solidity是一种面向智能合约的高级语言，其语法与JavaScript类似。solidity是用于生成在EVM上执行的机器级代码的工具。solidity编译器获取高级代码并将其分解为更简单的指令。Solidity代码封装在Contracts中。
>

合约是以太坊去中心化应用程序的基本构建模块。所有变量和函数都是合约的一部分，这是所有项目的起点。如下示例：

```csharp
version pragma ^0.4.19;
import "solidity_for_import.sol";

contract MyFirst{
    uint a;
    function setA(uint x) public return(uint){ 
        а=x;
    }
}
```

```csharp
//函数
function 函数名 (参数类型 参数名) {internal|external} [pure|constant|view|payable] [public|private] [returns (返回值类型)]{
    //code here
}
```

## 图示

### 接口设计&调用

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gh9a1ro2vaj313x0na403.jpg)

### 编译源码

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gh9a2h1dtmj31az0jtq41.jpg)

### 合约部署

![在这里插入图片描述](https://tva1.sinaimg.cn/large/007S8ZIlly1gh9a35dfutj318n0hd0v7.jpg)

## 结构

### 简介

源文件可以包含任意数量的合约定义，包括指令和pragma指令。

![8F57C52B-03F6-4472-A874-1CB77E4589F7](https://tva1.sinaimg.cn/large/007S8ZIlly1gh3abu2ps5j30g70cyq5v.jpg)

### 编译器版本

Version Pragma是定义代码使用的Solidity编译器版本的声明。

```css
version pragma ^0.4.00;
```

注意：上面显示的源文件不会使用早于版本0.4.0的编译器进行编译，也不能在从版本0.5.0开始的编译器上运行。

### 导入

Ethereum Solidity支持与JavaScript中可用的导入语句非常相似的导入语句，尽管Solidity不知道`default export`的概念。在全局级别，可以使用以下形式的import语句：

```cpp
import "filename";
```

```jsx
import * as symbolName from "filename";
```

### 注释

```cpp
// This is a single-line comment.
/*
This is a
multi-line comment
*/
```

## 存储区域

### 变量存储区域

| 四种存储位置 | 修饰的变量的存储位置                                         |
| :----------- | :----------------------------------------------------------- |
| **storage**  | 永久存储在区块链中                                           |
| **memory**   | 内存中                                                       |
| **stack**    | 栈，前16个元素可以直接访问，否则要pop出其他的，<br />栈深度1024，这是EVM的栈结构，肯定不可能这么大，EVM还要存储其他东西 |
| **calldata** | 只读（不会持久化到区块链中）                                 |

**变量默认存储位置：**

**函数的参数**，**函数的返回值**的**默认数据位置**是**memory**，**函数内局部变量**的**默认数据位置**为**storage**。**状态变量**的**默认数据位置**是**storage**。

**状态变量：** 合约中定义的变量（在函数之外）；

**局部变量：** 函数中的参数、函数内声明的变量。

存储Storage：

```css
永久存储在区块链

storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但内容可以被(交易)调用改变。
Solidity 称这个为状态改变，这也是合约级变量称为状态变量的原因。也可以更好的理解为什么状态变量都是storage存储。

storage 在区块链中是用key/value的形式存储
```

内存Memory：

```css
存储在内存，临时存储，当外部函数对某合约调用完成时，内存型变量即被移除

memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。

memory 表现为字节数组
```

memory位置还包含2种类型的存储数据位置，一种是calldata，一种是栈（stack）

> （1）calldata
>
> ```css
> 这是一块只读的，且不会永久存储的位置，用来存储函数参数。 外部函数（external）的参数（非返回参数）的数据位置被强制指定为 calldata ，效果跟 memory 差不多。
> ```
>
> （2） 栈（stack）
>
> 值类型的局部变量存储在栈上
>
> ```css
> EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。 
> ```

### gas消耗比较

storage ：会永久保存合约状态变量，开销最大；

memory ：仅保存临时变量，函数调用之后释放，开销很小；

stack ：保存很小的局部变量，免费使用，但有数量限制(16个变量)；

calldata ：的数据包含消息体的数据，其计算需要增加n*68的gas费用；

## 状态变量

一个合约的全局变量，既字段。

状态变量是被永久地保存在合约中。也就是说它们被写入以太币区块链中，可以想象成写入一个数据库。

状态变量不能重新赋值，需要通过交易进行。

```csharp
contract Example {
  // 这个无符号整数将会永久的被保存在区块链中
  uint myUnsignedInteger = 100;
}
```

## 修饰符

**函数默认可见性是 public ，状态变量的默认可见性是 internal 。**

| 修饰符                    | 说明                                         |
| ------------------------- | -------------------------------------------- |
| public                    | 公有,任何人(拥有以太坊账户的)都可以调用      |
| private                   | 私有, 只有智能合约内部可以调用               |
| external                  | 仅合约外部可以调用，合约内部需使用this调用   |
| internal                  | 仅合约内部和继承的合约可以调用               |
| view/constant（视图函数） | 函数会读取但是不会修改任何contract的状态变量 |
| pure（纯函数）            | 函数不使用任何智能合约的状态变量             |
| payable                   | 调用函数需要付钱，钱付给了智能合约的账户     |
| returns                   | 返回值函数声明中使用                         |

**注意，所有在合约内的东西对外部的观察者来说都是可见，将某些东西标记为`private`仅仅阻止了其它合约来进行访问和修改，但并不能阻止其它人看到相关的信息。**

## 运算符

**算术运算符**

+、-、*、/、%、**、<<、>>

```csharp
uint x = 10 **  3; // equal to 10^3 = 1000
```

**算数运算符**

<=, <,==, !=, >=, >

**增量运算符**

a++，a-- ，++a，--a，a+=1，a-=1

**按位运算符**

(按位OR）'|'，（按位异或），（按位求反）'~'，（按位右移）'>>'，（按位左移）'<<'

```css
b << 1 equal to b*2**1，右移两位等于除4，一位等于除2
```

**逻辑运算符**

!（逻辑否定），&&（逻辑和），||（逻辑或）

## 值类型

值类型是指变量在赋值过程中是将数据完整的拷贝一份，再赋值给新的变量，这种方式需要开辟新的内存空间，效率较低，两个变量完全独立，修改一个不会影响另外一个。

- 布尔(Booleans)
- 整型(Integer)
- 地址(Address)
- 字符串常量（string）
- 定长字节数组(fixed byte arrays)
- 有理数和整型(Rational and Integer Literals，String literals)
- 枚举类型(Enums)
- 函数(Function Types)

![A3521E5D-39CE-47A2-9745-52B0D9206E83](https://tva1.sinaimg.cn/large/007S8ZIlly1gh98j6lwhfj30wt0ij7lh.jpg)

### 布尔

**关键词：bool**

值是常数，即true或false。

### 整型

**关键字：int（有符号整型，有正有负）/uint（无符号整型，无负数）**

以8位为区间，支持int8，int16，int24 至 int256，uint同理

**int默认为int256，uint默认为uint256**

```csharp
contract MySample{
uint UnsignedInt =50;
}
```

### 地址

**关键字：address**

以太坊地址的长度，大小`20个字节`，每个字节8位，20 * 8 = `160位`，所以可以用一个`uint160`编码。地址是所有合约的基础，所有的合约都会继承地址对象，通过合约的地址串，调用合约内的函数。

**地址成员：balance（属性，其余都是方法）与transfer**,send和transfer类似（不建议使用）

可以使用属性balance查询地址的余额，并使用transfer函数将以太币发送到地址。

```kotlin
address x = 0x123;
address myAddress = this;
if  (x.balance < 10 && myAddress.balance > = 10)
x.transfer(10);
//return addr.balance;
//return this.balance; 返回当前合约账户的余额，可以使用this指针，this表示合约自身的地址
```

### 字符串

String：字符串文字用双引号或单引号

与其他语言的区别：字符串常量没有结尾符，不像C语言一样以\0结束，如"abc"只有三个字节，没有结尾符

```cpp
string language ="Solidity";
```

### 枚举类型

枚举可以显式的转换与整数进行转换，但不能进行隐式转换。显式的转换会在运行时检查数值范围，如果不匹配，将会引起异常。

枚举类型应至少有一名成员，枚举元素默认为uint8，当元素数量足够多时，会自动变为uint16，第一个元素默认为0，使用超出范围的数值时会报错。

```csharp
enum WeekDays {
    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
} 
WeekDays currentDay;
WeekDays defaultday = WeekDays.Sunday;
```

## 引用类型

solidity没有指针，对于复杂的结构进行高效传递方式是使用关键字`storage`进行修饰。

复杂类型，占用空间较大的。在拷贝时占用空间较大。所以考虑通过引用传递。常见的引用类型有：

- 结构体（Structs）

- 数组（Array）
- 映射mappings

### 结构体Structs

structs是自定义类型，可以对多个变量进行分组。

```csharp
pragma solidity ^0.4.0;
contract Ballot {
struct Voter { // Struct
uint weight1, weight2, weight3;
bool voted;
address delegate1, delegate2, delegate3, delegate4;
string name;
uint vote1, vote2, vote3, vote4, vote5;
uint height1, height2, height3   } }
```

注意：结构只能有16个成员，超过该成员可能会发生以下错误：**Stack too Deep 堆栈太深。**

### 数组Arrays

#### 简介

T[k]:元素类型为T,固定长度为k的数组

T[]:元素类型为T,长度动态调整

bytes string是一种特殊的数组

string可转为bytes, bytes类似byte[]

```csharp
uint[3] fixed;  //固定长度3的数组
uint[] dynamic; //动态数组没有固定大小，可以保持增长
```

还可以创建一个结构数组。使用以前创建的Voter结构：

```csharp
Voter[] voting;//voting结构体
```

注意：将数组声明为public将自动为其创建getter方法。

```c#
Voter[] public voting;
```

#### 成员

属性: length

函数: push()

> 变长数组；向数组追加元素，数组长度加1

#### 定长字节数组

- `bytes1`， … ，`bytes32`，允许值以步长1递增。
- byte默认表示bytes1，byte是类型，bytes是类型，bytes1是内置数组
- bytes1只能存储1个字节，即8位的内容，bytes2最多只能存储2个字节，即16位的内容。以此类推…

- 内置方法：length() --> 返回数组长度
- 存储方式：16进制ascii码

```c#
bytes3 public b3 = "xy";
uint public len = b3.length;//b3.length = 10;

bytes8 b8 = "12345678";
bytes1 public b8_0 = b8[0];//b8_0返回0x31，即十进制的数字1的ascii值（3*16+1=49）
```

#### 不定长字节数组

- bytes：不定长度的字节数组 (Dynamically-sized byte array)

  bytes类型可以使用 push() 方法，具有 length 属性

```js
string public name = "itheima.com";
bytes public g = 0x6c697975656368756e;
// 初始化一个两个字节空间的字节数组
bytes public name = new bytes(2);
```

- string： 动态长度的UTF-8编码的字符类型（非值类型）,它其实是一个特殊的可变字节数组

```js
string public str01 = "itheima.com";
```

- solidity中字符串不像JS中那样，没有length()方法，须转换成字节数组才能使用length属性来获得长度

```js
function getStrLegnth(string _str) constant returns (uint) {
	return bytes(_str).length;  // 强制转换string为bytes
}
```

- 一个好的使用原则是:
  bytes用来存储任意长度的字节数据，string用来存储任意长度的UTF-8编码的字符串数据。
  如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。

### 映射mappings

映射本质上是存储和查找数据所用的键-值对，类似map或字典。

映射可以看作是哈希表，它们被虚拟地初始化，使得每个可能的键都存在并被映射到其字节表示全为零的值：类型的默认值。

映射声明为：

```jsx
//mapping(_Keytype => _ValueType )
mapping(address => uint)
```

注意：**键类型**几乎可以是任何类型，除了动态大小的数组，合约，枚举和结构；**值类型**没有任何限制，可以为任何类型包括映射类型。

```jsx
contract MappingExample {
    mapping(address => uint) public balances;
    function update(uint newBalance) {
        balances[msg.sender] = newBalance;  }}
contract MappingUser {
    function f() returns (uint) {
        MappingExample m = new MappingExample();
        m.update(100);
        return m.balances(this);
    }}
```

## 控制结构

除了switch和goto（跳转）之外，JavaScript中的大多数控制结构都在Solidity中可用。

所以有：if，else，while，do，for，break，continue，return，？ ：，使用从C或JavaScript中已知的通常语义。

**注意：没有像C和JavaScript那样从非布尔类型到布尔类型的类型转换。**

```csharp
contract ControlStructure {
    address public a;
    function ControlStructure(){
        // if-else can be used like this
        if(input1==2)
            a=1;
        else
            a=0;
        // while can be used like this
        while(input1>=0){
            if(input1==5)
                continue;
            input1=input1-1;
            a++;}
        // for loop can be used like this
        for(uint i=0;i<=50;i++) { a++; if(a==4) break; } 			//do while can be used like this do { a--; } (while 		a>0);
        // Conditional Operator can be used like this
        bool IsTrue = (a == 1)?true: false;
        /*will show an error because
		there is no type conversion from non-boolean to 			boolean*/
        if(1){}
    }
}
```

## 事件&日志

> 事件event是以太坊提供的基本功能，用于将数据记录成日志保存到区块链上，用户可以自定义需要记录的数据，以及topic和索引；日志是指事件保存在区块链上的数据。事件强调操作行为，日志强调存储内容。

**事件**

使用event 关键字来定义一个事件

```js
event EventName(address bidder, uint amount); 
```

使用emit触发一个事件使用；事件在合约中同样可以被继承

```js
emit EventName(msg.sender, msg.value); 
```

## 函数

函数类型也就是我们所说的函数，本身也是一个特殊的变量，它可以`当做变量赋值`，`当做函数参数传递`，`当做返回值`。

- 构造函数

> 合约初始化

- 视图函数( constant/view)

> 不能修改状态变量

- 纯函数( pure)

> 既不能读取状态变量、又不能修改状态变量
>
> 用来完成一些功能，然后被调用

- 回退函数( fallback )

> 无名函数，一个合约只能有一个，这个函数不能有参数也不能有返回值
>
>  避免在此函数写复杂的逻辑（复杂可能会因为发起交易人gas不够而交易失败）
>
> 智能合约需要接收以太币时，就要实现回退函数，被动调用
>
> 被动调用条件：1.给这个合约(既合约账户)发送以太币时触发
>
> ​						   2.调用的合约没有相匹配的函数时触发

```csharp
contract Test {
    uint internal data;
    constructor (uint a) public { 
        data =a;
    }//构造函数
    function testView() public constant/view returns (uint) {
        return data;
    }//视图函数
    function f() public pure returns (uint ) {
        return 1 * 2;//return 1 * 2+data  错误
    }//纯函数
    function () public payable {
        emit EVENTA(1);
        var a =1 +2;
    }//回退函数
    //接收以太币时必须有payable关键字
```

## 函数参数

- 输入参数

- 输出参数

> 函数的返回值作为参数

- 命名参数

> 字典类型参数

- 参数解构

> 可返回多个不同类型的返回值，返回值可同时赋值给多个变量

**示例：**

```c#
pragma solidity ^0.5.0;

contract modifysample {
	//a、b输入参数；sum、mul输出参数
    function simplelnput(uint a, uint b) public view returns (uint sum,uint mul){
        sum =a + b;
        mul =a*b;
    }
	//{ b:3,a:1}命名参数，与顺序无关；接收变量与顺序有关
    function testSimpleInput() public view returns (uint sum,uint mul) { 
        (sum,mul) = simplelnput({ b:3,a:1});
    }
	//参数结构；solidity内置支持元组
    function f() public view returns (uint, bool , uint) {
        return (7, true, 2);
    }

    function g() public{
        (uint x,bool y,uint z) = f();
        (,y,z) = f();
        (x,)=(1,2);
        (x, z)=(z, x);
    }
}
```

## 函数修改器

相当于Spring中的AOP，既切面处理

### 一个修改器

函数修改器(Modifiers)可以用来改变一个函数的行为。比如用于在函数执行前检查某种前置条件。

修改器是一种可被继承合约属性，同时还可被继承的合约重写(override)。

```c#
pragma solidity ^0.4.11;

contract owned {
    function owned() public { 
        owner = msg.sender; 
    }
    address owner;
    
    // 定义了一个函数修改器，可被继承
    // 修饰时，函数体被插入到 “_;” 处
    // 不符合条件时，将抛出异常
    modifier onlyOwner () {
        require(msg.sender == owner);
        _;//符合条件时selfdestruct(owner)填充到_
    }
    function close() public onlyOwner {
        selfdestruct(owner);
    }
}

contract mortal is owned {
    //  使用继承的`onlyOwner` 
    function close() public onlyOwner {
        selfdestruct(owner);
    }
}

contract priced {
    // 函数修改器可接收参数
    modifier costs(uint price) {
        if (msg.value >= price) {
            _;
        }
    }
}

contract Register is priced, owned {
    mapping (address => bool) registeredAddresses;
    uint price;

    function Register(uint initialPrice) public { 
        price = initialPrice; 
    }

    // 需要提供payable 以接受以太
    function register() public payable costs(price) {
        registeredAddresses[msg.sender] = true;
    }

    function changePrice(uint _price) public onlyOwner {
        price = _price;
    }
}
```

### 多个修改器

如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。

在修改器中或函数内的显式的return语句，仅仅跳出当前的修改器或函数。返回的变量会被赋值，但执行流会在前一个修改器后面定义的"_"后继续执行， 如：

```js
contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(!locked);
        locked = true;
        _;//f()的函数体在这里执行
        locked = false;
    }

    // 防止递归调用
    // return 7 之后，locked = false 依然会执行
    function f() public noReentrancy returns (uint) {
        require(msg.sender.call());
        return 7;
    }
}
```

修改器的参数可以是任意表达式。在此上下文中，所有的函数中引入的符号，在修改器中均可见。但修改器中引入的符号在函数中不可见，因为它们有可能被重写。

### 修改器执行次序

再来看一个复杂一点的例子，来深入理解修改器：

```js
pragma solidity ^0.4.11;

contract modifysample {
    uint a = 10;
    modifier mf1 (uint b) {
        uint c = b;
        _;
        c = a;
        a = 11;
    }
    modifier mf2 () {
        uint c = a;
        _;
    }    
    modifier mf3() {
        a = 12;
        return ;
        _;
        a = 13;
    }    
    function test1() mf1(a) mf2 mf3 public   {
        a = 1;
    }  
    function test2() public view returns (uint)   {
        return a;  
    }  
}
```

上面的智能合约运行test1()之后，状态变量a的值是是 11

我们来分析一下 test1， 它扩展之后是这样的：

```js
uint c = b;
uint c = a;
a = 12;
return ;//不执行
_;//不执行
a = 13;
c = a;
a = 11;
```

## 继承

**Solidity**通过复制包括多态性的代码来支持**多重继承**。

除非合约是显式给出的，所有的函数调用都是虚拟的，绝大多数派生函数可被调用。

当一个合约继承自多个合约时，只会在区块链上创建单个合约，并将所有父合约中的代码复制到创建的合约中。

```c#
pragma solidity ^0.4.16;

contract owned {
    function owned() { owner = msg.sender; }
    address owner;
}
// 使用`is`继承另一个合约。
// 子合约可以访问所有非私有成员，包括内部函数和状态变量。 
// 不过，不能通过`this`来外部访问这些。
contract mortal is owned {
    function kill() {
        if (msg.sender == owner) selfdestruct(owner);
    }
}
// 这些抽象合约仅用于创建编译器已知的接口。 
// 注意函数没有函数体。 
// 如果合约没有实现全部函数，那它只能是接口。
contract Config {
    function lookup(uint id) public returns (address adr);
}

contract NameReg {
    function register(bytes32 name) public;
    function unregister() public;
 }
// 可以多重继承。 
// 请注意，`owned`也是`mortal`的父类，
// 但只有一个`owned`的实例（类似C++中的虚拟继承）。
contract named is owned, mortal {
    function named(bytes32 name) {
        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
        NameReg(config.lookup(1)).register(name);
    }
    //
    //函数可以被另一个具有相同名称和相同数量/类型的输入参数的函数覆盖。
    //如果重写函数有不同输出参数的类型，会发生错误。
    //本地和基于消息的函数调用都会将这些覆盖函数考虑在内。
    function kill() public {
        if (msg.sender == owner) {
            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
            NameReg(config.lookup(1)).unregister();
            // 仍然可以调用特定的重写函数。
            mortal.kill();
        }
    }
}
// 如果构造函数接受参数，参数需要在头部中提供。
// 或者在派生合约的构造器里
// 使用修饰符调用方式modifier-invocation-style
contract PriceFeed is owned, mortal, named("GoldFeed") {
   function updateInfo(uint newInfo) public {
      if (msg.sender == owner) info = newInfo;
   }

   function get() public view returns(uint r) { return info; }

   uint info;
}
```

## 接口&抽象合约

一个合约如何读取其他合约的数据或调用其他合约的方法？

接口的存在就是为了合约之间的通信。

有两种实现方式：抽象合约 和 接口

**1.抽象合约**

抽象函数是没有函数体的的函数。如下：

```javascript
pragma solidity ^0.4.0;

contract Feline {
    function utterance() returns (bytes32);
}
```

这样的合约不能通过编译，即使合约内也包含一些正常的函数。但它们可以做为基合约被继承。

```javascript
pragma solidity ^0.4.0;

contract Feline {
    function utterance() returns (bytes32);
    function getContractName() returns (string){
        return "Feline";
    }
}

contract Cat is Feline {
    function utterance() returns (bytes32) {
        return "miaow";
    }
}
```

如果一个合约从一个抽象合约里继承，但却没实现所有函数，那么它也是一个抽象合约。

**如何通过抽象合约实现接口功能？**

![279B7B85-29E0-42B8-A878-658302F455AA](https://tva1.sinaimg.cn/large/007S8ZIlly1ghcywck1y6j30dw0ehtei.jpg)

**2.接口**

接口与抽象合约类似，与之不同的是，接口内没有任何函数是已实现的，同时还有如下限制：

- 不能继承其它合约，或接口。
- 不能定义构造器
- 不能定义变量
- 不能定义结构体
- 不能定义枚举类

接口基本上限制为合约ABI定义可以表示的内容，ABI和接口定义之间的转换应该是可能的，不会有任何信息丢失。

![CC83BF01-804C-4DEB-96AF-E83DF3DF4486](https://tva1.sinaimg.cn/large/007S8ZIlly1ghcywk3zfcj31010gqtkk.jpg)

注意：

```
1、在两个.sol文件中都声明接口，或者两个合约写到一个.sol文件里，那就只要声明一次；
2、在一个合约中实现METHOD_A，该合同必须继承自接口interfaceContract；
3、在另一个合约中创建一个interfaceContract实例，该实例接受实现接口的合约的地址；
4、通过这个实例调用目标合约的方法，获取目标合约的数据；
```

## 创建实例

```c#
//合约
contract Account{
    ......
}

contract Initialize{
    Account account = new Account(10);
    ......
}
```

```c#
//接口
interface animalEat{
    function eat() public view returns(string);  //定义接口的方法
}

contract interit is animalEat{  //内部实现  直接实现了这个方法

    function eat() public view returns(string){}
}

contract animal{  //外部实现
    //实例化接口  这里的地址是先部署合约cat的地址
    animalEat ae = animalEat(0x692a70d2e424a56d2c6c27aa97d1a86395877b3a); 
    function test()public returns(string){
        return ae.eat();
    }
}
```

## 错误处理(检查)

**什么是错误处理**

> 指在程序发生错误时的处理方式

**处理方式**

> 回退状态
>
> 既：当一个错误发生时就像任何事情没有发生过一样，当然在调用过程中所消耗的gas会消耗掉
>
> 把区块链当做一个全球共享的分布式事务数据库，既要么全部完成、要么全部不完成

**如何处理**

> **assert**、**require**，用于条件检查，条件不满足则抛出异常；**revert**中止执行并恢复状态更改
>
> **assert**函数只能用于检查内部错误和不变量
>
> **require**函数用于检查**输入变量或合同状态变量**是否满足条件以及验证调用外部合约返回值
>
> 注意：捕捉异常是不可能的，因为没有try...catch...

**示例**

```c#
contract Sharer {
    function sendHalf(address payable addr) public payable returns (uint balance) {
        require(msg.value % 2 == 0); // 仅允许偶数
        uint balanceBeforeTransfer = address(this).balance;
        addr.transfer(msg.value / 2); 
         // 如果失败，会抛出异常，下面的代码就不执行
        assert(address(this).balance == balanceBeforeTransfer - msg.value / 2);
        return address(this).balance ;
    }
}
```

## 全局变量和函数

> 全局命名空间中总是存在特殊变量和函数，主要用于提供有关区块链的信息。

### 区块和交易属性

- `block.blockhash(uint blockNumber) returns (bytes32)`: 给定区块的哈希值 - 仅适用于最新的256个区块，不包括当前区块
- `block.coinbase` (`address`)：当前区块的矿工的地址
- `block.difficulty` (`uint`)：当前区块的难度系数
- `block.gaslimit` (`uint`)：当前区块gas限制
- `block.number` (`uint`)：当前区块编号
- `block.timestamp` (`uint`)：当前块的时间戳
- `msg.data` (`bytes`)：完整的calldata
- `msg.gas` (`uint`)：剩余的gas
- `msg.sender` (`address`)：消息的发送方(当前调用)
- `msg.sig` (`bytes4`)：calldata的前四个字节(即函数标识符)
- `msg.value` (`uint`)：所发送的消息中wei的数量
- `now` (`uint`)：当前块时间戳(`block.timestamp`的别名)
- `tx.gasprice` (`uint`)：交易的gas价格
- `tx.origin` (`address`)：交易发送方(完整的调用链)

| 注解                                                         |
| ------------------------------------------------------------ |
| `msg`的所有成员的值,包括`msg.sender`和`msg.value`可以在每个**external**函数调用中改变。这包括调用库函数。 如果你想在库函数实现访问限制使用`msg.sender`, 你必须手动设置`msg.sender`作为参数。 |

| 注解                                                         |
| ------------------------------------------------------------ |
| 不要依赖`block.timestamp`，`now`和`block.blockhash`作为**随机源** |
| 时间戳`timestamp`和区块哈希`blockhash`在一定程度上会受到矿工的影响。 |
| 例如，矿区中的坏节点可以对选定的哈希运行casino payout函数，如果他们没有收到任何钱，只需重试不同的哈希。 |
| 当前块时间戳必须严格大于最后一个块的时间戳，但唯一的保证是它将位于规范链中两个连续块的时间戳之间的某处。 由于区块链是增长可变的，所以不能获取整个区块链的哈希值。 您只能访问最近256个区块的哈希值，其他所有值都将为0。 |

### 数学和加密功能

- `addmod(uint x, uint y, uint k) returns (uint)`:
  计算`（x + y）％k`的值，其中加法以指定精度执行，并且不超过`2 ** 256`。从版本0.5.0开始断言`k！= 0`。
- `mulmod(uint x, uint y, uint k) returns (uint)`:
  计算`（x * y）％k`的值，其中乘法以指定精度执行，并且不超过`2 ** 256`。从版本0.5.0开始断言`k！= 0`
- `keccak256(...) returns (bytes32)`:
  计算（紧凑排列的）参数的Ethereum-SHA-3的Hash值值
- `sha256(...) returns (bytes32)`:
  计算（紧凑排列的）参数的SHA-256 的Hash值
- `sha3(...) returns (bytes32)`:
  `keccak256`的别名
- `ripemd160(...) returns (bytes20)`:
  计算（紧凑排列的）参数的 RIPEMD-160 的Hash值
- `ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`:
  从椭圆曲线签名中恢复与公钥相关的地址，或在错误时返回零

在上述中，“紧凑排列”，意思是没有填充的参数的连续排列，也就是下面表达式是没有区别的

```solidity
keccak256("ab", "c")
keccak256("abc")
keccak256(0x616263)
keccak256(6382179)
keccak256(97, 98, 99)12345
```

如果需要填充，可以使用显式类型转换：`keccak256("\x00\x12")`与`keccak256(uint16(0x12))`相同。
请注意，常量将使用存储它们所需的最小字节数打包。即：
`keccak256(0) == keccak256(uint8(0))`，`keccak256(0x12345678) == keccak256(uint32(0x12345678))`

在一个私有的blockchain里，你可能在使用`sha256`, `ripemd160` 或 `ecrecover` 的时候碰到”Out-of-Gas”的问题 。原因在于这个仅仅是预编译的合约，合约要在他们接到的第一个消息以后才真正的生成（虽然他们的合约代码是硬编码的）。对于没有真正生成的合约的消息是非常昂贵的，这时就会碰到“Out-of-Gas”的问题。 这一问题的解决方法是事先把1wei 发送到各个你当前使用的各个合约上。这不是官方或测试网的问题。

### 地址相关

- `<address>.balance` (`uint256`):
  该地址的余额，单位是Wei
- `<address>.transfer(uint256 amount)`:
  给该地址发送金额，单位是Wei，发送失败抛出异常，消耗2300 gas 费用，不可调整
- `<address>.send(uint256 amount) returns (bool)`:
  给该地址发送金额，单位是Wei，发送失败返回`false`，消耗2300 gas 费用，不可调整
- `<address>.call(...) returns (bool)`:
  发出 **low-level** `CALL`, 失败时返回`false` , 消耗所有可用gas, 可调整
- `<address>.callcode(...) returns (bool)`:
  发出 **low-level** `CALLCODE`, 失败时返回`false` , 消耗所有可用gas, 可调整
- `<address>.delegatecall(...) returns (bool)`:
  发出 **low-level** `DELEGATECALL`, 失败时返回`false` , 消耗所有可用gas, 可调整

欲了解更多资料，请参阅地址Address部分。

| 警告                                                         |
| ------------------------------------------------------------ |
| 使用`send`存在一些危险：如果调用堆栈深度为1024，则转账将失败（调用程序始终强制执行此操作），并且如果接受者的gas耗尽，也会失败。 |
| 因此，为了让以太币转账更安全，请务必检查`send`的返回值，或者直接使用`transfer`那就更好了。 |

| 注解                               |
| ---------------------------------- |
| `callcode`不建议使用，未来将会移除 |

### 合约相关

- `this` **(current contract’s type)**:
  当前的合约，可显式转换为地址Address
- `selfdestruct(address)`：
  销毁当前合约,其资金发送给指定的地址
- `suicide(address recipient)`：
  `selfdestruct`的别名

此外，当前合同的所有函数均可以被直接调用，包括当前函数。
