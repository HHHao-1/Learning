## ABI

ABI全称 Application Binary Interface，字面意思是应用程序二进制接口，可以通俗的理解为合约的接口说明，当合约被编译后，它对应的abi也就确定了。

abi有点类似于程序中的接口文档，描述了字段名称、字段类型、方法名称、参数名称、参数类型、方法返回值类型等

### 为什么需要ABI

我们编写智能合约的流程是：

- 编写合约代码（一般使用solidity语言）
- 编译合约，将solidity编写的代码编译成EVM可识别的bytecode，这一步生成abi
- 部署合约，将合约部署到区块链上，生成合约地址，将合约内容（即上一步生成的bytecode）作为input date输入。部署合约是一个交易过程，所以也会生成一个交易Hash
- 执行合约，获取合约地址，然后传入参数调用合约中的方法，获得执行结果

从上面的步骤可以看出，abi对于EVM来说，其实是不需要的。但是对于调用者来说，就需要知道合约有哪些方法，方法的参数是什么，返回值是什么，而这些信息就记录在智能合约的abi中。所以abi其实就相当于开发者的接口文档，方便开发者调用执行合约

### ABI有哪些内容

编写一个最简单的合约，然后编译生成abi看下内容

```c#
pragma solidity ^0.4.24;

contract Demo {
    uint private x;
    function set(uint _x) public {
        x = _x;
    }
}
```

执行 `truffle compile` 编译合约，就会生成对应的文件`Demo.json`，内容如下。由于json太长，删除了一些不重要的内容，完整内容可以自己手动执行看看。

```json
{
    "contractName": "Demo",
    "abi": [
        {
            "constant": false,
            "inputs": [
                {
                    "name": "_x",
                    "type": "uint256"
                }
            ],
            "name": "set",
            "outputs": [],
            "payable": false,
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ],
    "bytecode": "0x6080604052348015600f57600080fd5b5060a48061001e6000396000f300608060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b1146044575b600080fd5b348015604f57600080fd5b50606c60048036038101908080359060200190929190505050606e565b005b80600081905550505600a165627a7a723058201dfe7c019fec67ccd87250c9ac8642c163cc5f43588715b33e8a8953df3715f60029",
    "deployedBytecode": "0x608060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b1146044575b600080fd5b348015604f57600080fd5b50606c60048036038101908080359060200190929190505050606e565b005b80600081905550505600a165627a7a723058201dfe7c019fec67ccd87250c9ac8642c163cc5f43588715b33e8a8953df3715f60029",
    "sourceMap": "27:97:1:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;27:97:1;;;;;;;",
    "deployedSourceMap": "27:97:1:-;;;;;;;;;;;;;;;;;;;;;;;;69:52;;8:9:-1;5:2;;;30:1;27;20:12;5:2;69:52:1;;;;;;;;;;;;;;;;;;;;;;;;;;;112:2;108:1;:6;;;;69:52;:::o",
    "source": "pragma solidity ^0.4.24;\n\n\ncontract Demo {\n\n    uint private x;\n\n    function set(uint _x) public {\n        x = _x;\n    }\n\n}\n",
    "sourcePath": "/Users/root/Workspace/DApp/demo/contracts/Demo.sol",
    "ast": {
        ...
    },
        "legacyAST": {
            ...
        },
            "compiler": {
                "name": "solc",
                "version": "0.4.24+commit.e67f0147.Emscripten.clang"
            },
            "networks": {},
            "schemaVersion": "2.0.1",
            "updatedAt": "2018-09-14T11:57:49.750Z"
        }
    }
}
```

大部分参数通过名称就可以看出来含义，这里我们主要介绍abi中各参数的含义和调用函数时生成ABI编码的过程

### abi各参数含义

- `name`：函数名称
- `type`：方法类型，包括`function`, `constructor`, `fallback`(缺省方法)可以缺省，默认为`function`
- `constant`：布尔值，如果为true指明方法不会修改合约字段的状态变量
- `payable`：布尔值，标明方法是否可以接收ether
- `stateMutability`：状态类型，包括`pure` (不读取区块链状态)，`view` (和constant类型，只能查看，不会修改合约字段)，`nonpayable`（和payable含义一样），`payable`（和payable含义一样）。其实保留`payable`和`constant`是为了向后兼容
- `inputs`：数组，描述参数的名称和类型
  - `name`：参数名称
  - `type`：参数类型
- `outputs`：和`inputs`一样，如果没有返回值，缺省是一个空数组

这里要说明一点的是，由于示例中的`x`字段类型为`private`，所以没有生成一个和参数名称一样的函数，如果`x`字段类型为`public`，生成的abi就如下，会多一个和参数名称一样的函数(将状态变量声明为public将自动为其创建getter方法)

```bash
"abi": [
    {
      "constant": true,
      "inputs": [],
      "name": "x",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "name": "_x",
          "type": "uint256"
        }
      ],
      "name": "set",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    }
```

## 公钥加密系统

 Alice有一把公钥和一把私钥。她可以用她的私钥创建数字签名，而Bob可以用她的公钥来验证这个签名确实是用Alice的私钥创建的，也就是说，确实是Alice的签名。当你创建一个以太坊或者比特币钱包的时候，那长长的`0xdf...5f`地址实质上是个公钥，对应的私钥保存某处。类似于Coinbase的在线钱包可以帮你保管私钥，你也可以自己保管。如果你弄丢了存有资金的钱包的私钥，你就等于永远失去了那笔资金，因此你最好对私钥做好备份。

## 点对点网络

就像BitTorrent, 以太坊分布式网络中的所有节点都地位平等，没有中心服务器。(未来会有半中心化的混合型服务出现为用户和开发者提供方便。)

## EVM

以太坊虚拟机 ，它让你能在以太坊上写出更强大的程序（比特币上也可以写脚本程序）。它有时也用来指以太坊区块链，负责执行智能合约以及一切。

## 节点

你可以运行节点，通过它读写以太坊区块链，也即使用以太坊虚拟机。完全节点需要下载整个区块链。轻节点仍在开发中。

## 矿工

挖矿，也就是处理区块链上的区块的节点。

## 以太币

缩写ETH。一种你可以购买和使用的真正的数字货币

## Gas

在以太坊上执行程序以及保存数据都要消耗一定量的以太币，Gas是以太币转换而成。这个机制用来保证效率。

## DApp

以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。DApp的目标是(或者应该是)让你的智能合约有一个友好的界面，外加一些额外的东西，例如IPFS（可以存储和读取数据的去中心化网络，不是出自以太坊团队但有类似的精神)。DApp可以跑在一台能与以太坊节点交互的中心化服务器上，也可以跑在任意一个以太坊平等节点上。(花一分钟思考一下：与一般的网站不同，DApp不能跑在普通的服务器上。他们需要提交交易到区块链并且从区块链而不是中心化数据库读取重要数据。相对于典型的用户登录系统，用户有可能被表示成一个钱包地址而其它用户数据保存在本地。许多事情都会与目前的web应用有不同架构。

## 客户端

以太坊有许多不同语言的客户端实现（即多种与以太坊网络交互的方法），包括C++, Go, Python, Java, Haskell等等。为什么需要这么多实现？不同的实现能满足不同的需求（例如Haskell实现的目标是可以被数学验证），能使以太坊更加安全，能丰富整个生态系统。

交互式控制台。 客户端运行起来后，你就可以同步区块链，建立钱包，收发以太币了。使用geth的一种方式是通过[Javascript控制台](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console)（JavaScript console, 类似你在chrome浏览器里面按F12出来的那个，只不过是跑在终端里）。此外还可以使用类似curl的命令通过[JSON RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC)来与客户端交互。本文的目标是带大家过一边DApp开发的流程，因此这块就不多说了。但是我们应该记住这些命令行工具是调试，配置节点，以及使用钱包的利器。

在测试网络运行节点。 如果你在正式网络运行geth客户端，下载整个区块链与网络同步会需要相当时间。（你可以通过比较节点日志中打印的最后一个块号和以太坊网址上列出的最新块来确定是否已经同步。) 另一个问题是在正式网络上跑智能合约需要实实在在的以太币。在测试网络上运行节点的话就没有这个问题。此时也不需要同步整个区块链，创建一个自己的私有链就好了了，对于开发来说更省时间。

## truffle

truffle是本地的用来编译、部署智能合约的工具

## testrpc

testrpc不同于geth，geth是真正的以太坊环境，testrpc是在本地使用内存模拟的一个以太坊环境，对于开发调试来说，更为方便快捷，当你的合约在testrpc中测试通过后，再可以部署到geth中去

testrpc 现在已经并入到Truffle 开发框架中，现在名字是ganache-cli

注意：它仅运行在內存中，因此每次重开时都会回到全新的状态

## ganache

ganache相当于是testrpc的升级版，有图形界面

注意：它仅运行在內存中，因此每次重开时都会回到全新的状态；但可选择固定一个测试环境

## Open zeppelin 

一个帮助我们在以太坊上建立安全智能合约的开发库,当前集成于truffle开发框架中

## 智能合约

> 将合约条款代码化
>
> 以太坊上的程序,是代码和数据(状态)的集合
>
> 典型应用：代币: EOS ，游戏：迷恋猫

你愿意和从未谋面的人签合约吗？你会同意把钱借给埃塞俄比亚的农民吗？你愿意投资一个战乱地区由少数人管理的报纸吗？你会不嫌麻烦为了网上一次5美元的购买签一个有法律效力的合约吗？

大多数的答案都是否定的，原因是合约需要的基础太多了：有时需要双方之间互相信任的工作关系，有时要依靠合法的工作体系、警察和律师费用。

在以太坊这些都不需要：**如果合约所必需的要求都能放在区块链中，那么就会放在区块链中，这是一个无需信任基础也几乎不用任何成本的环境**。

 不要想将你现有的合约转移到区块链中会麻烦，想一想那些因为经济上不可行或是没有足够法律保护而被你拒绝的成千上万的小合约吧。

## DAO

> Decentralized Autonomous Organization，简称DAO，一般翻译为去中心化的自治组织。

这里简单地举个例子：想象一下你和朋友有个小生意。律师和会计很贵，完全信任让一个单独的合伙人来看管账簿可能让你精神很紧张（这甚至可能是个诈骗的机会）。你可以尝试一下多个合伙人共同看管账簿，但只要协议没有被严格遵守，就可能导致诈骗发生。

使用智能合约，公司的所有权和基金分配的条款可以在一开始就详细规定。智能合约签署的方式是，只有大部分拥有者批准，合约才可以变更。 这样的智能合约可以像开源软件一样获取，你甚至都不必雇佣自己的程序员来代替会计和律师。

这样的智能合约可以立即按比例决定分配。几个年轻人分配柠檬水站收入，可以像主权基金给拥有基金的亿万公民分配收益一样透明。在这两个案例中，这种透明性带来的花费可能每美元连一美分都不到。

## DAG

**DAG**是有向无环图。它用于所有Ethash算数的数字货币，如ETH-以太坊，ETC-以太经典，MUSIC-乐币，ETP-元界，DBIX-迪拜币，CLO，EXP，UBQ等其它数字货币，以提供工作量证明。DAG文件在每个挖矿纪元（epoch）都会生成一个DAG，并且会不断增加。了解DAG文件的当前和未来的大小非常重要，因为它对挖矿速度会产生很大影响。DAG文件直接位于GPU显存中。如果DAG文件比GPU显存大，那么你的显卡就不能再进行挖矿。要分析未来的dag大小，您可以查看下表。

**DAG**文件每个纪元（epoch）都会改变。一个纪元（epoch）是30000个区块。DAG文件的增加速度直接取决于出块时间。但出块时间不稳定，以太坊可能会从10秒到60秒不等。因此，每个纪元（epoch）都没有固定产生时间，它是以块为单位决定的。一般来说，以太坊的DAG文件每年增加0.72倍。但这还是得看出块时间。对于出块时间较慢的其他数字货币，DAG文件增加较慢，GPU可以挖矿很长时间。

bitcoin之所以效率低是因为它的POW机制. 整个网络只有一个主链, 其上的新块只能有一个, 无法同时创建多个新块. 10分钟左右以内的所有交易记录都被记录到一个块中. Ethereum也是类似, 大概15-20秒产生一个新块。有了DAG, 就可以同一时间创建多个块。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghp7pezlc8j30om0ctwhn.jpg" alt="0F68C9A2-B75A-4C7B-870B-7844452483B5" style="zoom:50%;" />

对于每一个块，首先计算一个种子(seed)，该种子只和当前块的信息有关;然后根据种子生成一个32M的随机数据集（cache）

根据Cache生成一个1GB大小的数据集合DAG(有向非循环图)，它是一个完整的搜索空间，挖矿的过程就是从DAG中随机选择元素(类似于比特币挖矿中查找合适Nonce)再进行哈希运算，可以从Cache快速计算DAG指定位置的元素，进而哈希验证。要求对Cache和DAG进行周期性更新，每1000个块更新一次，并且规定DAG的大小随着时间推移线性增长，从1G开始，每年大约增长7G左右。

## 硬/软分叉

软分叉：在区块链中产生分叉短时间出现过另外一条分叉链，随后被抛弃，这样的分叉称为软分叉。（如：比特币）

硬分叉：

1. 在区块链中产生分叉后本该被抛弃的分叉链，被保留了下来，这样的分叉被称为硬分叉。（分叉链由于有人号召大家或其他原因，得到维护者的响应继续维护此链，那么这条链就会逐渐壮大起来，不会消失）

2. 因为区块链的共识发生了分歧，而产生的新的共识规则发布之后，一些没有升级的节点无法验证已经升级的节点生产出来的区块，如果不能达成一致，分叉有可能会出现分叉币，实现硬分叉。

   ```css
   历史上最出名的硬分叉事件：
   2016年5月底由以太坊创始人Vitalik Buterin主导的一个叫做The DAO的项目使用以太币来众筹，结果超过1200万个以太币被黑客盗取，V神提出设想，通过硬分叉使得黑客利用漏洞转出交易的区块失效，找回丢失的以太币。当时超过85%的以太坊算力支持硬分叉，以太坊硬分叉成功。新链是以太坊ETH，旧链是以太经典ETC。对部分区块链信仰者来说，此次硬分叉是对区块链的背叛，采用了人为手段进行强制回滚，违背了区块链不能修改的技术本质。他们反对此次硬分叉并且在原有链上继续贡献自己的算力，所以ETC一直活着并逐渐在各交易平台上市，而且ETC价格极低。
   ```

## 共识机制

### 分布式记账场景

**下面归纳现区块链主流共识算法(机制)：**

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1ghqi7f9opkj30ca0bpq35.jpg)

### PoW

> POW（Proof of Work，工作量证明）

**“解决一道数学难题”，“机器性能越好，挖矿时间越长，获得的回报也越多。”**

类型：竞争共识

概念：工作量证明，引入了对一个特定值的计算工作。

POW共识算法应用场景：比特币（BTC）及其引申出来的BCH、BCD等

**算法工作描述：**

1. 矿工们在挖一个新的区块时，必须对SHA-256密码散列函数进行运算，区块中的随机散列值以一个或多个0开始。
2. 随着0数目的上升，找到这个解所需要的工作量将呈指数增长，矿工通过反复尝试找到这个解。

**解决问题：**

1. 谁有权记账
2. 如何避免记账者作弊

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1ghqibwgeyej30jy0inwgn.jpg)

**优点：**

算法简单，采用大家认可的数学逻辑（找寻随机数），容易实现。安全系数最高，破坏整个系统，需要投入巨大成本。

**缺点：**

1. 大量消耗能源。
2. 它的价值回路必须要通过外部输入。也就是说，采用POW的数字货币仍旧不是理想状态的数字货币，因为它们的安全性不直接与使用者相关，而是要通过矿工这个媒介。

**使用该算法的项目(包含且不限于)：**

Bitcoin、Ethereum、Litecoin、Dogecoin 

### PoS

> POS（Proof of Stake，权益证明）

**“拥有的币越多，有记账权的概率就越大？”**

类型：竞争共识

因为POW大量消耗能源和安全性不与使用者相关的问题，POS的出现可以解决这些问题：

1. 采用POS的货币的安全性直接与使用者相关，省去了矿工这个媒介。
2. POS简单说就是，每当发表一条消息的时候，不用证明你付出了什么代价，而要证明你拥有一定数量的钱。而拥有钱代表着，如果你作弊损害了这个系统的安全性，你的钱会贬值，这变相地让你付出了代价。
3. 这东西更好的一点是，如果采用POS，实际上连挖矿奖励都不需要，因为POS实际上不需要付出任何代价。

**概念：**

试图解决POW机制中大量资源被浪费的情况。这种机制通过计算你持有占总币数的百分比，包括你占有币数的时间来决定记账权。

**优点：**

不需要拼算力挖矿，不会浪费电力。缩短了共识达成的时间，效率提高。

**缺点：**

1. 拥有权益的参与者因为可以持币吃利息，所以卖币意愿不强烈，容易产生垄断。
2. 所有的确认都只是概率上的表达，存在其他攻击的可能性。挖矿成本低，硬分叉十分容易。

**使用该算法的项目(包含且不限于)：**

Ethereum、Peercoin、Nxt

### DPoS

> DPOS（Delegated Proof of Stake，授权权益证明）

**可理解为“公司董事会”。**

类型：协同型共识

2014年4月由Bitshares 的首席开发者 Dan Larimer（BM）提出。它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。

**优点：**

节能；快速；高流量博客网站 Steemit 就使用了它。EOS 的块时间是 0.5 秒。

**缺点：**

略为中心化；拥有高权益的参与者可投票使自己成为一名验证者（这是近期已在 EOS 中出现的问题）。

**使用该算法的项目(包含且不限于)：**

BitShares、Steemit、EOS、Lisk、Ark。

### PoA

> POA（Proof-of-Authority，权威证明）

**“投票指定一位被认可的账户作为矿工”**

类型：协同型共识

 基于 PoA 的网络、事务和区块，是由一些经认可的账户认证的，这些被认可的账户称为“验证者”（Validator）。验证者运行的软件，支持验证者将交易（transaction）置于区块中。该过程是自动的，无需验证者持续监控计算机，但需要维护计算机（权威节点）不妥协（uncompromised）。

使用 PoA，每个个体都具有变成验证者的权利，因此存在一旦获取就保持验证者位置的动机。通过对身份附加一个声誉，可以鼓励验证者去维护交易的过程。因为验证者并不希望让自己获得负面声誉，这会使其失去来之不易的验证者地位。

**优点：**

节能、快速。

**缺点：**

略为中心化；虽然可用于公有区块链，但是通常用于私有区块链和许可区块链。

**使用该算法的项目(包含且不限于)：**

POA.Network、Ethereum Kovan testnet、VeChain

### PBFT

> PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法）

类型：协同型共识

**描述：**

首先从“拜占庭将军问题”开始，拜占庭将军问题的实质就是要寻找一个方法，使得将军们在一个有版徒的非信任环境中建立对战斗计划的共识。

实用拜占庭容错（PBFT，Practical Byzantine Fault Tolerance）是首个提出的该问题解决方案，当前已被 Hyperledger Fabric 采用。PBFT 使用了较少（少于 20 个，之后会稍有增加）的预选定将军数，因此运行非常高效。它的优点是高交易通量和吞吐量，但是不足之处在于是中心化的，并用于许可网络。

拜占庭容错系统是指：在一个拥有n台节点的系统，整个系统，对每个请求满足如下条件： 所有非拜占庭节点使用相同的输入信息，产生同样的结果； 如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。

与此同时,在拜占庭系统的实际运行过程中一般假设系统中拜占庭节点不超过m台，并且对每个请求满足2个指标：

安全性——任何已经完成的请求都不会被更改，它可以在以后请求看到；

活性——可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。

**优点：**

高速、可扩展。

**缺点：**

通常用于私有网络和许可网络。

**使用该算法的项目(包含且不限于)：**

Hyperledger Fabric、Stellar、Ripple、Dispatch

### DBFT

> DBFT (Delegated Byzantine Fault Tolerance, 授权拜占庭容错算法）

类型：协同型共识

**描述：**

同样是为了解决拜占庭将军问题，「授权拜占庭容错」机制，是一种在NEO区块链内部实现的保证容错的共识算法。

在这个机制当中，存在两个参与者，一个是专业记账的“记账节点”，一个是系统当中的普通用户。

普通用户基于持有权益的比例来投票决定记账节点，当需要通过一项共识时，在这些记账节点中随机推选出一名发言人拟定方案，然后由其他记账节点根据拜占庭容错算法，即少数服从多数的原则进行表态，如果超过66%的节点表示同意发言人方案，则共识达成；否则，重新推选发言人，重复投票过程。

**优点：**

快速；可扩展。

**缺点：**

每个人都争相成为根链。其中可能存在多个根链。

**使用该算法的项目：**

Neo

## EOS

EOS，可以理解为Enterprise Operation System，即为商用分布式应用设计的一款区块链操作系统。EOS是引入的一种新的区块链架构，旨在实现分布式应用的性能扩展。注意，它并不是像比特币和以太坊那样的货币，而是基于EOS软件项目之上发布的代币，被称为区块链3.0。以太坊希望对世界计算领域进行去中心化，EOS的目标是快速运行去中心化的应用程序。两个协议使用不同的协商一致算法和不同的治理模型来实现这些目标。以太坊在其核心部分非常注重去中心化，而EOS则通过消除其一些去中心化特性来提高速度。

EOS是一种区块链体系结构，旨在通过开发可构建应用程序的操作系统来促进去中心化应用程序的纵向和横向扩展。该协议提供身份验证、帐户、异步通信、数据库，能够将应用程序调度到多个CPU内核。

它所产生的技术是一种区块链体系结构，它不需要使用费，在受治理的区块链的上下文中，它提供了快速和直观的去中心化应用程序的构成方式和维护方式。EOS作为一个底层的区块链和一个智能合约平台。该协议的工作方式类似于一个去中心化的操作系统，并允许通过去中心化的自治公司模型部署工业规模的应用程序。它的智能合约平台声称无需缴纳事务费，并且每秒管理数百万事务。

EOS的协商一致算法基于“委托的利害关系证明”，即那些在平台上拥有令牌的人可以通过一个扩展的批准投票系统来选择块生产者。

任何人都可以选择参加区块生产，并被允许生产区块，只要他们能够说服令牌持有人投票给他们。EOS协商一致算法尊重“拜占庭式的容错”方式，允许生产者签署所有块，只要没有生产者批准两个具有相同时间戳或相同块高度的块。一旦15个生产商签署了一个区块，这个区块就被认为是不可逆转的。

## 代币（Token）

代币是一种经过加密的数字货币。如：比特币、以太币

Token只是代币的英文，也称为通证，一般是指基于区块链技术发行的数字货币

## ICO

ICO（Initial Coin Offering），首次币发行，源自股票市场的首次公开发行（IPO）概念，是区块链项目首次发行代币，如募集比特币、以太坊等通用数字货币的行为。 

## IBC

IBC是链间通信协议（Inter-Blockchain Communication Protocol）。通过数据包的交换在多个不同的区块链网络之间转移数据和状态信息。最初的用途更多是通过IBC协议实现跨链通证转移。

IBC的目标是在两个独立的七层网络之间传递应用信息，所以需要链外的relay把数据包在链A和链B的网络之间做中继。链B收到链A的数据后必须能独立验证它所包含的证明信息，该证明代表了链A上的某个状态（及其对应操作）的真实性。为了让IBC协议能够工作，必须依赖基础的信任机制，要相信链A和链B里各自的共识算法，也要相信轻客户端验证，通过对区块头信息的验证，证明在区块链上曾经发生过的事情。

## ERC20

ERC20（Ethereum Request for Comments 20）是一种代币设计标准，是目前的行业标准，它基于以太坊存在。以相同的规则构建代币有利于后期发展，才会有更多的第三方应用对你发行的代币进行支持。

在编写了一份标准的ERC20智能合约之后，第三方机构就会用事先编写好的自定义代码与你的代币合约建立通信，这样人们就可以开始交易你的代币或把它存入钱包了。

## txindex

txindex：全称Transaction index 。

比特币核心默认建立包含仅与用户钱包相关交易的数据库。若你想使用类似gettransaction的命令访问所有交易，你需要配置比特币核心去建立一个完整的交易索引，这个可以通过txindex选项实现。在比特币核心配置文件中将txindex赋值为1（通常在安装目录的.bitcoin/bitcoin.conf中可以找到）， 或者使用命令行参数 txindex=1。一旦你改变了此参数，你需要重启bitcoind，并等待其重建索引。这个参数txindex的值会写入pblocktree数据库中，data/blocks/index目录下，

## UTXO

如果我们观察任何一个交易，它总是由若干个输入（Input）和若干个输出（Output）构成，一个Input指向的是前面区块的某个Output，只有Coinbase交易（矿工奖励的铸币交易）没有输入，只有凭空输出。所以，任何交易，总是可以由Input溯源到Coinbase交易。这些交易的Input和Output总是可以串联起来：

```ascii
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│Block #1     │     │Block #2     │     │Block #3     │     │Block #4     │
│┌──┬────┬───┐│     │┌──┬────┬───┐│     │┌──┬────┬───┐│     │┌──┬────┬───┐│
││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT││
│└──┴────┴───┘│  │  │└──┴────┴───┘│  │  │└──┴────┴───┘│  │  │└──┴────┴───┘│
│             │  │  │┌──┬────┬───┐│  │  │┌──┬────┬───┐│  │  │┌──┬────┬───┐│
│             │  │  ││  │8.70│OUT├┼──┼──>│IN│    │   ││  └──>│IN│25.0│OUT││
│             │  └──>│IN├────┼───┤│  │  │├──┤58.7│OUT││     │├──┼────┼───┤│
│             │     ││  │41.3│OUT├┼─┐└──>│IN│    │   ││  ┌──>│IN│66.3│OUT││
│             │     │└──┴────┴───┘│ │   │└──┴────┴───┘│  │  │└──┴────┴───┘│
└─────────────┘     └─────────────┘ │   └─────────────┘  │  └─────────────┘
                                    └────────────────────┘
```

还没有被下一个交易花费的Output被称为UTXO：Unspent TX Output，即未花费交易输出。给定任何一个区块，计算当前所有的UXTO金额之和，等同于自创世区块到给定区块的挖矿奖励之和（没交易的话）。

因此，比特币的交易模型和我们平时使用的银行账号有所不同，它并没有账户这个说法，只有UTXO。想要确定某个人拥有的比特币，并无法通过某个账户查到，必须知道此人控制的所有UTXO金额之和。

在钱包程序中，钱包管理的是一组私钥，对应的是一组公钥和地址。钱包程序必须从创世区块开始扫描每一笔交易，如果：

1. 遇到某笔交易的某个Output是钱包管理的地址之一，则钱包余额增加；
2. 遇到某笔交易的某个Input是钱包管理的地址之一，则钱包余额减少。

钱包的当前余额总是钱包地址关联的所有UTXO金额之和。

如果刚装了一个新钱包，导入了一组私钥，在钱包扫描完整个比特币区块之前，是无法得知当前管理的地址余额的。



## TX

TX表示Transaction，交易。

## ETH账户模型

以太坊所使用的账户模型比较容易理解，就好像我们每个人都拥有一个银行帐户一样。在以太坊的世界中，每个地址就像是一个帐户，每一次的扣款，交易过后，都会将帐户的余额纪录在区块链当中。因此在认证交易时只要检查帐户是否有足够的余额就可以了。这个方法简单，直观，较利于智能合约的开发。在Etherscan上输入你的交易ID之后会看到这种画面：

![img](https://img2018.cnblogs.com/blog/1484426/201810/1484426-20181026084044268-1599941074.png)

## UTXO模型

UTXO全名是`Unspent Transaction Outputs`，未花费交易输出，相比于账户模型来说没那么直观。

在比特币的世界里，并没有一个纪录所有帐户余额的帐本。那么要怎么确定一个地址现在有多少余额呢？简单的说，你要回顾以前所有的交易，并且找到当前所有UTXO，再把他们全都加起来，才会知道。

- **交易中的输入与输出**

  如果我们观察任何一个交易，它总是由若干个输入（Input）和若干个输出（Output）构成，一个Input指向的是前面区块的某个Output，只有Coinbase交易（矿工奖励的铸币交易）没有输入，只有凭空输出。所以，任何交易，总是可以由Input溯源到Coinbase交易。这些交易的Input和Output总是可以串联起来：

  ```
  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
  │Block #1     │     │Block #2     │     │Block #3     │     │Block #4     │
  │┌──┬────┬───┐│     │┌──┬────┬───┐│     │┌──┬────┬───┐│     │┌──┬────┬───┐│
  ││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT├┼──┐  ││CB│50.0│OUT││
  │└──┴────┴───┘│  │  │└──┴────┴───┘│  │  │└──┴────┴───┘│  │  │└──┴────┴───┘│
  │             │  │  │┌──┬────┬───┐│  │  │┌──┬────┬───┐│  │  │┌──┬────┬───┐│
  │             │  │  ││  │8.70│OUT├┼──┼──>│IN│    │   ││  └──>│IN│25.0│OUT││
  │             │  └──>│IN├────┼───┤│  │  │├──┤58.7│OUT││     │├──┼────┼───┤│
  │             │     ││  │41.3│OUT├┼─┐└──>│IN│    │   ││  ┌──>│IN│66.3│OUT││
  │             │     │└──┴────┴───┘│ │   │└──┴────┴───┘│  │  │└──┴────┴───┘│
  └─────────────┘     └─────────────┘ │   └─────────────┘  │  └─────────────┘
                                      └────────────────────┘
  ```

  还没有被下一个交易花费的Output被称为UTXO：Unspent TX Output，即未花费交易输出。给定任何一个区块，计算当前所有的UXTO金额之和，等同于自创世区块到给定区块的挖矿奖励之和（没输出的话）。

- **那么，查询一个给定地址的余额，难道要从头扫描几百GB的区块链数据？**

  当然不是。

  要做到瞬时查询，我们知道，使用关系数据库的主键进行查询，由于用了索引，速度极快。

  因此，对区块链进行查询之前，首先要扫描整个区块链，重建一个类似关系数据库的地址-余额映射表。这个表的结构如下：

  | address   | balance | lastUpdatedAtBlock |
  | :-------- | :------ | :----------------- |
  | address-1 | 50.0    | 0                  |

  一开始，这是一个空表。每当扫描一个区块的所有交易后，某些地址的余额增加，另一些地址的余额减少，两者之差恰好为区块奖励：

  | address   | balance | lastUpdatedAtBlock |
  | :-------- | :------ | :----------------- |
  | address-1 | 50.0    | 0                  |
  | address-2 | 40.0    | 3                  |
  | address-3 | 50.0    | 3                  |
  | address-4 | 10.0    | 3                  |

  这样，扫描完所有区块后，我们就得到了整个区块链所有地址的完整余额记录，查询的时候，并不是从区块链查询，而是从本地数据库查询。大多数钱包程序使用LevelDB来存储这些信息，手机钱包程序则是请求服务器，由服务器查询数据库后返回结果。

  如果我们把MySQL这样的数据库看作可修改的，那么区块链就是不可修改，只能追加的只读数据库。但是，MySQL这样的数据库虽然其状态是可修改的，但它的状态改变却是由修改语句（INSERT/UPDATE/DELETE）引起的。把MySQL的binlog日志完整地记录下来，再进行重放，即可在另一台机器上完整地重建整个数据库。把区块链看作不可修改的binlog日志，我们只要把每个区块的所有交易重放一遍，即可重建一个地址-余额的数据库。

- **交易中的UTXO**

  ![img](https://tva1.sinaimg.cn/large/007S8ZIlly1ghv2loatyxj30hs07et8v.jpg)

  **且比特币交易遵守几个规则：**

  **第一，除了 coinbase交易之外，所有的资金来源都必须来自前面某一个或者几个交易的 UTXO，就像接水管一样，一个接一个，此出彼入，此入彼出，生生不息，钱就在交易之间流动起来了。**

  **第二，任何一笔交易的交易输入总量必须等于交易输出总量，等式两边必须配平。**

  > 所以，出现找零机制：
  >
  > ​		1. 中本聪有一个面值为50的UTXO，转给哈尔·芬尼（Hal Finney）10个BTC，除了要写哈尔·芬尼这个收款人的地址，还要写找零地址，说明多出来的40个BTC想放到哪个比特币地址，可以是原来发起转账的地址，也可以是其他的比特币地址，必须得写一个找零地址。
  >
  > ​		2. 如果交易的时候不写找零地址，剩下的钱会被系统默认为全部归属矿工，全部给矿工当成是帮你打包交易的手续费。
  >
  > ​		3. 但是现在的加密货币钱包软件都是非常人性化的，会自动帮用户去生成1个找零地址和手续费，如果你觉得钱包自动设置的手续费太高了，也可以进行下调，或者如果你想要交易被尽快确认的话也可以调高手续费。

  **矿工对UTXO进行校验：**
  
  ![img](https://tva1.sinaimg.cn/large/007S8ZIlly1ghv2w3cyqyj30hs07zglv.jpg)
  
  > **注：**合法的私钥签名用来证实发起者对这个比特币地址是有控制权的，如果不能提供私钥签名，那么矿工就会判定他发行的这笔交易是非法的，不能通过检验。

- **UTXO的优势与劣势**

  ① 平行交易：UTXO因为没有帐户的存在，因此容许平行进行多笔交易。假如你有许多的UTXO，你可以同时进行多笔交易而不会被阻挡。

  ② 匿名性：可以轻易的隐藏自己的交易目的。

  ③ 安全&效率：UTXO也被认为比较安全且有效率，可以透过Simple Payment Verification（SPV）来快速验证检验交易。

  **④ 缺点：**但UTXO最大的缺点就在于他是`Stateless`无状态的，这对于在其上开发应用程序非常的不利。就像有名的Qtum虽然底子是UTXO的交易模式，但是仍然会设计`Account Abstraction Layer`账户抽象层来让应用程序的开发变得容易。

  > 现在区块链应用开发当道，UTXO倾向被大家视为一种只能简单处理交易的模型，我觉得一定程度上算是时代的产物吧！尽管有一些特性是无可取代，但是大家仍是偏好朝向Account Model或是混合式的架构前进。