 #  以太坊概念问题

## 公链

以太坊是一个分布式的公链，由很多台电脑组网而成，每台接入这个网络的电脑本地都会保存一份完整区块链（可理解为一个本地数据库，多个文件组成）。

## 旷工

这些组网的电脑中有一些节点电脑担任所谓的矿工，矿工负责将所有这个网络上的交易打包成一个小区块，然后分发到所有的节点（包括你的电脑），这些小区块就构成了区块链。

## 智能合约

> 智能合约就好比一个web应用（与Web应用不同的是它不需要部署到中心化服务器上，而是部署到区块链上），智能合约赋予你的是可以在以太坊上进行应用开发的能力。
>
> 可以简单的理解为一段可执行的程序片段，具体的代码由发布人使用特定的编程语言来编写（以太坊使用的是Solidity编程语言，类似JavaScript），在本地编译成功后可以发布到区块链上。而以太坊的智能合约也可以理解为一个特殊的交易（包括可执行代码的），被发送出去后会被矿工打包记录在某一个区块中，当需要调用这个智能合约的方法时只需要向这个智能合约的地址发送一笔交易即可。

**智能合约的存储：**合约部署后会创建一个合约账户，合约账户里保存着智能合约的可执行字节码(编译之后的,在EVM里执行)，并且有存储空间，合约能对合约账户的空间写入信息，合约代码就放在合约账户的code字段里。而abi是一个接口结构，利用abi Definition可以创建调用该合约的结构。abi应该由合约所有方自己保存和提供。

**智能合约的工作流程：**构建、存储、执行

**智能合约的工作原理：**智能合约由区块链内的多个用户共同参与制定，可用于用户之间的任何交易行为。协议中明确了双方的权利和义务，开发人员将这些权利和义务以电子化的方式进行编程，代码中包含会触发合约自动执行的条件。一旦编码完成，这份智能合约就被上传到区块链网络上，即全网验证节点都会接收到你和A的智能合约。智能合约会定期检查是否存在相关事件和触发条件；满足条件的事件将会推送到待验证的列队中。区块链上的验证节点先对该事件进行签名验证，以确保其有效性；等大多数验证节点先对该事件达成共识后，智能合约将成功执行，并通知用户。

## Gas

以太坊上只要涉及到状态的变更都会消耗以太币，比如一笔交易的产生会更改账户的状态、一个智能合约的存储或更改智能合约的状态等等，消耗掉计算资源和存储资源的都需要支付费用。智能合约是一个程序片段，由很多方法和变量组成，部署智能合约到链上（相当于发送一个交易）需要消耗以太币，通过智能合约改变智能合约的内部状态也需要消耗以太币，但也有在本地读取而不改变状态的是不需要消耗以太币的。

> 部署到以太坊上的智能合约是要消耗以太币的。智能合约逻辑复杂度与以太坊Gas的消耗成正比，逻辑越复杂，执行智能合约所消耗的以太坊Gas就越多。

## EVM

每个节点电脑都需要安装以太坊客户端，而这个以太坊客户端自带了EVM（超轻量级虚拟机，最小编译体积40KB，最小内存占用2KB），一个以太坊智能合约的执行环境，类似JVM一样，通过交易触发智能合约后智能合约的代码就会在EVM中执行了。这种方式相当于把程序部署到了非常非常多的电脑上（只要这个电脑安装了以太坊客户端并接入了以太坊网络），随时都可以通过交易来触发这些智能合约的执行，也从而完成了分布式程序的部署和调用。当然，目前智能合约的功能还非常有限，不能完成所有的现在编程可以解决的事情（比如访问网络下载文件，这个是目前EVM不允许和不支持的）。

## 账户

在乙太坊网络中，账户的状态信息是全局的，这些状态会被一种特殊的数据结构(MPT：默克尔前缀树)保存到一个区块中，比方说账户A的地址，余额，交易的次数等等，比方说合约账户的地址，余额，合约代码等等；外部账和和合约账户的状态改变都可看作一次特殊的交易。

每个合约账号下都有一个存储空间，用来存储合约产生的数据，我理解的最底层应该是一个kv数据库，查询普通账户的时候对应的是账户余额，查询合约账户对应的是合约的详细信息（abi和bytecode等），再通过查询指令操作在evm中运行。区块链的设计架构应该还有一个计算层，用来计算每个key对应的value的存储位置，不然查询响应速度应该没那么快。

# 以太坊区块组成 

## 简介

 以太坊的区块是由去块头、交易列表和叔区块三部分组成。其中区块头包含块区号、块哈希、父块哈希等信息，其中State Root、Transaction Root、Receipt Root分别代表了状态树、交易树和交易树的哈希。除了创世块外，每个块都有父块，用Parent Hash连成一条区块链。

> 交易列表：存储的是本区块中所有的交易内容
>
> 叔块：其实就是孤块，因以太坊出块速度很快平均十几秒就会打包生成一个块，所以矿工挖矿的竞争性很高，可能同时产出几个都合法的区块，以太坊为了一些安全性起见，允许竞争块也挂在到主链上，同时给与挖出这些孤块的矿工们少许奖励增加工作的公平性。具体参见以太坊中的Ghost协议。
>
> 区块头：由15个字段组成

## 区块头

以太坊中每个区块的结构和比特币中每个区块的结构却不同，以太坊中每个区块的结构比比特币种区块的结构更加复杂，太坊中区块的区块头(Block Header)结构定义如下图所示：

![33D115E8-90F4-4B3E-BBAF-CD986A8A46D0](https://tva1.sinaimg.cn/large/007S8ZIlly1ghn0lk4tx8j30nz0ew13g.jpg)

区块头中每个字段的意义如下：

| 名称        | 类型           | 意义                                                         |
| ----------- | -------------- | ------------------------------------------------------------ |
| parentHash  | common.Hash    | 父区块的哈希值                                               |
| UncleHash   | common.Hash    | 叔父区块列表的哈希值                                         |
| Coinbase    | common.Address | 打包该区块的矿工的地址，用于接收矿工费                       |
| Root        | common.Hash    | 状态树的根哈希值                                             |
| TxHash      | common.Hash    | 交易树的根哈希值                                             |
| ReceiptHash | common.Hash    | 收据树的根哈希值                                             |
| Bloom       | Bloom          | 交易收据日志组成的Bloom过滤器                                |
| Difficulty  | *Big.Int       | 本区块的难度                                                 |
| Number      | *Big.Int       | 本区块块号，区块号从0号开始算起                              |
| GasLimit    | uint64         | 本区块中所有交易消耗的Gas上限，这个数值不等于所有交易的中Gas limit字段的和 |
| GasUsed     | uint64         | 本区块中所有交易使用的Gas之和                                |
| Time        | *big.Int       | 区块产生的unix时间戳，一般是打包区块的时间，这个字段不是出块的时间戳 |
| Extra       | []byte         | 区块的附加数据                                               |
| MixDigest   | common.Hash    | 哈希值，与Nonce的组合用于工作量计算                          |
| Nonce       | BlockNonce     | 区块产生时的随机值                                           |

## 叔块

> 在比特币，最长的链是主链。在以太坊中，主链是指最重的链。

**最长的链**

在比特币协议中，最长的链被认为是绝对的正确。如果一个块不是最长链的一部分，那么它被称为是“孤块”。一个孤立的块是一个块，它也是合法的，但是发现的稍晚，或者是网络传输稍慢，而没有能成为最长的链的一部分。在比特币中，孤块没有意义，随后将被抛弃，发现这个孤块的矿工也拿不到采矿相关的奖励。

**最重的链**

Ethereum的GHOST协议，不认为孤块没有价值，而是会给与发现孤块的矿工以回报。在以太坊中，孤块被称为“叔块”(uncle block)，它们可以为主链的安全作出贡献。

相对来说，比特币有很长的块间隔时间。在比特币区块中，平均约10分钟可以得到一个确认(也就是发现一个新的后续区块)。但是自从比特币成立以来，大量关于块链技术的研究已经发展起来。这些研究表明，更短的块间隔确实是可能的，而且在很多应用场景下是需要的。然而，随着拥有更快的出块速度，孤块的增加而带来的昂贵的成本和浪费也随之增加。

GHOST协议支付报酬给叔块，这激励了矿工在新发现的块中去引用叔块。引用叔块使主链更重。

**叔块的好处**

解决了两个问题：

1. 以太坊十几秒的出块间隔，大大增加了孤块的产生，并且降低了安全性。通过鼓励引用叔块，使引用主链获得更多的安全保证(因为孤块本身也是合法的)
2. 比特币中，采矿中心化(大量的集中矿池)成为一个问题。给与叔块报酬，可以一定程度上缓解这个问题。

**叔块的引用有报酬**

- 区块可以不引用，或者最多引用两个叔块
- 叔块必须是区块的前2层~前7层的祖先的直接的子块
- 被引用过的叔块不能重复引用
- 引用叔块的区块，可以获得挖矿报酬的1/32，也就是5\*(1/32)=0.15625 Ether。最多获得2*0.15625=0.3125 Ether
- 被引用的叔块，其矿工的报酬和叔块与区块之间的间隔层数有关系。

| 间隔层数 | 报酬比例 | 报酬(ether) |
| :------: | :------: | :---------: |
|    1     |   7/8    |    4.375    |
|    2     |   6/8    |    3.75     |
|    3     |   5/8    |    3.125    |
|    4     |   4/8    |     2.5     |
|    5     |   3/8    |    1.875    |
|    6     |   2/8    |    1.25     |

## 注意

1. 和比特币中的区块链一样，以太坊中的区块链仍然使用了parentHash连接前一个区块，通过这个字段，所有的区块最终都能回溯到创始块。

2. 值得一提的是，区块的时间戳并不是出块的时间，矿工在挖矿的时候区块的时间戳一般是确定的，所以这个区块的时间戳，是矿工开始挖这个区块的时间。

3. Gas Limit是用于限制区块中的交易个数用的。具体由每个矿工自己设置，有些矿工觉得本区块的Gas Limit太大，可以在挖下一个区块时将Gas Limit下调1/1024​,觉得Gas Limit太小的时候，就会上调1/1024。整个区块链中区块的大小，就是所有矿工微调的平均值。以太坊中正是通过Gas Limit来限制区块的大小。

4. 区块头中比较重要的三个字段是Root、TxHash和ReceiptHash三个哈希值。

> 其中Root表示以太坊网络中全部有过转账交易的账户形成的Merkle partial Tree(MPT)的根哈希值。
>
> - 为什么是全部有过转账交易的账户呢，因为我们可以随便创建一个以太坊账户，但是没有发生交易的话，以太坊节点也不会知道这个账户的存在。
>
> TxHash是本区块中所有交易形成的merkle tree的根哈希值
>
> ReceiptHash是本区块中所有收据信息构成的merkle tree 的哈希值。

# 以太坊数据结构

## Merkle 树

默克尔树是自底向上构建的。在下图的例子中，首先将L1-L4四个单元数据哈希化，然后将哈希值存储至相应的叶子节点。将相邻两个节点的哈希值合并成一个字符串，然后计算这个字符串的哈希，得到的就是这两个节点的父节点的哈希值。

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gho2m5dud0j30jy09hq3z.jpg)



重要结论：

**若两棵树的根哈希一致，则这两棵树的结构、节点的内容必然相同。**

> 在p2p网络下载网络之前，先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他从不可信的源获取Merkle tree。通过可信的树根来检查接受到的MerkleTree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的MerkleTree。

## Trie 树

Trie树，又称前缀树或字典树。利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。典型应用是用于统计，排序和保存大量的字符串(不仅限于字符串)，经常被搜索引擎系统用于文本词频统计。

基本性质：

1）根节点不包含字符，除根节点外的每一个子节点都包含一个字符

2）从根节点到某一节点。路径上经过的字符连接起来，就是该节点对应的字符串

3）每个节点的所有子节点包含的字符都不相同

> 注：键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理
>
> ​	    即前缀树的key值被编码在根节点到该节点的路径中。

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gho2q5mvw6j30b907qmyv.jpg)

## Patricia树

   Patricia树，或称Patricia trie，压缩前缀树，是一种更节省空间的Trie。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。

![BB813877-D286-4E4F-90FF-E718E3185C1A](https://tva1.sinaimg.cn/large/007S8ZIlly1ghn1c7pxl7j30bg079q3x.jpg)

## MPT树

一种经过改良的、融合了**默克尔树和前缀树**两种树结构优点的数据结构，以太坊中，MPT是一个非常重要的数据结构，在以太坊中，帐户的交易信息、状态以及相应的状态变更，还有相关的交易信息等都使用MPT来进行管理，其是整个数据存储的重要一环。交易树、收据树、状态树、Storage Trie存储树 都是采用的MPT结构。

**作用：**

1. 存储任意长度的key-value键值对数据；
2. 提供了一种快速计算所维护数据集哈希标识的机制；
3. 提供了快速状态回滚的机制；
4. 提供了一种称为默克尔证明的证明方法，进行轻节点的扩展，实现简单支付验证；

## LevelDB数据库

  以太坊的数据最终都是存储在LevelDB数据库中。**LevelDB是Google实现一个非常高效的键值对数据库，其中键值都是二进制的，目前能够支持十亿级别的数据量，在这个数据量下还有着非常高的性能。**以太坊中共有三个LevelDB数据库，分别是**BlockDB、StateDB和ExtrasDB**。BlockDB保存了块的主体内容，包括块头和交易；StateDB保存了账户的状态数据；ExtrasDB保存了收据信息和其他辅助信息。

# 以太坊的树

1. 交易树：记录交易的状态和变化。每个块都有各自的交易树，且不可更改 
2. 收据树(交易收据)：交易收据的存储
3. 状态树(账户信息)：帐户中各种状态的保存。如余额等。
4. Storage Trie 存储树 ：存储智能合约状态 ，每个账号有自己的Storage Trie 。

# 全节点问题

> 以太坊全节点大小数据对比VS比特币全节点

1. **以太坊的区块链VS比特币登记的信息**

比特币的区块链只登记了“交易历史”。以太坊的区块链同时登记了“交易历史”和“余额状态”两种数据。

比特币开发者也曾经考虑过进行协议升级、让比特币区块链也登记上“余额状态”，也就是UTXO commitment，但是考虑到种种问题，一直都没有实现。

2. **2019年“以太坊全节点到底是2TB还是180GB”的问题**

以太的180GB确实可以叫全节点，它也是有保留完整交易历史的，而且只要对接算力就有独立出块能力。

删掉的只是历史状态数据，它相当于“余额”，是可以从交易历史里重新算出来的。

3. **所谓“2TB的全节点”，应该叫做“存档节点”而不是“全节点”（虽然也算是全节点），人家以太坊社区本来也都是这么叫的。**

“存档节点”比一般的“全节点”多出来的数据，即使删掉，也是可以重算出来的，只不过重算的过程非常费时费力而已。

如果我没理解错，以太的存档节点，不仅要重放交易历史，还要把历史上的每一个时刻拍照记录下来。

4. **FULL：以太坊新节点同步时要把历史上所有的交易都完整验证（重放）一遍，完成“自证清白”的过程，计算负担太重。**

所以，一般同步以太全节点的时候，用的选项都是“fast”，节点只会直接下载近期的状态，直接从近期的状态开始完整验证。

也就是说，对于历史交易，相当于只是简单“过目”了一遍，并没有真正去执行验证。

```css
Bitcoin Core（最主流的的比特币全节点软件）如果要完成一次完整校验历史交易的同步，在2018年12月，高配的机器大概只需要5小时。

有一点要注意：Bitcoin Core默认并不会完整验证所有交易历史，因为assumevalid默认是开启的，由开发者写入了一个区块哈希值，相当于信任开发者已经代用户完成了这个区块之前的完整（数字签名）验证。

需要改一下配置，设置assumevalid=0，才是真正的完整验证。上面那个测试就是设置了assumevalid=0的。
```

另外，比特币的全节点启用了修剪，也就是简单粗暴地删掉了老区块，但也仍然可以算作一个全节点。但是历史区块删掉了是没办法重算出来的，所以这种启用修剪的全节点不能帮助新的全节点从头同步，不能向别人“自证清白”。

至于中本聪白皮书里提到的裁剪，它其实从来就没被实现过。可能是因为回溯扫描老区块数据的工作模式效率比较低吧——很早以前，比特币全节点软件就已经完成了区块数据和UTXO数据的分离管理，这样验证交易的效率才不至于太差。

5. **FAST：以太坊fast node**

以太坊一个新的fast node对当前区块之前的交易是不执行的，而是从其他节点得到一个state snapshot，在这个基础上再开始执行。

然后每隔一定的区块（1024个）把老的状态信息都丢掉，只保留最新状态。

那么fast node到底算不算全节点呢？我觉得不能算

- 去中心化的精髓就是“Don't trust，Verify”。fast node的信任不是完全来自于公开的区块链，而是来自于其他节点，也就是存在大量没有verify的数据。

- fast node无法回到任意历史状态，而全节点可以。fast node丢掉了1024个区块之前的状态信息，而一旦区块链因为算力竞争从1024个区块之前开始重组，fast node等同于失效了。

- state tie是一个巨大的随机访问树，受到磁盘IO限制，重构需要大量时间。不是说想重构就可以重构的，大量fast node如果要重新生成state tie就根本不可能跟上当前的区块更新速度。也就是说永远不能变成全节点。

我们甚至还可以进一步假设极端情况，如果以太坊都由fast node组成，那么以太坊的区块链就是没有任何人完整校验过的，虽然还可以正常工作，但是这是不可接受的。

6. **Light：以太节点的light模式，相当于比特币的SPV。**

这种“节点”硬件要求极低、同步极快，因为它是啥也不验证，直接跟着算力走的。不知道以太统计“全节点”的时候，是不是也把这种light模式的“伪节点”统计进去了。

7. **节点真实性**

其实，对于网络上出现的一个节点，它到底是不是“真节点”，外人是没办法准确区分的。因为节点完全可以“滥竽充数”，从别人那里把数据拉过来，当“二道贩子”，无论比特币还是以太坊都是这样。

8. **区块链全节点定义**

区块链关于全节点的定义，我觉得应该是有从诞生至今全部主链数据的节点。全部“数据”是关键。至于是否能挖矿，是否包括加工后的数据，甚至版本如何，是否能被其它节点直接发现连接，能否发币等，都关系不大。要明白全节点是总账本，信息若有缺失不能完全对账的不算是全节点。

9. **大小：以太坊全节点VS比特币全节点**

Ethereum在 2015-07-30诞生，经过4年的发展到现在的740w高度，从https://etherscan.io/chartsync/chainarchive 数据来看，完完整整的区块链数据已经膨胀到2231.5 GB，也就是2.2 TB，同步时间要花几个月时间，而且每天以 3～4 GB的速度在增长。在过几年5TB的硬盘可能也装不下了，这也是为什么ethereum技术社区对分片呼声这么高的原因。

Bitcoin在2009-01-03诞生，经过10年的发展，完完整整的区块链数据基本也就200多GB，同步时间基本在24~36小时。

从保持去中心化，保有全量数据的角度来说，Bitcoin 在这两方面平衡的相当好。而Ethereum归档节点的机器成本已经很高了，个人没有太多动力去维护。

# 以太坊三种同步模式

区块链在本质上就是一个分布式的大帐本，它由一个区块链接下一个区块而成为了一个链式帐本，在区块里记录了所有的交易信息。

所谓的**区块同步**，就是从p2p网络里的其它节点把区块下载到本地来。

**以太坊go-ethereum提供了三种同步方式:**

**Full:** 即全节点模式，会将所有的区块头，区块体都下载来，并逐一验证交易的准确性，确保下载的是正确的区块。

特点：数据完整， 但同步时间长，占用硬盘空间大。

**Fast：**即快速同步模式，对较早的历史区块下载快照，不会验证交易，达到一定高度后会下载完整区块，同步到最新状态后开始验证交易。

特点：时间快，通常1-2天就够了，占用空间也较小，几十到上百G，但是获取较早区块时会丢失数据。

**Light：**即轻节点模式，不下载区块，不验证交易，不会对网络有任何的贡献，属于吸血模式。

# 交易安全问题

## 双花问题

**通俗理解，就是一笔资金，通过某种方式(有可能是欺骗的手段或者支付系统bug问题)被花费了两次，取得了超过该笔资金的服务。**

下面举一个极端的例子：

> 个体户TT银行有存款100万，向商户A购买了一匹钢材，价值100万；商户A支持通过支票支付的方式。
>
> 那么商户A是如何确认这张支票不是“空头”的呢?
>
> 他会向对应的银行（中心化的有认证资质的机构）去查询这张支票的拥有者是否账户上有足够100万的余额可供提取。商户A查询的即时结果是：足额。所以商户A就（基于某种信任）向个体户TT发货。
>
> 然后，个体户TT 又到了商户B去购买了价值100万的实木家具，同样是采用支票支付方式。过程同上。
>
> 上述过程中，个体户TT通过欺诈的手段（借助于可信任的中心化认证机构），将银行中的100万资产消费了两次，获取到了两次的收益，这就是“双花问题”。

**区块链的解决方案：**

> 双花问题主要通过第三方机构来解决，区块链在共识机制的基础上，引入了时间戳和utxo模型，通过共识机制来解决问题。

## 拜占庭将军问题

**「拜占庭将军问题」来源：**

>  拜占庭帝国的军队正在围攻一座城市。这支军队被分成了多支小分队，驻扎在城市周围的不同方位，每支小分队由一个将军领导。这些将军们彼此之间只能依靠信使传递消息（无法聚在一起开个会）。每个将军在观察自己方位的敌情以后，会给出一个各自的行动建议（比如进攻、撤退或按兵不动），但最终的需要将军们达成一致的作战计划并共同执行，否则就会被敌人各个击破。但是，这些将军中可能有叛徒，他们会尝试阻止其他忠诚的将军达成一致的作战计划。
>
> 拜占庭将军的「问题」：只能依靠通信相互交流，又不知道谁是叛徒，怎么能不受叛徒们的影响，让这些忠诚的将军快速的达到一致的作战计划呢？

那么：在一个分布式系统中，针对每个运算，每台独立的机器也需要最终达成一致的结果。但每台计算机之间也只能依靠网络通信，每台计算机都有出错的可能（被攻击，或故障），从而变成「叛徒」干扰正常的计算机达成一致。

**区块链的解决方案：**

> 区块链的底层包括点对点的通讯系统，因此必须解决拜占庭将军问题。解决这个问题的机制，叫做共识机制，目前包括工作量证明、权益证明等等。

# 比特币SVP机制

## 双花攻击

**“双花攻击”（double spend attack）又叫“双重消费攻击”。**

> 说到“双花攻击”，大部分都发生在“数字货币”领域，因为数字货币，因为数据安全性的问题，很容易被“伪造”“复制”“篡改”。
>
> 而物理货币（特指可见的物理货币：比如纸币，硬币，黄金等）就极少存在“双花攻击”问题。因为，物理货币很难被复制篡改，因为交易的参与者会很容易而且很快的验证交易中的物理货币的真伪。
>
> 像比特币，莱特币，EOS币等虚拟数字加密货币，由于其“去中心化”的属性，导致没有一个中心化的机构能够对虚拟货币进行认证“该货币只被消费一次”，所以比特币等都是把如何解决“双花攻击”问题放在最高优先级。

**比特币等虚拟加密货币确确实实完美解决了“双花攻击”问题，虽然无需任何中心化的机构背书，那么，究竟是如何解决该问题的呢？**

> 可以简单的理解为，比特币采用的是一种基于**交易日志记录跟踪**的机制，来验证每一笔交易的真实性，以此来避免“双花攻击”；
>
> 比特币系统要求所有的交易毫无例外的都要被记录在一个公开的，可分享的，去中心化的“账本”上（这个“账本”，其实指的就是区块链）。

## SPV机制

SPV（Simplified payment verification）：简单支付认证

先一句话介绍下，比特币区块的打包机制：比特币的每一个区块在打包的时候，会将该区块包含的所有交易（一般是2000笔以内）进行简单的支付认证，认证的方式就是，通过某种机制来验证，每一笔交易都曾经出现在主“链”上，也就意味着曾经被验证过。

**那采用什么方式去验证呢？**

> 基于各种顾虑，比如上文说的上百G容量限制。Satoshi（中本聪）在论文中提出了：“节点无需下载所有的区块数据，而只需要加载所有区块头数据（block header的大小为80B），即可验证这笔交易是否曾经被比特币网络认证过。”---既SVP机制
>
> 用户虽然不能自己验证交易（因为没有完全的交易信息详情），但如果能够从区块链的某处找到相符的交易（区块头中包含的Merkle Tree 的hash值，就可以链式最终定位到该笔交易是否曾经出现过），他就可以知道网络已经认可了这笔交易，而且得到了网络的多个确认。
>
> 截止2018年3月8号上午10点10分，最新区块高度为：512563。也就是说，就算一个普通节点进行SPV认证需要下载所有的区块头数据，那么总容量也只有40MB。（连诺基亚板砖都能运行了吧？）
>

**SPV认证，需要下载所有的区块头信息吗？**

完美的“布隆过滤器”

> 上文算过，就算全部区块的header信息均被下载，也才40MB，但是真的有必要吗？
>
> ***布隆过滤器（Bloom Filter）***；节点会在通信链路上建立一个布隆过滤器，过滤掉那些不包含有目标地址的交易信息，这一步能避免掉大量不相关的数据下载。
>
> 基于SPV机制和布隆过滤器功能，市面上出现了很多“轻钱包”，使得“轻钱包”在手机上就能运行，比如：ImToken，火币钱包等等。

# 从发出交易到打包 

> 1.  将交易广播到全网
> 2. 挖矿节点接到交易
> 3. 放入本地内存池进行验证（交易是否合法）
>
> - 验证成功，将其放入“未确认交易池”，等待被打包
>
> - 验证失败，交易被标记为“无效交易”，不会被打包。

```c
    发起一笔比特币转账后，要将交易广播到全网，挖矿节点接到这笔交易后，先将其放入本地内存池进行基本验证，比如该笔交易费的比特币是否是未被花费的交易。验证成功，就要将其放入“未确认交易池”，等待被打包；验证失败，该交易就会被标记为“无效交易”，不会被打包。

    也就是说，挖矿节点不仅要比拼算力，还要及时验证每笔交易，更新自己的“未确认交易池”。节点抢到记账权后，会从“未确认交易池”中抽取约近千笔“未确认交易”进行打包。有时交易无法被及时打包，是因为“未确认交易池”中的交易笔数太多，而各区块能记录的交易笔数有限，因此很容易造成区块拥堵。

    那么，比特币矿工什么时候停止打包交易？是否会出现交易不一致或交易遗漏的情况？其实，10分钟是系统找到的一个有效交易链块所需的平均时间，基于运气，这个时间会稍长或稍短。在挖矿激励下，不断验证发生的交易会产生新区块，如果来不及验证，就要排队等待；如果想提高被验证的优先级，就需要支付更多的手续费。

    区块产生机制决定了打包交易不一致和矿工选择性验证是不可能的。因为规则是固定的，不按照这个规则挖矿，就会产生一条不被认可的分叉：无法获得奖励，就没人选择，毕竟挖矿成本很高。
```

