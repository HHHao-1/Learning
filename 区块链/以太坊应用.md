# 创世块

## JSON文件

1. **手动创建：**

```json
{
  "config": {
    "chainId": 666,
    "homesteadBlock": 0,
    "eip150Block": 0,
    "eip150Hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "eip155Block": 0,
    "eip158Block": 0,
    "byzantiumBlock": 0,
    "constantinopleBlock": 0,
    "petersburgBlock": 0,
    "istanbulBlock": 0,
    "ethash": {}
  },
  "nonce": "0x0",
  "timestamp": "0x5ddf8f3e",
  "extraData": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "gasLimit": "0x47b760",
  "difficulty": "0x00002",
  "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "alloc": { },
  "number": "0x0",
  "gasUsed": "0x0",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
}
```

2. **puppeth生成：**

> puppeth是一个自动化运维管理工具，geth中自带

```json
{
    "config": {
        "chainId": 666,
        "homesteadBlock": 0,
        "eip150Block": 0,
        "eip150Hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
        "eip155Block": 0,
        "eip158Block": 0,
        "byzantiumBlock": 0,
        "constantinopleBlock": 0,
        "petersburgBlock": 0,
        "istanbulBlock": 0,
        "clique": {
            "period": 15,
            "epoch": 30000
        }
    },
    "nonce": "0x0",
    "timestamp": "0x5f350a96",
    "extraData": "0x00000000000000000000000000000000000000000000000000000000000000006f25fcf724d93a58da537489eeb295bb09f6f1648ab5ddc2708916dfbd6f8cb07999d78bf41c57940000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "gasLimit": "0x47b760",
    "difficulty": "0x1",
    "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "coinbase": "0x0000000000000000000000000000000000000000",
    "alloc": {
        "6f25fcf724d93a58da537489eeb295bb09f6f164": {
            "balance": "0x1000000000000000000"
        },
        "8ab5ddc2708916dfbd6f8cb07999d78bf41c5794": {
            "balance": "0x1000000000000000000"
        }
    },
    "number": "0x0",
    "gasUsed": "0x0",
    "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
}
```

**步骤：**

```stylus
//运行puppeth命令后会提示你输入私链的名称。
Please specify a network name to administer (no spaces, please)
> My-Private-Chain
```

```stylus
What would you like to do? (default = stats)
 1. Show network stats
 2. Configure new genesis
 3. Track new remote server
 4. Deploy network components
> 2
```

```stylus
//选择共识机制
Which consensus engine to use? (default = clique)
 1. Ethash - proof-of-work
 2. Clique - proof-of-authority
> 
```

- Ethash - proof-of-work(POW) ：工作量证明，通过算力达成共识 （以太坊就是使用这种方式）

- Clique - proof-of-authority(POA):  权威证明、通过预先设定的权威节点负责达成共识 (不消耗算力，一般用于私有链测试开发)

  > 如果选择Pow的共识方法,直接输入1，回车即可。
  >
  > 如果选择PoA的共识方法，输入2后会提示让你选择处快的间隔时间，一般测试开发使用可以设置相对的将出块时间设置较少5秒即可，然后会让你选择哪个账户来作为权威生成区块(至少有一个)

```stylus
How many seconds should blocks take? (default = 15)
> 5
Which accounts are allowed to seal? (mandatory at least one)
>0x0cfd3ab46d552d30f8b1c4f1b08a90f40192de97
```

```stylus
//选择好共识机制后会让你指定给那些账号初始化ether(至少有一个)，输入我们刚才创建的账户地址回车即可。
Which accounts should be pre-funded? (advisable at least one)
> 0xc43881d20bb2a2b6d72801b4bc04cdcc35950a8b
```

```stylus
//选择输入私有链的网络ID，任意数字即可（不能为1，1是公链），也可以不输入会给定一个随机数作为私有链的网络ID
Specify your chain/network ID if you want an explicit one (default = random)
> 666
```

```stylus
//创世区块中是允许你输入一些个人信息的，可以选择输入也可以直接按回车跳过
Anything fun to embed into the genesis block? (max 32 bytes)
>Test Private Chain
```

```stylus
What would you like to do? (default = stats)
 1. Show network stats
 2. Manage existing genesis
 3. Track new remote server
 4. Deploy network components
> 2
```

```stylus
 1. Modify existing fork rules
 2. Export genesis configuration
> 2
```

```stylus
//选择导出创世区块配置文件的保存路径，可以保存到当前目录，直接按回车即可
Which file to save the genesis into? (default = my-private-chain.json)
> 
INFO [02-09|14:56:33] Exported existing genesis block 

//完成创世区块配置，直接退出puppeth即可。
```

## 文件说明

### 1. chainID

链ID，在全球须唯一，各个链之间ID不同。ETH的ID是1， ETC的id是61。已经在用的ID有：

| `CHAIN_ID` | Chain(s)                      |
| :--------- | :---------------------------- |
| 1          | Ethereum mainnet              |
| 2          | Expanse mainnet               |
| 3          | Ropsten                       |
| 4          | Rinkeby                       |
| 30         | Rootstock mainnet             |
| 31         | Rootstock testnet             |
| 42         | Kovan                         |
| 61         | Ethereum Classic mainnet      |
| 62         | Ethereum Classic testnet      |
| 1337       | Geth private chains (default) |

### 2. 硬分叉设置

| 参数名称       | 参数描述                                 |
| -------------- | ---------------------------------------- |
| homesteadBlock | homesteadBlock硬分叉的高度，设置为0 即可 |
| eip150Block    | EIP 150硬分叉的高度，设置为0即可。       |
| eip150Hash     | EIP 150的hash值， 设置为0即可。          |
| eip155Block    | EIP 155硬分叉的高度，设置为0即可。       |
| eip158Block    | EIP 158硬分叉的高度，设置为0即可。       |
| byzantiumBlock | Byzantium硬分叉的高度，设置为0即可。     |

### 3. POA 挖矿参数

以太坊目前有ethash和clique两个共识引擎,其中ethash是用于正式网络的PoW(proof-of-work)共识引擎,clique是用于测试网络的PoA(proof-of-authority)共识引擎

| 参数名称   | 参数描述                                                     |
| ---------- | ------------------------------------------------------------ |
| clique     | period： 生成块的时间，15秒。   epoch： 生成DAG的大小，默认都是3万。 |
|            |                                                              |
| mixhash    | 与nonce配合用于挖矿,由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow paper,4.3.4. Block Header Validity, (44)章节所描述的条件。 |
| nonce      | nonce就是一个64位随机数,用于挖矿,注意他和mixhash的设置需要满足以太坊的Yellow paper, 4.3.4. Block HeaderValidity, (4)章节所描述的条件。 |
| difficulty | 设置当前区块的难度,如果难度过大, cpu挖矿就很难,这里设置较小难度 |
| alloc      | 用来预置账号以及账号的以太币数量,因为私有链挖矿比较容易,所以我们不需要预置有币的账号,需要的时候自己创建即可以。 |
| coinbase   | 矿工的账号,在这里不设置                                      |
| timestamp  | 设置创世块的时间戳                                           |
| parentHash | 上一个区块的hash值,因为是创世块,所以这个值是0                |
| extraData  | 附加信息,随便填,可以填你的个性信息；在POA机制下，这里写的是预分配账户 |
| gasLimit   | 该值设置对GAS的消耗总量限制,用来限制一个区块能包含的交易信息总和,因为我们是私有链,所以填最大。 |

# 创建私有链

1. **安装geth**

```stylus
brew install geth
```

2. **创建节点目录**

```stylus
mkdir eth
cd eth
mkdir enode1
mkdir enode2
```

3. **创建账号（POA共识机制下需要）**

```stylus
geth --datadir ./enode1/data account new
geth --datadir ./enode1/data account new
```

4. **初始化节点**

```stylus
geth --datadir enode1/data init my-private-chain.json 
geth --datadir enode2/data init my-private-chain.json 
```

初始成功后会在数据目录data下生产geth和keystore两个文件夹

> geth目录：保存链上的区块数据
>
> keystore目录：保存链上的账户数据

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghpl8bgnodj30ah09idh5.jpg" alt="EC5FC340-ECBA-4D70-A3C4-62506E0B4C88"  align="left"/>

5. **启动节点**

```shell
geth --rpc --nodiscover --datadir ./enode1/data --port 30303 --rpc --rpcport 8545 --rpcapi "db,eth,net,web3" --rpccorsdomain "*" --networkid 666 --ipcdisable console --allow-insecure-unlock
```

> --allow-insecure-unlock：允许不安全解锁，开启后控制台内才可以对账户解锁

```shell
geth attach rpc:http://127.0.0.1:8545 
#连接geth javaScript控制台，也可以：geth console 2>>geth.log
```

| 参数            | 参数描述                                                     |
| --------------- | ------------------------------------------------------------ |
| --identity      | 区块链的标示，随便填写，用于标示目前网络的名字               |
| --datadir       | 私有链数据存放目录，包括Ethereum使用的Leveldb数据            |
| --port          | geth的网络端口，默认是30303,如果一台电脑上多个节点一定设置不同的端口 |
| --rpc           | 启动rpc通信，可以进行智能合约的部署和调试                    |
| --rpcaddr       | 指定HTTP-RPC服务监听地址，默认为“localhost”                  |
| --rpcapi        | 设置允许连接的rpc的客户端，一般为db,eth,net,web3             |
| --rpcport       | 指定允许连接的rpc服务监听端口，默认为8545,如果一台电脑上多个节点一定设置不同的端口 |
| --rpccorsdomain | 设置哪些URL可以连接你的RPC接口。                             |
| --networkid     | 设置当前区块链的网络ID，用于区分不同的网络，1代表是公链，与创世块的chainId相同 |
| --nat           | 根据自己网络情况选择是否添加                                 |
| --nodiscover    | 关闭自动连接节点，但是可以手动添加节点，在搭建私有链时，为避免其他节点连入私有链，可以使用该命令 |
| --ipcdisable    | 不能使用IPC连接                                              |
| --etherbase     | 指定旷工账号，默认为keystore中的首个账号                     |
| --mine          | 开启挖矿，默认为CPU挖矿                                      |
| --minerthreads  | 挖矿占用CPU的线程数，默认为4                                 |
| --maxpeers      | 设置允许最大连接节点数目，默认为25                           |
| console         | 启动命令行模式，可以在Geth中执行命令                         |

6. **控制台操作**

这是一个交互式的 JavaScript 执行环境，在这里面可以执行 JavaScript 代码。这个环境里内置了一些用来操作以太坊的 JavaScript 对象，可以直接。

**主要对象：**

> eth：包含一些跟操作区块链相关的方法；
>
> net：包含一些查看p2p网络状态的方法；
>
> admin：包含一些与管理节点相关的方法；
>
> miner：包含启动&停止挖矿的一些方法；
>
> personal：主要包含一些管理账户的方法；
>
> txpool：包含一些查看交易内存池的方法；
>
> web3：包含了以上对象，还包含一些单位换算的方法。

**账户相关：**

```stylus
eth.accounts               // 查询账户列表
personal.listAccounts      // 查询账户列表
eth.accounts[0]			   // 查看账户列表的第一个账户
personal.listAccounts[0]   // 查看账户列表的第一个账户
personal.newAccount("xxx") // 新建账户，xxx为账户密码，也可为空
eth.coinbase          	   // 节点挖矿的账户地址，默认为账户列表的第一个账户
miner.setEtherbase(xxx)    // 设置挖矿的账户，xxx为账户地址
eth.getBalance("xxx")      // 查看对应账户的余额，xxx为账户地址
			               // 返回值的单位是wei，wei是以太币的最小单位，1个以太币=10^18wei。
web3.fromWei()             // 将返回值换算成以太币
web3.fromWei(eth.getBalance(eth.account[0]))   
//解锁账户（账户，密码，解锁时间【单位是秒】）
personal.unlockAccount(eth.accounts[0],"123",6000)
```

**交易相关：**

```stylus
//发送转账交易，返回交易的哈希
eth.sendTransaction({from:eth.accounts[0],to:"0xdb2e9d8b44b8e52b276cb3b81764076d77bea6fb",value:web3.toWei(0.005, "ether")})
返回："0x70b014b7ded02aadb2e78c48e1ab8762694ffb82d0189e180b14318ec8455cd7"
//查看交易信息
eth.pendingTransactions
// 查看交易信息
eth.getTransaction("交易的哈希") 
// 查看交易池，查看当前交易的待处理状态
txpool.status        
```

**挖矿相关：**

```stylus
//开始挖矿
//参数表示挖矿使用的线程数。
//第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。
miner.start(1)              
//挖到第一个区块即停止挖矿
admin.sleepBlocks(1)
// 停止挖矿
miner.stop()               
//组合输入
miner.start(1);admin.sleepBlocks(1);miner.stop()
```

**区块相关：**

```stylus
// 查看链上区块数量
eth.blockNumber
// 根据区块号查看区块信息，xxx为区块号
eth.getBlock(xxx)          
```

**节点相关：**

```stylus
// 查看节点信息
admin.nodeInfo             
// 查看节点enode信息
admin.nodeInfo.enode
// 添加节点
admin.addPeer("enode://52ee8fd33d8d37093b5be9171b209140ebe34e70a6bd286a998d0d1128780fdd18f4cac99b67cd8615e04214e405340d5afe41bb5e8426a01b00dc47a9a2e9ae@127.0.0.1:30304?discport=0")
//查看网络中已连接节点信息
admin.peers
// 查看网络中已连接节点数量
net.peerCount
```

**遇到问题：**

```stylus
1. //“Signed recently, must wait for others”问题:

如：在配置创世区块配置文件的时候 , 指定了2个有签名权限的账户 , 分别属于2个节点 。
需要登录第2个节点控制台 , 启动挖矿。如果节点连接没有问题 , 2个节点开始刷屏 , 那么说明挖矿启动成功了。 
如果第2个节点也停留在 “Signed recently, must wait for others” . 说明节点没有连通。

原则 : 在网络中 , 任何更改都需要由50%+1个节点提出 , 以使其生效 。对于2个签名者 , 50%+1实际上是2 , 所以需要让第2个签名者的节点也启动挖矿。
```

# 代币

## 简单代币

```js
pragma solidity ^0.4.20;

contract MyToken {
    //定义映射：账户地址 => 代币余额
    mapping (address => uint256) public balanceOf;

    //给创建者初始化代币数量
    constructor(uint256 initialSupply) public {
        //msg.sender：外部函数调用者的地址
        balanceOf[msg.sender] = initialSupply;              
    }
    //定义代币转账函数
    function transfer(address _to, uint256 _value) public {
        // Check if the sender has enough
        require(balanceOf[msg.sender] >= _value);           
        // Check for overflows,可能会溢出（uint256存储的数值范围是固定的）
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        // Subtract from the sender
        balanceOf[msg.sender] -= _value;   
        // Add the same to the recipient
        balanceOf[_to] += _value;                           
    }
}
```

## ERC-20代币

```js
pragma solidity ^0.4.20;


contract ERC20Interface {
    string public name;
    string public symbol;
    uint8 public  decimals;
    uint public totalSupply;
    
	//默认可见性为public
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) view public returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}

contract ERC20 is ERC20Interface {

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) internal allowed;

    constructor() public {
        totalSupply = 100000000;
        name = "HAO Token";
        symbol = "HAO";
        decimals = 10;
        balanceOf[msg.sender] = totalSupply;
    }

    function balanceOf(address _owner) view public returns (uint256 balance) {
        return balanceOf[_owner];
    }

    function transfer(address _to, uint _value) public returns (bool success) {
        //address(0)：将0转换为地址类型，既_to地址不能为0
        require(_to != address(0));
        require(_value <= balanceOf[msg.sender]);
        //判断是否产生溢出
        require(balanceOf[_to] + _value >= balanceOf[_to]);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balanceOf[_from]);
        require(_value <= allowed[_from][msg.sender]);
        require(balanceOf[_to] + _value >= balanceOf[_to]);

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;

        allowed[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

}
```

## ERC-20标准

以下规范使用Solidity 0.4.17（或更高版本）中的语法

调用者必须处理返回的错误 `returns (bool success)`。调用者不得以为永远不会返回false！！！

ERC-20文档：https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md

- ### 可选方法

> #### name
>
> 返回令牌的名称。例如：“ MyToken”。
>
> ```
>function name() public view returns (string)
> ```
> 
> #### symbol
>
> 返回令牌的代号。例如：“ HIX”。
>
> ```
>function symbol() public view returns (string)
> ```
>
> #### decimals
> 
> 返回令牌的小数位数。例如：返回10就相当于可以使用0.1个代币
>
> ```
>function decimals() public view returns (uint8)
> ```

- ### 必须方法

> #### totalSupply
>
> 返回令牌供应总量。
>
> ```
> function totalSupply() public view returns (uint256)
> ```
>
> #### balanceOf
>
> 返回地址为_owner的帐户的余额。
>
> ```
> function balanceOf(address _owner) public view returns (uint256 balance)
> ```
>
> #### transfer
>
> 将\_value个令牌的数量转移到地址 _to，并且必须触发Transfer事件。
>
> **调用者转移代币**
>
> 注意:传递0值必须视为正常传递，并触发Transfer事件。
>
> ```
> function transfer(address _to, uint256 _value) public returns (bool success)
> ```
>
> #### transferFrom
>
> 将\_value个令牌的数量从地址 \_from转移到地址 \_to，并且必须触发Transfer事件。 
>
> **账户间转账**
>
> 注意:传递0值必须视为正常传递，并触发Transfer事件。
>
> ```
> function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)
> ```
>
> #### approve
>
> **调用者委托\_spender账户操作自己的账户的\_value数量的代币**
>
> \_spender 需要发送token的地址， _value 发送token的数量，return 是否成功
>
> ```
> function approve(address _spender, uint256 _value) public returns (bool success)
> ```
>
> #### allowance
>
> **查询\_owner委托\_spender操作多少代币**
>
> \_owner 拥有token的地址，\_spender 可以发送token的地址，return 允许发送的token的数量
>
> ```
> function allowance(address _owner, address _spender) public view returns (uint256 remaining)
> ```

- ###事件

> #### Transfer
>
> **监听转移事件**
>
> 必须在令牌传输（包括零值传输）时触发。
>
> 创建新令牌的令牌合约应在创建令牌时触发_from地址设置为0x0的Transfer事件。
>
> ```
> event Transfer(address indexed _from, address indexed _to, uint256 _value)
> ```
>
> #### Approval
>
> **监听委托事件**
>
> 必须在任何成功委托的调用上触发。
>
> ```
> event Approval(address indexed _owner, address indexed _spender, uint256 _value)
> ```
>

# pet-shop

## 构建工程

1. ```
   mikdir pet-shop
   cd pet-shop
   ```

2. ```
   truffle init
   ```

   <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghutnmmjj8j30az05umyr.jpg" alt="9CD0E14C-A5F8-44D0-9FD9-98EDEE2D8DB9"  align=""/>

   **文件介绍：**

   **contracts:**  智能合约目录

   > 1. migrations.sol部署（迁移）合约：防止我们部署相同的合约
   >
   >    ```
   >    初始迁移合约一般不需要修改，他们是跟踪部署在区块链上的地址。当然也可以按照自己的需要修改 `Migrations.sol` 合约文件，进行一些高级的迁移管理，但需要保留 `truffle init` 命令创建的接口。
   >    ```
   >
   > 

   **migrations:**  用来进行部署（迁移）的目录

   > 1. migrations下放置一些js脚本帮助我们部署合约到以太坊网络中去
   >
   > 2. 1_initial_migration.js部署部署合约，仅仅是说明如何把 `Migrations.sol` 合约部署到对应的链上。
   >
   > 3. 迁移文件说明：
   >
   >    ~~~js
   >    文档名称：2_adoption_migration.js
   >    
   >    ```
   >    var Adoption = artifacts.require("Adoption");
   >    
   >    module.exports = function(deployer) {
   >      deployer.deploy(Adoption);
   >    };
   >    ```
   >    
   >    1. 文件名带有数字前缀，并带有描述后缀。为了记录迁移是否成功运行，需要带编号的前缀。
   >    2. 后缀仅用于人类可读性和理解性。前缀代表着 truffle migrate 运行迁移文件的顺序（从 1 开始）。 
   >    3. 在每个合约部署完成，Truffle 会把迁移序号保存到 Migrations 合约的 `last_completed_migration`
   >    
   >    /* 假设 `migrations` 两个迁移文件，`truffle migrate` 运行时实际会发生 4 笔交易：
   >    1. 运行 `1_initial_migration.js` 进行部署
   >    2. 把序号 1 写入到合约的状态变量 last_completed_migration
   >    3. 运行 `2_mycontract_migration.js` 进行部署
   >    4. 把序号 2 写入到合约的状态变量 last_completed_migration */
   >    ~~~
   >
   >    ```css
   >    关于`last_completed_migration`：
   >    
   >    1. `last_completed_migration` 表示的是最后部署的迁移，之后再加入其它的迁移文件： `3_your_contract.js` 时， 运行 truffle migrate 时 Truffle 会首先读取 l`ast_completed_migration` 状态变量，参看之前部署到了哪，再部署比 `last_completed_migration` 序号大的（所有）迁移文件，这样就可以保证不会重复部署。 
   >    
   >    2. 如果修改一个已有的合约，需要重新部署的话，直接运行 `truffle migrate` 是不会自动部署的，需要新加（或修改）一个更高序号的迁移文件，再运行 `truffle migrate`。
   >    
   >    3. `truffle migrate` 可以接一个 `-f 序号` 来强制重从一个需要的序号开始执行迁移（此时会忽略`last_completed_migration` 的值）。 例如： `truffle migrate -f 2` 会从第 2 个迁移文件开始部署。
   >    ```

   **test:**  测试目录

   **truffle-config.js:**  truffle的配置文件

   > 1. 以太坊网络配置，默认panache网络，配置后可部署
   >
   >    ```js
   >    //默认ganache网络
   >    host       > 127.0.0.1
   >    port       > 7545
   >    network_id > 5777
   >    ```

   

   

# Truffle

box：truffle的包，封装了一系列功能，如react、pet-shop（truffle提供的一个应用例子）

trffle unbox 包：下载box

![C4633D33-CF0B-483D-9352-1C6CFEB7276D](https://tva1.sinaimg.cn/large/007S8ZIlly1ghsou7so51j30rf01ldh3.jpg)

# Ganache

模拟本地在内存的区块链环境用来测试，既每次重启数据丢失，只有本地一个节点，会为我们创建账号

truffle运行时会用ganache来为我们提供环境



命令：truffle migrate（部署合约到区块链）

##  迁移文件

一个简单的迁移文件如下所示：

文档名称： `4_example_migration.js`

```javascript
var MyContract = artifacts.require("MyContract");

module.exports = function(deployer) {
  // deployment steps
  deployer.deploy(MyContract);
};
```

请注意，文件名带有数字前缀，并带有描述后缀。为了记录迁移是否成功运行，需要带编号的前缀。后缀仅用于人类可读性和理解性。1_initial_migration.js` 迁移文件名，前面的序号，代表着 truffle migrate 运行迁移文件的顺序，`1` 表示第一个运行的迁移文件（从 1 开始）。 我们可以创建其他的迁移文件： `2_mycontract_migration.js` ，在每个合约部署完成，Truffle 会把迁移序号保存到 Migrations 合约的 `last_completed_migration

假设 `migrations` 就这两个迁移文件，`truffle migrate` 运行时实际会发生 4 笔交易：

1. 运行 `1_initial_migration.js` 进行部署
2. 把序号 1 写入到合约 Migrations
3. 运行 `2_mycontract_migration.js` 进行部署
4. 把序号 2 写入到合约 Migrations

`last_completed_migration` 表示的是最后部署的迁移，之后再加入其它的迁移文件：`3_yourcontract.js` 时， 运行 `truffle migrate` 时 Truffle 会首先读取 `last_completed_migration` 状态变量，参看之前部署到了哪些，在部署比 `last_completed_migration` 序号大的（所有）迁移文件，这样就可以保证不会重复部署。

注意，如果修改一个已有的合约，需要重新部署的话，直接运行 `truffle migrate` 是不会自动部署的，需要新加（或修改）一个更高序号的迁移文件，再运行 `truffle migrate`。

`truffle migrate` 可以接一个 `-f 序号` 来强制重从一个需要**开始**执行迁移（此时会忽略 `last_completed_migration` 的值）。 例如： `truffle migrate -f 2` 会从第 2 个迁移文件开始部署。

![DE1831EA-3CD0-435D-AFF6-3D14E989AA47](https://tva1.sinaimg.cn/large/007S8ZIlly1ghszc8xv7mj30nl0ax0w5.jpg)

`truffle migrate`之前与之后

![7C74FED5-0852-4C99-A674-6647D49FA586](https://tva1.sinaimg.cn/large/007S8ZIlly1ghszq254mtj30h905smyx.jpg)

![D063C6A4-A540-46B9-9E1A-FAF0B13FD8FC](https://tva1.sinaimg.cn/large/007S8ZIlly1ghszpksl1hj30ne06dmzt.jpg)

使用ganache，ganache会产生4个区块，四条交易，可产看交易详细信息

# 配置

将调用您的配置文件`truffle-config.js`，该文件位于项目目录的根目录下。该文件是Javascript文件，可以执行创建配置所需的任何代码。它必须导出一个代表您的项目配置的对象，如下例所示。

```javascript
module.exports = {
  networks: {
    development: {
      host: "127.0.0.1",
      port: 8545,
      network_id: "*" // Match any network id
    }
  }
};
```

默认配置随附运行于的单个开发网络的配置`127.0.0.1:8545`





## Test

命令：truffle test

```js
pragma solidity ^0.4.17;

import 'truffle/Assert.sol';
import 'truffle/DeployedAddresses.sol';
import '../contracts/Adoption.sol';

contract TestAdoption {
    
    //通过DeployedAddresses获取Adoption合约实例
    Adoption adoption = Adoption(DeployedAddresses.Adoption());
	//测试是否领养到id匹配的宠物
    function testUserCanAdoptPet() public {
        uint returnedId = adoption.adopt(8);
        uint expected = 8;
        Assert.equal(returnedId, expected, "Aoption of pet Id 8 should be recorded.");
    }
	//测试领养者地址是否正确
    function testGetAdopterAddressByPetid() public {
        address expected = this;
        //adopters(8)，外部调用public变量相当于getter函数，参数是因为该变量是数组
        address adopter = adoption.adopters(8);
        Assert.equal(adopter, expected, "Owner of pet ID 8 should be recorded.");
    }
	//测试adopters变量，既领养者的信息
    function testGetAdopterAddressByPetIdInArray() public {
        address expected = this;
        address[16] memory adopters = adoption.getAdopters();
        Assert.equal(adopters[8], expected, "Owner of Pet Id 8 should be recoded.");
    }
}
```

# 编写web部分

npm init

将其转换成一个可以用npm管理的一个工程

![F56EAB5A-01B6-4199-9014-5EED2B036EFE](https://tva1.sinaimg.cn/large/007S8ZIlly1ght1babqxlj30hq04ydhe.jpg)

生成package.json：显示工程信息及管理依赖

![ADEC0782-8058-4395-B722-908F9B6D65FC](https://tva1.sinaimg.cn/large/007S8ZIlly1ght1upvqqij30i602ujso.jpg)

提供服务器

Bs-config：配置lite server告诉它去哪里找文件

```js
{
    "server": {
        "baseDir": ["./src", "./build/contracts"]
    }
}
```

这里加入脚本

![38373331-D3A6-4C26-B2C0-C4060D946955](https://tva1.sinaimg.cn/large/007S8ZIlly1ght2cfafczj30ua06jdiz.jpg)

src加入view页面

npm run dev ： 启动

truffle-conract.js是对web3.js的封装,用来和智能合约交互

package-lock.json 是在 `npm install`时候生成一份文件，用来记录当前状态下实际安装的各个npm package的具体来源和版本号。

 为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。

 ![84339B70-F17A-481F-9280-9D2A7A785C31](https://tva1.sinaimg.cn/large/007S8ZIlly1ghtz26z6vjj30q70dpgol.jpg)

Truffle-contract：对web3的包装，支持js的一些高级语法（详见文档Features）

Web3:

# Web3.js

web3.js 是一组使用HTTP或IPC连接来和本地或远程以太坊节点进行交互的库。

一个App对象来管理整个应用

init: function() 初始化呢函数时调用initWeb3: function()---initContract: function() ---bindEvents: function()---绑定Adopt按钮---

handleAdopt: function(event)---调用合约的领养方法---markAdopted: function(adopters, account) ---处理已经被领养过的状态

```
$(function() {
  $(window).load(function() {
    App.init();
  });
});
//加载window时，调用App的init方法
```

两段代码：

初始化web3

truffle-contact使用

TruffleContract对象通过deployed()拿到合约的实例

# promise写法？then

