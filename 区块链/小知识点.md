# 名词解释

## ABI

ABI全称 Application Binary Interface，字面意思是应用程序二进制接口，可以通俗的理解为合约的接口说明，当合约被编译后，它对应的abi也就确定了。

abi有点类似于程序中的接口文档，描述了字段名称、字段类型、方法名称、参数名称、参数类型、方法返回值类型等

### 为什么需要ABI

我们编写智能合约的流程是：

- 编写合约代码（一般使用solidity语言）
- 编译合约，将solidity编写的代码编译成EVM可识别的bytecode，这一步生成abi
- 部署合约，将合约部署到区块链上，生成合约地址，将合约内容（即上一步生成的bytecode）作为input date输入。部署合约是一个交易过程，所以也会生成一个交易Hash
- 执行合约，获取合约地址，然后传入参数调用合约中的方法，获得执行结果

从上面的步骤可以看出，abi对于EVM来说，其实是不需要的。但是对于调用者来说，就需要知道合约有哪些方法，方法的参数是什么，返回值是什么，而这些信息就记录在智能合约的abi中。所以abi其实就相当于开发者的接口文档，方便开发者调用执行合约

### ABI有哪些内容

编写一个最简单的合约，然后编译生成abi看下内容

```c#
pragma solidity ^0.4.24;

contract Demo {
    uint private x;
    function set(uint _x) public {
        x = _x;
    }
}
```

执行 `truffle compile` 编译合约，就会生成对应的文件`Demo.json`，内容如下。由于json太长，删除了一些不重要的内容，完整内容可以自己手动执行看看。

```json
{
    "contractName": "Demo",
    "abi": [
        {
            "constant": false,
            "inputs": [
                {
                    "name": "_x",
                    "type": "uint256"
                }
            ],
            "name": "set",
            "outputs": [],
            "payable": false,
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ],
    "bytecode": "0x6080604052348015600f57600080fd5b5060a48061001e6000396000f300608060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b1146044575b600080fd5b348015604f57600080fd5b50606c60048036038101908080359060200190929190505050606e565b005b80600081905550505600a165627a7a723058201dfe7c019fec67ccd87250c9ac8642c163cc5f43588715b33e8a8953df3715f60029",
    "deployedBytecode": "0x608060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b1146044575b600080fd5b348015604f57600080fd5b50606c60048036038101908080359060200190929190505050606e565b005b80600081905550505600a165627a7a723058201dfe7c019fec67ccd87250c9ac8642c163cc5f43588715b33e8a8953df3715f60029",
    "sourceMap": "27:97:1:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;27:97:1;;;;;;;",
    "deployedSourceMap": "27:97:1:-;;;;;;;;;;;;;;;;;;;;;;;;69:52;;8:9:-1;5:2;;;30:1;27;20:12;5:2;69:52:1;;;;;;;;;;;;;;;;;;;;;;;;;;;112:2;108:1;:6;;;;69:52;:::o",
    "source": "pragma solidity ^0.4.24;\n\n\ncontract Demo {\n\n    uint private x;\n\n    function set(uint _x) public {\n        x = _x;\n    }\n\n}\n",
    "sourcePath": "/Users/root/Workspace/DApp/demo/contracts/Demo.sol",
    "ast": {
        ...
    },
        "legacyAST": {
            ...
        },
            "compiler": {
                "name": "solc",
                "version": "0.4.24+commit.e67f0147.Emscripten.clang"
            },
            "networks": {},
            "schemaVersion": "2.0.1",
            "updatedAt": "2018-09-14T11:57:49.750Z"
        }
    }
}
```

大部分参数通过名称就可以看出来含义，这里我们主要介绍abi中各参数的含义和调用函数时生成ABI编码的过程

### abi各参数的含义

- `name`：函数名称
- `type`：方法类型，包括`function`, `constructor`, `fallback`(缺省方法)可以缺省，默认为`function`
- `constant`：布尔值，如果为true指明方法不会修改合约字段的状态变量
- `payable`：布尔值，标明方法是否可以接收ether
- `stateMutability`：状态类型，包括`pure` (不读取区块链状态)，`view` (和constant类型，只能查看，不会修改合约字段)，`nonpayable`（和payable含义一样），`payable`（和payable含义一样）。其实保留`payable`和`constant`是为了向后兼容
- `inputs`：数组，描述参数的名称和类型
  - `name`：参数名称
  - `type`：参数类型
- `outputs`：和`inputs`一样，如果没有返回值，缺省是一个空数组

这里要说明一点的是，由于示例中的`x`字段类型为`private`，所以没有生成一个和参数名称一样的函数，如果`x`字段类型为`public`，生成的abi就如下，会多一个和参数名称一样的函数(将状态变量声明为public将自动为其创建getter方法)

```bash
"abi": [
    {
      "constant": true,
      "inputs": [],
      "name": "x",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "name": "_x",
          "type": "uint256"
        }
      ],
      "name": "set",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    }
```

## 公钥加密系统

 Alice有一把公钥和一把私钥。她可以用她的私钥创建数字签名，而Bob可以用她的公钥来验证这个签名确实是用Alice的私钥创建的，也就是说，确实是Alice的签名。当你创建一个以太坊或者比特币钱包的时候，那长长的`0xdf...5f`地址实质上是个公钥，对应的私钥保存某处。类似于Coinbase的在线钱包可以帮你保管私钥，你也可以自己保管。如果你弄丢了存有资金的钱包的私钥，你就等于永远失去了那笔资金，因此你最好对私钥做好备份。

## 点对点网络

就像BitTorrent, 以太坊分布式网络中的所有节点都地位平等，没有中心服务器。(未来会有半中心化的混合型服务出现为用户和开发者提供方便。)

## EVM

以太坊虚拟机 ，它让你能在以太坊上写出更强大的程序（比特币上也可以写脚本程序）。它有时也用来指以太坊区块链，负责执行智能合约以及一切。

## 节点

你可以运行节点，通过它读写以太坊区块链，也即使用以太坊虚拟机。完全节点需要下载整个区块链。轻节点仍在开发中。

## 矿工

挖矿，也就是处理区块链上的区块的节点。

## 以太币

缩写ETH。一种你可以购买和使用的真正的数字货币

## Gas

在以太坊上执行程序以及保存数据都要消耗一定量的以太币，Gas是以太币转换而成。这个机制用来保证效率。

## DApp

以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。DApp的目标是(或者应该是)让你的智能合约有一个友好的界面，外加一些额外的东西，例如IPFS（可以存储和读取数据的去中心化网络，不是出自以太坊团队但有类似的精神)。DApp可以跑在一台能与以太坊节点交互的中心化服务器上，也可以跑在任意一个以太坊平等节点上。(花一分钟思考一下：与一般的网站不同，DApp不能跑在普通的服务器上。他们需要提交交易到区块链并且从区块链而不是中心化数据库读取重要数据。相对于典型的用户登录系统，用户有可能被表示成一个钱包地址而其它用户数据保存在本地。许多事情都会与目前的web应用有不同架构。

## 客户端

以太坊有许多不同语言的客户端实现（即多种与以太坊网络交互的方法），包括C++, Go, Python, Java, Haskell等等。为什么需要这么多实现？不同的实现能满足不同的需求（例如Haskell实现的目标是可以被数学验证），能使以太坊更加安全，能丰富整个生态系统。

交互式控制台。 客户端运行起来后，你就可以同步区块链，建立钱包，收发以太币了。使用geth的一种方式是通过[Javascript控制台](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console)（JavaScript console, 类似你在chrome浏览器里面按F12出来的那个，只不过是跑在终端里）。此外还可以使用类似curl的命令通过[JSON RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC)来与客户端交互。本文的目标是带大家过一边DApp开发的流程，因此这块就不多说了。但是我们应该记住这些命令行工具是调试，配置节点，以及使用钱包的利器。

在测试网络运行节点。 如果你在正式网络运行geth客户端，下载整个区块链与网络同步会需要相当时间。（你可以通过比较节点日志中打印的最后一个块号和以太坊网址上列出的最新块来确定是否已经同步。) 另一个问题是在正式网络上跑智能合约需要实实在在的以太币。在测试网络上运行节点的话就没有这个问题。此时也不需要同步整个区块链，创建一个自己的私有链就好了了，对于开发来说更省时间。

## truffle

truffle是本地的用来编译、部署智能合约的工具

## testrpc

testrpc不同于geth，geth是真正的以太坊环境，testrpc是在本地使用内存模拟的一个以太坊环境，对于开发调试来说，更为方便快捷，当你的合约在testrpc中测试通过后，再可以部署到geth中去

testrpc 现在已经并入到Truffle 开发框架中，现在名字是ganache-cli

注意：它仅运行在內存中，因此每次重开时都会回到全新的状态

### ganache

ganache相当于是testrpc的升级版，有图形界面

注意：它仅运行在內存中，因此每次重开时都会回到全新的状态

## 智能合约

> 将合约条款代码化
>
> 以太坊上的程序,是代码和数据(状态)的集合
>
> 典型应用：代币: EOS ，游戏：迷恋猫

你愿意和从未谋面的人签合约吗？你会同意把钱借给埃塞俄比亚的农民吗？你愿意投资一个战乱地区由少数人管理的报纸吗？你会不嫌麻烦为了网上一次5美元的购买签一个有法律效力的合约吗？

大多数的答案都是否定的，原因是合约需要的基础太多了：有时需要双方之间互相信任的工作关系，有时要依靠合法的工作体系、警察和律师费用。

在以太坊这些都不需要：**如果合约所必需的要求都能放在区块链中，那么就会放在区块链中，这是一个无需信任基础也几乎不用任何成本的环境**。

 不要想将你现有的合约转移到区块链中会麻烦，想一想那些因为经济上不可行或是没有足够法律保护而被你拒绝的成千上万的小合约吧。

## DAO

> Decentralized Autonomous Organization，简称DAO，一般翻译为去中心化的自治组织。

这里简单地举个例子：想象一下你和朋友有个小生意。律师和会计很贵，完全信任让一个单独的合伙人来看管账簿可能让你精神很紧张（这甚至可能是个诈骗的机会）。你可以尝试一下多个合伙人共同看管账簿，但只要协议没有被严格遵守，就可能导致诈骗发生。

使用智能合约，公司的所有权和基金分配的条款可以在一开始就详细规定。智能合约签署的方式是，只有大部分拥有者批准，合约才可以变更。 这样的智能合约可以像开源软件一样获取，你甚至都不必雇佣自己的程序员来代替会计和律师。

这样的智能合约可以立即按比例决定分配。几个年轻人分配柠檬水站收入，可以像主权基金给拥有基金的亿万公民分配收益一样透明。在这两个案例中，这种透明性带来的花费可能每美元连一美分都不到。

## DAG

**DAG**是有向无环图。它用于所有Ethash算数的数字货币，如ETH-以太坊，ETC-以太经典，MUSIC-乐币，ETP-元界，DBIX-迪拜币，CLO，EXP，UBQ等其它数字货币，以提供工作量证明。DAG文件在每个挖矿纪元（epoch）都会生成一个DAG，并且会不断增加。了解DAG文件的当前和未来的大小非常重要，因为它对挖矿速度会产生很大影响。DAG文件直接位于GPU显存中。如果DAG文件比GPU显存大，那么你的显卡就不能再进行挖矿。要分析未来的dag大小，您可以查看下表。

**DAG**文件每个纪元（epoch）都会改变。一个纪元（epoch）是30000个区块。DAG文件的增加速度直接取决于出块时间。但出块时间不稳定，以太坊可能会从10秒到60秒不等。因此，每个纪元（epoch）都没有固定产生时间，它是以块为单位决定的。一般来说，以太坊的DAG文件每年增加0.72倍。但这还是得看出块时间。对于出块时间较慢的其他数字货币，DAG文件增加较慢，GPU可以挖矿很长时间。

bitcoin之所以效率低是因为它的POW机制. 整个网络只有一个主链, 其上的新块只能有一个, 无法同时创建多个新块. 10分钟左右以内的所有交易记录都被记录到一个块中. Ethereum也是类似, 大概15-20秒产生一个新块。有了DAG, 就可以同一时间创建多个块。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghp7pezlc8j30om0ctwhn.jpg" alt="0F68C9A2-B75A-4C7B-870B-7844452483B5" style="zoom:50%;" />

对于每一个块，首先计算一个种子(seed)，该种子只和当前块的信息有关;然后根据种子生成一个32M的随机数据集（cache）

根据Cache生成一个1GB大小的数据集合DAG(有向非循环图)，它是一个完整的搜索空间，挖矿的过程就是从DAG中随机选择元素(类似于比特币挖矿中查找合适Nonce)再进行哈希运算，可以从Cache快速计算DAG指定位置的元素，进而哈希验证。要求对Cache和DAG进行周期性更新，每1000个块更新一次，并且规定DAG的大小随着时间推移线性增长，从1G开始，每年大约增长7G左右。

## 硬/软分叉

软分叉：在区块链中产生分叉短时间出现过另外一条分叉链，随后被抛弃，这样的分叉称为软分叉。（如：比特币）

硬分叉：

1. 在区块链中产生分叉后本该被抛弃的分叉链，被保留了下来，这样的分叉被称为硬分叉。（分叉链由于有人号召大家或其他原因，得到维护者的响应继续维护此链，那么这条链就会逐渐壮大起来，不会消失）

2. 因为区块链的共识发生了分歧，而产生的新的共识规则发布之后，一些没有升级的节点无法验证已经升级的节点生产出来的区块，如果不能达成一致，分叉有可能会出现分叉币，实现硬分叉。

   ```css
   历史上最出名的硬分叉事件：
   2016年5月底由以太坊创始人Vitalik Buterin主导的一个叫做The DAO的项目使用以太币来众筹，结果超过1200万个以太币被黑客盗取，V神提出设想，通过硬分叉使得黑客利用漏洞转出交易的区块失效，找回丢失的以太币。当时超过85%的以太坊算力支持硬分叉，以太坊硬分叉成功。新链是以太坊ETH，旧链是以太经典ETC。对部分区块链信仰者来说，此次硬分叉是对区块链的背叛，采用了人为手段进行强制回滚，违背了区块链不能修改的技术本质。他们反对此次硬分叉并且在原有链上继续贡献自己的算力，所以ETC一直活着并逐渐在各交易平台上市，而且ETC价格极低。
   ```

## 共识机制

### 分布式记账场景

**下面归纳现区块链主流共识算法(机制)：**

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1ghqi7f9opkj30ca0bpq35.jpg)

### PoW

> POW（Proof of Work，工作量证明）

**“解决一道数学难题”，“机器性能越好，挖矿时间越长，获得的回报也越多。”**

类型：竞争共识

概念：工作量证明，引入了对一个特定值的计算工作。

POW共识算法应用场景：比特币（BTC）及其引申出来的BCH、BCD等

**算法工作描述：**

1. 矿工们在挖一个新的区块时，必须对SHA-256密码散列函数进行运算，区块中的随机散列值以一个或多个0开始。
2. 随着0数目的上升，找到这个解所需要的工作量将呈指数增长，矿工通过反复尝试找到这个解。

**解决问题：**

1. 谁有权记账
2. 如何避免记账者作弊

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1ghqibwgeyej30jy0inwgn.jpg)

**优点：**

算法简单，采用大家认可的数学逻辑（找寻随机数），容易实现。安全系数最高，破坏整个系统，需要投入巨大成本。

**缺点：**

1. 大量消耗能源。
2. 它的价值回路必须要通过外部输入。也就是说，采用POW的数字货币仍旧不是理想状态的数字货币，因为它们的安全性不直接与使用者相关，而是要通过矿工这个媒介。

**使用该算法的项目(包含且不限于)：**

Bitcoin、Ethereum、Litecoin、Dogecoin 

### PoS

> POS（Proof of Stake，权益证明）

**“拥有的币越多，有记账权的概率就越大？”**

类型：竞争共识

因为POW大量消耗能源和安全性不与使用者相关的问题，POS的出现可以解决这些问题：

1. 采用POS的货币的安全性直接与使用者相关，省去了矿工这个媒介。
2. POS简单说就是，每当发表一条消息的时候，不用证明你付出了什么代价，而要证明你拥有一定数量的钱。而拥有钱代表着，如果你作弊损害了这个系统的安全性，你的钱会贬值，这变相地让你付出了代价。
3. 这东西更好的一点是，如果采用POS，实际上连挖矿奖励都不需要，因为POS实际上不需要付出任何代价。

**概念：**

试图解决POW机制中大量资源被浪费的情况。这种机制通过计算你持有占总币数的百分比，包括你占有币数的时间来决定记账权。

**优点：**

不需要拼算力挖矿，不会浪费电力。缩短了共识达成的时间，效率提高。

**缺点：**

1. 拥有权益的参与者因为可以持币吃利息，所以卖币意愿不强烈，容易产生垄断。
2. 所有的确认都只是概率上的表达，存在其他攻击的可能性。挖矿成本低，硬分叉十分容易。

**使用该算法的项目(包含且不限于)：**

Ethereum、Peercoin、Nxt

### DPoS

> DPOS（Delegated Proof of Stake，授权权益证明）

**可理解为“公司董事会”。**

类型：协同型共识

2014年4月由Bitshares 的首席开发者 Dan Larimer（BM）提出。它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。

**优点：**

节能；快速；高流量博客网站 Steemit 就使用了它。EOS 的块时间是 0.5 秒。

**缺点：**

略为中心化；拥有高权益的参与者可投票使自己成为一名验证者（这是近期已在 EOS 中出现的问题）。

**使用该算法的项目(包含且不限于)：**

BitShares、Steemit、EOS、Lisk、Ark。

### PoA

> POA（Proof-of-Authority，权威证明）

**“投票指定一位被认可的账户作为矿工”**

类型：协同型共识

 基于 PoA 的网络、事务和区块，是由一些经认可的账户认证的，这些被认可的账户称为“验证者”（Validator）。验证者运行的软件，支持验证者将交易（transaction）置于区块中。该过程是自动的，无需验证者持续监控计算机，但需要维护计算机（权威节点）不妥协（uncompromised）。

使用 PoA，每个个体都具有变成验证者的权利，因此存在一旦获取就保持验证者位置的动机。通过对身份附加一个声誉，可以鼓励验证者去维护交易的过程。因为验证者并不希望让自己获得负面声誉，这会使其失去来之不易的验证者地位。

**优点：**

节能、快速。

**缺点：**

略为中心化；虽然可用于公有区块链，但是通常用于私有区块链和许可区块链。

**使用该算法的项目(包含且不限于)：**

POA.Network、Ethereum Kovan testnet、VeChain

### PBFT

> PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法）

类型：协同型共识

**描述：**

首先从“拜占庭将军问题”开始，拜占庭将军问题的实质就是要寻找一个方法，使得将军们在一个有版徒的非信任环境中建立对战斗计划的共识。

实用拜占庭容错（PBFT，Practical Byzantine Fault Tolerance）是首个提出的该问题解决方案，当前已被 Hyperledger Fabric 采用。PBFT 使用了较少（少于 20 个，之后会稍有增加）的预选定将军数，因此运行非常高效。它的优点是高交易通量和吞吐量，但是不足之处在于是中心化的，并用于许可网络。

拜占庭容错系统是指：在一个拥有n台节点的系统，整个系统，对每个请求满足如下条件： 所有非拜占庭节点使用相同的输入信息，产生同样的结果； 如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。

与此同时,在拜占庭系统的实际运行过程中一般假设系统中拜占庭节点不超过m台，并且对每个请求满足2个指标：

安全性——任何已经完成的请求都不会被更改，它可以在以后请求看到；

活性——可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。

**优点：**

高速、可扩展。

**缺点：**

通常用于私有网络和许可网络。

**使用该算法的项目(包含且不限于)：**

Hyperledger Fabric、Stellar、Ripple、Dispatch

### DBFT

> DBFT (Delegated Byzantine Fault Tolerance, 授权拜占庭容错算法）

类型：协同型共识

**描述：**

同样是为了解决拜占庭将军问题，「授权拜占庭容错」机制，是一种在NEO区块链内部实现的保证容错的共识算法。

在这个机制当中，存在两个参与者，一个是专业记账的“记账节点”，一个是系统当中的普通用户。

普通用户基于持有权益的比例来投票决定记账节点，当需要通过一项共识时，在这些记账节点中随机推选出一名发言人拟定方案，然后由其他记账节点根据拜占庭容错算法，即少数服从多数的原则进行表态，如果超过66%的节点表示同意发言人方案，则共识达成；否则，重新推选发言人，重复投票过程。

**优点：**

快速；可扩展。

**缺点：**

每个人都争相成为根链。其中可能存在多个根链。

**使用该算法的项目：**

Neo

## EOS

EOS，可以理解为Enterprise Operation System，即为商用分布式应用设计的一款区块链操作系统。EOS是引入的一种新的区块链架构，旨在实现分布式应用的性能扩展。注意，它并不是像比特币和以太坊那样的货币，而是基于EOS软件项目之上发布的代币，被称为区块链3.0。以太坊希望对世界计算领域进行去中心化，EOS的目标是快速运行去中心化的应用程序。两个协议使用不同的协商一致算法和不同的治理模型来实现这些目标。以太坊在其核心部分非常注重去中心化，而EOS则通过消除其一些去中心化特性来提高速度。

EOS是一种区块链体系结构，旨在通过开发可构建应用程序的操作系统来促进去中心化应用程序的纵向和横向扩展。该协议提供身份验证、帐户、异步通信、数据库，能够将应用程序调度到多个CPU内核。

它所产生的技术是一种区块链体系结构，它不需要使用费，在受治理的区块链的上下文中，它提供了快速和直观的去中心化应用程序的构成方式和维护方式。EOS作为一个底层的区块链和一个智能合约平台。该协议的工作方式类似于一个去中心化的操作系统，并允许通过去中心化的自治公司模型部署工业规模的应用程序。它的智能合约平台声称无需缴纳事务费，并且每秒管理数百万事务。

EOS的协商一致算法基于“委托的利害关系证明”，即那些在平台上拥有令牌的人可以通过一个扩展的批准投票系统来选择块生产者。

任何人都可以选择参加区块生产，并被允许生产区块，只要他们能够说服令牌持有人投票给他们。EOS协商一致算法尊重“拜占庭式的容错”方式，允许生产者签署所有块，只要没有生产者批准两个具有相同时间戳或相同块高度的块。一旦15个生产商签署了一个区块，这个区块就被认为是不可逆转的。

## 代币（Token）

代币是一种经过加密的数字货币。如：比特币、以太币

Token只是代币的英文，也称为通证，一般是指基于区块链技术发行的数字货币

## ICO

ICO（Initial Coin Offering），首次币发行，源自股票市场的首次公开发行（IPO）概念，是区块链项目首次发行代币，如募集比特币、以太坊等通用数字货币的行为。 

## IBC

IBC是链间通信协议（Inter-Blockchain Communication Protocol）。通过数据包的交换在多个不同的区块链网络之间转移数据和状态信息。最初的用途更多是通过IBC协议实现跨链通证转移。

IBC的目标是在两个独立的七层网络之间传递应用信息，所以需要链外的relay把数据包在链A和链B的网络之间做中继。链B收到链A的数据后必须能独立验证它所包含的证明信息，该证明代表了链A上的某个状态（及其对应操作）的真实性。为了让IBC协议能够工作，必须依赖基础的信任机制，要相信链A和链B里各自的共识算法，也要相信轻客户端验证，通过对区块头信息的验证，证明在区块链上曾经发生过的事情。

## ERC20

ERC20（Ethereum Request for Comments 20）是一种代币设计标准，是目前的行业标准，它基于以太坊存在。以相同的规则构建代币有利于后期发展，才会有更多的第三方应用对你发行的代币进行支持。

在编写了一份标准的ERC20智能合约之后，第三方机构就会用事先编写好的自定义代码与你的代币合约建立通信，这样人们就可以开始交易你的代币或把它存入钱包了。

## txindex

txindex：全称Transaction index 。

比特币核心默认建立包含仅与用户钱包相关交易的数据库。若你想使用类似gettransaction的命令访问所有交易，你需要配置比特币核心去建立一个完整的交易索引，这个可以通过txindex选项实现。在比特币核心配置文件中将txindex赋值为1（通常在安装目录的.bitcoin/bitcoin.conf中可以找到）， 或者使用命令行参数 txindex=1。一旦你改变了此参数，你需要重启bitcoind，并等待其重建索引。这个参数txindex的值会写入pblocktree数据库中，data/blocks/index目录下，

# 区块链

1. 狭义区块链：

   区块链是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构，并以密码学方式保证的不可篡改和不可伪造的**分布式账本。**

2. 广义区块链：

   区块链技术是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的**一种全新的分布式基础架构与计算范式。**

3. 比特币 VS 以太坊：

   Bitcoin是伟大创举，Ethereum是天才设计，前者是从0到1跨时代的发明，后者带来了智能合约，深刻影响着传统经济观念。

4. 以太坊 VS EOS：

   以太坊虽然速度较慢，但安全性更高，EOS更快，但也更集中。EOS是为了更快地中继事务而开发的,以太坊是为安全性和去中心化性而构建的。

   > 中继（Relay）是两个交换中心之间的一条传输通路

5. 回溯：

   区块链使用了parent Hash（父区块的hash值）连接前一个区块，通过这个字段，所有的区块最终都能回溯到创世块。

6. 创世块：

   区块链由多个相连的区块构成，每个区块记录了一段时间内网络中数字货币的交易情况，可以将区块视为账簿中的帐页。第一个被最早构建的区块称为创世块，拥有一个唯一的ID标识号。除创世块外，每个后续建立的区块均包含两个ID号，一个是该区块自身的ID号，另一个是前序区块的ID号。通过ID号间的前后指向关系，所有区块按序相连就构成了区块链。

7. 以太坊的智能合约 VS BTC脚本：

   BTC的脚本执行过程可以看作一个原子操作，不存在中间状态。而以太坊的智能合约实际上是一个允许多人修改的状态机，每个区块包含对状态机进行修改的交易，所以智能合约有大量中间状态。交易保存在底层的levelDB中即区块中；而中间状态是一个巨大的state tie，保存在stateDB中。 

8. 什么是IBC：

   IBC是链间通信协议的缩写（Inter-Blockchain Communication Protocol）。通过数据包交换在多个不同的区块链网络之间转移数据和状态信息。IBC的目标是在两个独立的七层网络之间传递应用信息，所以需要链外的relay把数据包在链A和链B的网络之间做中继。为了让IBC协议能够工作，必须依赖基础的信任机制，要相信链A和链B里各自的共识算法，也要相信轻客户端验证，通过对区块头信息的验证，证明在区块链上曾经发生过的事情。

9. 区块链协议：

   协议是管理网络的一组规则。区块链协议通常包括共识、交易验证和网络参与的规则。

10. 区块链五大特征：

   ①去中心化

   ②可追溯性

   ③防篡改性：要改变区块链里面的信息，必须要51%的节点都改变，这难度非常大

   ④开放性：这是针对区块链共有链来讲的

   ⑤匿名性：它的算法实现以地址来寻址，而不是以个人身份

11. 比特币总量VS以太币总量：

   ①BTC：总量2100万。10分钟出一个块，

   每挖出21万个块奖励发生一次减半，大约是每四年减半一次。

   ```css
   50 *21万(1 + 1/2 + (1/2)^2 + ……) ≈ 2100万
   ```

   > 2009年1月3日，中本聪挖出--创世区块，比特币网络诞生，奖励50。
   > 第一次减半：2012年11月28日，奖励25
   > 第二次减半：2016年7月10日，奖励12.5
   > 第二次减半：2020年5月12日，奖励6.25

   ②ETH：总量无上限。15s出一个块。

   奖励：普通块5eth+数块引用

   ```css
   以太币的总量存在形式：
   
   Pre-mine（矿前）+Block rewards（区块奖励）+Uncle rewards（叔块奖励）+Uncle referencing rewards（叔块引用奖励）
   ```

   > **矿前：**2014年7月/8月间，以太坊为众筹大约发行了7200万以太币。这些币有的时候被称之为“矿前”。众筹阶段之后，以太币每年的产量被限制在7200万以太币的25%（每年以太币的矿产量，不高于1800万）
   >
   > **区块奖励：**目前，每产生一个新区块就会产生5个新以太币。
   >
   > **叔块奖励：**每个叔块会为挖矿者产出大约4.375个以太币（5个以太币奖励的7/8）。
   >
   > **叔块引用奖励：**矿工每引用一个叔块，就得到了大约0.15个以太币（5个以太币奖励的1/32，最多引用两个叔块）

12. 关于挖矿：区块链中固定时间出一个块，无交易时便是空块。

# 以太坊

1. 以太坊升级路线：

	> https://eips.ethereum.org/

  | 区块高度  | 升级代号（English） | 升级代号（中文） | 北京时间       | 阶段(Egnlish) | 阶段（中文） |
  | --------- | ------------------- | ---------------- | -------------- | ------------- | ------------ |
  | -         | Olympic             | 奥林匹克         | 2015/5/9       | Frontier      | 前沿         |
  | 1         | Frontier            | 前沿             | 2015/7/30      |               |              |
  | 200,000   | Frontier Thrawing   | 前沿解冻         | 2015/9/7       |               |              |
  | 1,150,000 | HomeStead           | 家园             | 2016/3/14      | HomeStead     | 家园         |
  | 1,920,000 | DAO Fork            | DAO分叉          | 2016/7/20      |               |              |
  | 2,463,000 | Tangerine Whistle   | 橘子口哨         | 2016/10/18     |               |              |
  | 2,675,000 | Spurious Dragon     | 伪龙             | 2016/11/22     |               |              |
  | 4,370,000 | Byzantium           | 拜占庭           | 2017/10/16     | Metropolis    | 大都会       |
  | 7,280,000 | Constantinople      | 君士坦丁堡       | 2019/2/28      |               |              |
  | 9,069,000 | Istanbul            | 伊斯坦布尔       | 2019/12/8      | Serenity      | 宁静         |
  | 9,200,000 | Muir Glacier        | 谬尔冰川         | 2019/12/31     |               |              |
  | 待更新    | Berlin              | 柏林             | 2020/8月或更迟 |               |              |
  | 待更新    | London              | 伦敦             |                |               |              |
  | 待更新    | Shanghai            | 上海             |                |               |              |

2. RPC实现方式：

   以太坊rpc有4种实现方式分别是**inproc**，**ipc**，**http**，**ws**

   > inproc：是进程内部调用，为console使用；
   >
   > http：是以http接口方式提供访问；
   >
   > ws：是以websocket的方式提供访问。
   >
   > **ipc**：便是进程间通信，以npipe为底层实现，上层采用Json-Rpc为消息格式，并使用go的reflect包实现对内部Api的调用。 ipc通信是用于同一个主机间钱包等客户端与geth之间的通信。

3. 区块高度：区块编号（既区块的坐标）

   > 首先，“区块”是什么？
   >
   > 把区块链想象成一本记账的笔记本的话，“区块”就是笔记本上的一页页纸，纸上面的内容就是记账的内容（A什么时间转了多少钱给B，B什么时间转了多少钱给C...）。
   >
   > 那么，区块的编号其实就是“区块高度”。还是用账本举例，比如在一本100页的账本中，我想查看其中第50页的账目内容，那么这页的“区块高度”就是50。
   >
   > 所以“区块高度”相当于区块链上的经纬度，它给区块一个“坐标”，通过区块高度，准确地描述出某一区块在链上的位置。

# Solidity

1. 在 Solidity 写的智能合约中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。

2. Getter函数：编译器自动为所有public状态变量创建getter函数。

   下面给出的合约,编译器会生成一个名为data的函数,该函数不会接收任何参数并返回一个uint ,即状态变量data的值。可以在声明时完成状态变量的初始化。

   ```cpp
   contract C {
       uint public data = 42;
   }
   contract Caller { 
       C c = new C();
       function f() public { 
           uint local = c.data();
       }
   }
   ```

   getter函数具有外部可见性。如果在内部访问getter (即设有this. )它被认为一个状态变量。如果它是外部访问的(即用this.),它被认为是一个函数。

   ```cpp
   contract C{
       intbtic data;
       function x() public{
           data = 3; //内部访
           uint val = this.data(); //外部访问
       }
   }
   
   ```

3. 事件的作用：

   事件是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应，调用合约和区块链进行通讯。

   在函数中定义触发事件函数才可执行。

# Remix

1. VALUE

   <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghruenvssbj308b05vt99.jpg" alt="6ADA100E-119A-4FFD-A5D2-3412070FA4C2" style="zoom: 67%;" align="left"/>当函数有payable时，除了定义的参数外，还需在value框中输值，如果没有在value框中输入值，`就会被如代码中的if (msg.value == 0) throw;(此句相当于使用require检查)判断出错，`交易失败。







2. IPFS

   ​		IPFS一般指星际文件系统。星际文件系统是一个旨在创建持久且分布式存储和共享文件的网络传输协议。它是一种内容可寻址的对等超媒体分发协议。在IPFS网络中的节点将构成一个分布式文件系统。本质是一种类似HTTP的网络传输协议。

3. IPFS对区块链的作用

   ​		区块链的诞生本是为了做到去中心化，在没有中心机构的情况下达成共识，共同维护一个账本。它的设计动机并不是为了高效、低能耗，亦或是拥有可扩展性（如果追求高效、低能耗和扩展性，中心化程序可能是更好的选择）。IPFS与区块链协同工作，能够补充区块链的两大缺陷：

   ​		① 区块链存储效率低，成本高 

   ​		② 跨链需要各个链之间协同配合，难以协调

   ​		针对第1个问题，区块链网络要求全部的矿工维护同一个账本，需要每一个矿工留有一个账本的备份在本地。那么在区块链中存放的信息，为了保证其不可篡改，也需要在各个矿工手中留有一份备份，这样是非常不经济的。设想，现在全网有1万个矿工，即便我们希望在网络保存1MB信息，全网消耗的存储资源将是10GB。目前，也有折中的方案来缓解这一问题。在搭建去中心化应用DAPP时，大家广泛采取的方式是，仅在区块链中存放哈希值，将需要存储的信息存放在中心化数据库中。而这样，存储又成为去中心化应用中的一个短板，是网络中脆弱的一环。IPFS则提出了另一个解决方法：可以使用 IPFS存储文件数据，并将唯一永久可用的IPFS地址放置到区块链事务中，而不必将数据本身放在区块链中。

   ​		针对第2个问题，IPFS能协助各个不同的区块链网络传递信息和文件。比特币和以太坊区块结构不同，通过IPLD可以定义不同的分布式数据结构，这一功能目前还在开发中（2020.05）。

   ​		目前的IPLD（ IPLD是内容可寻址web的数据模型）组件，已经实现了将以太坊智能合约代码通过IPFS存储，在以太坊交易中只需存储这个链接。

3. Filecoin 

   ​		Filecoin 是基于IPFS技术的区块链项目。Filecoin是IPFS的激励层，IPFS网络要想稳定运行需要用户贡他们的存储空间、网络带宽，如果没有恰当的奖励机制，那么巨大的资源开销很难维持网络持久运转。受到比特币网络的启发，将Filecoin作为IPFS的激励层就是一种解决方案了，既**FIL币**。

   ​		矿工通过共享硬盘的方式获得相应奖励，由于挖矿性质的不同，它并不只依赖“算力”，而主要是是看存储能力和上下行带宽这两个因素。

4. CALLDATA

   **简介：**

   > ​		CALLDATA 就是合约交易里数据部分的值，就是下图里面标红的部分，包括要调用的合约函数和要传递的参数两部分内容。
   > ![image.png](https://tva1.sinaimg.cn/large/007S8ZIlly1ghrvnj9144j30a204vaa6.jpg)
   >
   > ​		在 Remix 里发起一笔合约交易后，展开交易内容，如下图一样看到的 input 值就是 CALLDATA。
   > ![image.png](https://tva1.sinaimg.cn/large/007S8ZIlly1ghrvovcavaj30fs037jr9.jpg)
   >
   > ​		将input 值复制出来：
   >
   > ```
   > 0x60fe47b10000000000000000000000000000000000000000000000000000000000000064
   > ```
   >
   > ​		这是 36 个字节长的一个 16 进制数，其中前 4 个字节 “0x60fe47b1” 是要调用的合约函数签名标识，后 32 个字节是这个合约函数要传入的参数。这个函数签名代表哪个函数，可以在 Remix 的 “Compilation Details” 里看到。如下图所示：
   > ![image.png](https://tva1.sinaimg.cn/large/007S8ZIlly1ghrvr3mpqwj306u040t8x.jpg)
   >
   > ​		“0x60fe47b1” 怎么来的呢，就是进行 keccak256("set(uint256)") 运算之后取结果的头 4 个字节。

   **为什么这里叫 low level interaction ？**

   > ​		它实际上提供了另外一种调用合约的方式，除了 Remix 生成的合约交互界面上的合约函数调用按钮，我们现在可以直接把合约调用的底层数据传过来取调用合约了。我可以把下面这串内容填入 CALLDATA 输入框，点击右边的 Transact 按钮，就发起了一笔对 set(uint256) 这个合约函数的调用，可以看到对应的交易执行状态。

   **这有什么用？**

   > 		1. 正常的函数调用
   >   		2. 测试 fallback（回退） 函数。当我们调用合约中不存在的一个函数时，如果合约中定义有 fallback 函数，这个 fallback 函数就会被执行。既在 CALLDATA 输入框里输入任意一个 16 进制数据，就可以触发fallback 函数执行。

5. 哈希算法

   ```js
   contract Hash{
       //① keccak256
       function hash1(string x,string y) public view returns(bytes32){
           return keccak256(x,y);
       }
       //② sha256
       function hash2(string x,string y) public view returns(bytes32){
           return sha256(x,y);
       }
   }
   ```

   