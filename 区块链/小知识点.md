# 名词解释

## ABI

ABI全称 Application Binary Interface，字面意思是应用程序二进制接口，可以通俗的理解为合约的接口说明，当合约被编译后，它对应的abi也就确定了。

abi有点类似于程序中的接口文档，描述了字段名称、字段类型、方法名称、参数名称、参数类型、方法返回值类型等

### 为什么需要ABI

我们编写智能合约的流程是：

- 编写合约代码（一般使用solidity语言）
- 编译合约，将solidity编写的代码编译成EVM可识别的bytecode，这一步生成abi
- 部署合约，将合约部署到区块链上，生成合约地址，将合约内容（即上一步生成的bytecode）作为input date输入。部署合约是一个交易过程，所以也会生成一个交易Hash
- 执行合约，获取合约地址，然后传入参数调用合约中的方法，获得执行结果

从上面的步骤可以看出，abi对于EVM来说，其实是不需要的。但是对于调用者来说，就需要知道合约有哪些方法，方法的参数是什么，返回值是什么，而这些信息就记录在智能合约的abi中。所以abi其实就相当于开发者的接口文档，方便开发者调用执行合约

### ABI有哪些内容

编写一个最简单的合约，然后编译生成abi看下内容

```c#
pragma solidity ^0.4.24;

contract Demo {
    uint private x;
    function set(uint _x) public {
        x = _x;
    }
}
```

执行 `truffle compile` 编译合约，就会生成对应的文件`Demo.json`，内容如下。由于json太长，删除了一些不重要的内容，完整内容可以自己手动执行看看。

```json
{
    "contractName": "Demo",
    "abi": [
        {
            "constant": false,
            "inputs": [
                {
                    "name": "_x",
                    "type": "uint256"
                }
            ],
            "name": "set",
            "outputs": [],
            "payable": false,
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ],
    "bytecode": "0x6080604052348015600f57600080fd5b5060a48061001e6000396000f300608060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b1146044575b600080fd5b348015604f57600080fd5b50606c60048036038101908080359060200190929190505050606e565b005b80600081905550505600a165627a7a723058201dfe7c019fec67ccd87250c9ac8642c163cc5f43588715b33e8a8953df3715f60029",
    "deployedBytecode": "0x608060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b1146044575b600080fd5b348015604f57600080fd5b50606c60048036038101908080359060200190929190505050606e565b005b80600081905550505600a165627a7a723058201dfe7c019fec67ccd87250c9ac8642c163cc5f43588715b33e8a8953df3715f60029",
    "sourceMap": "27:97:1:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;27:97:1;;;;;;;",
    "deployedSourceMap": "27:97:1:-;;;;;;;;;;;;;;;;;;;;;;;;69:52;;8:9:-1;5:2;;;30:1;27;20:12;5:2;69:52:1;;;;;;;;;;;;;;;;;;;;;;;;;;;112:2;108:1;:6;;;;69:52;:::o",
    "source": "pragma solidity ^0.4.24;\n\n\ncontract Demo {\n\n    uint private x;\n\n    function set(uint _x) public {\n        x = _x;\n    }\n\n}\n",
    "sourcePath": "/Users/root/Workspace/DApp/demo/contracts/Demo.sol",
    "ast": {
        ...
    },
        "legacyAST": {
            ...
        },
            "compiler": {
                "name": "solc",
                "version": "0.4.24+commit.e67f0147.Emscripten.clang"
            },
            "networks": {},
            "schemaVersion": "2.0.1",
            "updatedAt": "2018-09-14T11:57:49.750Z"
        }
    }
}
```

大部分参数通过名称就可以看出来含义，这里我们主要介绍abi中各参数的含义和调用函数时生成ABI编码的过程

### abi各参数的含义

- `name`：函数名称
- `type`：方法类型，包括`function`, `constructor`, `fallback`(缺省方法)可以缺省，默认为`function`
- `constant`：布尔值，如果为true指明方法不会修改合约字段的状态变量
- `payable`：布尔值，标明方法是否可以接收ether
- `stateMutability`：状态类型，包括`pure` (不读取区块链状态)，`view` (和constant类型，只能查看，不会修改合约字段)，`nonpayable`（和payable含义一样），`payable`（和payable含义一样）。其实保留`payable`和`constant`是为了向后兼容
- `inputs`：数组，描述参数的名称和类型
  - `name`：参数名称
  - `type`：参数类型
- `outputs`：和`inputs`一样，如果没有返回值，缺省是一个空数组

这里要说明一点的是，由于示例中的`x`字段类型为`private`，所以没有生成一个和参数名称一样的函数，如果`x`字段类型为`public`，生成的abi就如下，会多一个和参数名称一样的函数(将状态变量声明为public将自动为其创建getter方法)

```bash
"abi": [
    {
      "constant": true,
      "inputs": [],
      "name": "x",
      "outputs": [
        {
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "name": "_x",
          "type": "uint256"
        }
      ],
      "name": "set",
      "outputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    }
```

## 公钥加密系统

 Alice有一把公钥和一把私钥。她可以用她的私钥创建数字签名，而Bob可以用她的公钥来验证这个签名确实是用Alice的私钥创建的，也就是说，确实是Alice的签名。当你创建一个以太坊或者比特币钱包的时候，那长长的`0xdf...5f`地址实质上是个公钥，对应的私钥保存某处。类似于Coinbase的在线钱包可以帮你保管私钥，你也可以自己保管。如果你弄丢了存有资金的钱包的私钥，你就等于永远失去了那笔资金，因此你最好对私钥做好备份。

## 点对点网络

就像BitTorrent, 以太坊分布式网络中的所有节点都地位平等，没有中心服务器。(未来会有半中心化的混合型服务出现为用户和开发者提供方便。)

## EVM

以太坊虚拟机 ，它让你能在以太坊上写出更强大的程序（比特币上也可以写脚本程序）。它有时也用来指以太坊区块链，负责执行智能合约以及一切。

## 节点

你可以运行节点，通过它读写以太坊区块链，也即使用以太坊虚拟机。完全节点需要下载整个区块链。轻节点仍在开发中。

## 矿工

挖矿，也就是处理区块链上的区块的节点。

## 工作量证明

矿工们总是在竞争解决一些数学问题。第一个解出答案的(算出下一个区块)将获得以太币作为奖励。然后所有节点都更新自己的区块链。所有想要算出下一个区块的矿工都有与其他节点保持同步，并且维护同一个区块链的动力，因此整个网络总是能达成共识。

## 以太币

缩写ETH。一种你可以购买和使用的真正的数字货币

## Gas

在以太坊上执行程序以及保存数据都要消耗一定量的以太币，Gas是以太币转换而成。这个机制用来保证效率。

## DApp

以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。DApp的目标是(或者应该是)让你的智能合约有一个友好的界面，外加一些额外的东西，例如IPFS（可以存储和读取数据的去中心化网络，不是出自以太坊团队但有类似的精神)。DApp可以跑在一台能与以太坊节点交互的中心化服务器上，也可以跑在任意一个以太坊平等节点上。(花一分钟思考一下：与一般的网站不同，DApp不能跑在普通的服务器上。他们需要提交交易到区块链并且从区块链而不是中心化数据库读取重要数据。相对于典型的用户登录系统，用户有可能被表示成一个钱包地址而其它用户数据保存在本地。许多事情都会与目前的web应用有不同架构。

## 客户端

以太坊有许多不同语言的客户端实现（即多种与以太坊网络交互的方法），包括C++, Go, Python, Java, Haskell等等。为什么需要这么多实现？不同的实现能满足不同的需求（例如Haskell实现的目标是可以被数学验证），能使以太坊更加安全，能丰富整个生态系统。

交互式控制台。 客户端运行起来后，你就可以同步区块链，建立钱包，收发以太币了。使用geth的一种方式是通过[Javascript控制台](https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console)（JavaScript console, 类似你在chrome浏览器里面按F12出来的那个，只不过是跑在终端里）。此外还可以使用类似curl的命令通过[JSON RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC)来与客户端交互。本文的目标是带大家过一边DApp开发的流程，因此这块就不多说了。但是我们应该记住这些命令行工具是调试，配置节点，以及使用钱包的利器。

在测试网络运行节点。 如果你在正式网络运行geth客户端，下载整个区块链与网络同步会需要相当时间。（你可以通过比较节点日志中打印的最后一个块号和以太坊网址上列出的最新块来确定是否已经同步。) 另一个问题是在正式网络上跑智能合约需要实实在在的以太币。在测试网络上运行节点的话就没有这个问题。此时也不需要同步整个区块链，创建一个自己的私有链就好了了，对于开发来说更省时间。

## truffle

truffle是本地的用来编译、部署智能合约的工具

## testrpc

testrpc不同于geth，geth是真正的以太坊环境，testrpc是在本地使用内存模拟的一个以太坊环境，对于开发调试来说，更为方便快捷，当你的合约在testrpc中测试通过后，再可以部署到geth中去

testrpc 现在已经并入到Truffle 开发框架中，现在名字是ganache-cli

注意：它仅运行在內存中，因此每次重开时都会回到全新的状态

### ganache

ganache相当于是testrpc的升级版，有图形界面

注意：它仅运行在內存中，因此每次重开时都会回到全新的状态

## 智能合约

> 将合约条款代码化
>
> 以太坊上的程序,是代码和数据(状态)的集合
>
> 典型应用：代币: EOS ，游戏：迷恋猫

你愿意和从未谋面的人签合约吗？你会同意把钱借给埃塞俄比亚的农民吗？你愿意投资一个战乱地区由少数人管理的报纸吗？你会不嫌麻烦为了网上一次5美元的购买签一个有法律效力的合约吗？

大多数的答案都是否定的，原因是合约需要的基础太多了：有时需要双方之间互相信任的工作关系，有时要依靠合法的工作体系、警察和律师费用。

在以太坊这些都不需要：**如果合约所必需的要求都能放在区块链中，那么就会放在区块链中，这是一个无需信任基础也几乎不用任何成本的环境**。

 不要想将你现有的合约转移到区块链中会麻烦，想一想那些因为经济上不可行或是没有足够法律保护而被你拒绝的成千上万的小合约吧。

## DAO

> Decentralized Autonomous Organization，简称DAO，一般翻译为去中心化的自治组织。

这里简单地举个例子：想象一下你和朋友有个小生意。律师和会计很贵，完全信任让一个单独的合伙人来看管账簿可能让你精神很紧张（这甚至可能是个诈骗的机会）。你可以尝试一下多个合伙人共同看管账簿，但只要协议没有被严格遵守，就可能导致诈骗发生。

使用智能合约，公司的所有权和基金分配的条款可以在一开始就详细规定。智能合约签署的方式是，只有大部分拥有者批准，合约才可以变更。 这样的智能合约可以像开源软件一样获取，你甚至都不必雇佣自己的程序员来代替会计和律师。

这样的智能合约可以立即按比例决定分配。几个年轻人分配柠檬水站收入，可以像主权基金给拥有基金的亿万公民分配收益一样透明。在这两个案例中，这种透明性带来的花费可能每美元连一美分都不到。

## DAG

**DAG**是有向无环图。它用于所有Ethash算数的数字货币，如ETH-以太坊，ETC-以太经典，MUSIC-乐币，ETP-元界，DBIX-迪拜币，CLO，EXP，UBQ等其它数字货币，以提供工作量证明。DAG文件在每个挖矿纪元（epoch）都会生成一个DAG，并且会不断增加。了解DAG文件的当前和未来的大小非常重要，因为它对挖矿速度会产生很大影响。DAG文件直接位于GPU显存中。如果DAG文件比GPU显存大，那么你的显卡就不能再进行挖矿。要分析未来的dag大小，您可以查看下表。

**DAG**文件每个纪元（epoch）都会改变。一个纪元（epoch）是30000个区块。DAG文件的增加速度直接取决于出块时间。但出块时间不稳定，以太坊可能会从10秒到60秒不等。因此，每个纪元（epoch）都没有固定产生时间，它是以块为单位决定的。一般来说，以太坊的DAG文件每年增加0.72倍。但这还是得看出块时间。对于出块时间较慢的其他数字货币，DAG文件增加较慢，GPU可以挖矿很长时间。

bitcoin之所以效率低是因为它的POW机制. 整个网络只有一个主链, 其上的新块只能有一个, 无法同时创建多个新块. 10分钟左右以内的所有交易记录都被记录到一个块中. Ethereum也是类似, 大概15-20秒产生一个新块。有了DAG, 就可以同一时间创建多个块。

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghp7pezlc8j30om0ctwhn.jpg" alt="0F68C9A2-B75A-4C7B-870B-7844452483B5" style="zoom:50%;" />

对于每一个块，首先计算一个种子(seed)，该种子只和当前块的信息有关;然后根据种子生成一个32M的随机数据集（cache）

根据Cache生成一个1GB大小的数据集合DAG(有向非循环图)，它是一个完整的搜索空间，挖矿的过程就是从DAG中随机选择元素(类似于比特币挖矿中查找合适Nonce)再进行哈希运算，可以从Cache快速计算DAG指定位置的元素，进而哈希验证。要求对Cache和DAG进行周期性更新，每1000个块更新一次，并且规定DAG的大小随着时间推移线性增长，从1G开始，每年大约增长7G左右。

# 区块链

1. 狭义区块链：

   区块链是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构，并以密码学方式保证的不可篡改和不可伪造的**分布式账本。**

2. 广义区块链：

   区块链技术是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的**一种全新的分布式基础架构与计算范式。**

3. 比特币 VS 以太坊

   Bitcoin是伟大创举，Ethereum是天才设计，前者是从0到1跨时代的发明，后者带来了智能合约，深刻影响着传统经济观念。

4. 回溯：

   区块链使用了parent Hash（父区块的hash值）连接前一个区块，通过这个字段，所有的区块最终都能回溯到创世块。

5. 创世块：

   区块链由多个相连的区块构成，每个区块记录了一段时间内网络中数字货币的交易情况，可以将区块视为账簿中的帐页。第一个被最早构建的区块称为创世块，拥有一个唯一的ID标识号。除创世块外，每个后续建立的区块均包含两个ID号，一个是该区块自身的ID号，另一个是前序区块的ID号。通过ID号间的前后指向关系，所有区块按序相连就构成了区块链。

6. 以太坊的智能合约 VS BTC脚本：

   BTC的脚本执行过程可以看作一个原子操作，不存在中间状态。而以太坊的智能合约实际上是一个允许多人修改的状态机，每个区块包含对状态机进行修改的交易，所以智能合约有大量中间状态。交易保存在底层的levelDB中即区块中；而中间状态是一个巨大的state tie，保存在stateDB中。 

5. 什么是IBC：

   IBC是链间通信协议的缩写（Inter-Blockchain Communication Protocol）。通过数据包交换在多个不同的区块链网络之间转移数据和状态信息。IBC的目标是在两个独立的七层网络之间传递应用信息，所以需要链外的relay把数据包在链A和链B的网络之间做中继。为了让IBC协议能够工作，必须依赖基础的信任机制，要相信链A和链B里各自的共识算法，也要相信轻客户端验证，通过对区块头信息的验证，证明在区块链上曾经发生过的事情。

6. 区块链协议：

   协议是管理网络的一组规则。区块链协议通常包括共识、交易验证和网络参与的规则。

7. 区块链五大特征：

   ①去中心化

   ②可追溯性

   ③防篡改性：要改变区块链里面的信息，必须要51%的节点都改变，这难度非常大

   ④开放性：这是针对区块链共有链来讲的

   ⑤匿名性：它的算法实现以地址来寻址，而不是以个人身份

10. 比特币总量VS以太币总量

   ①BTC：总量2100万。10分钟出一个块，

   每挖出21万个块奖励发生一次减半，大约是每四年减半一次。

   ```css
   50 *21万(1 + 1/2 + (1/2)^2 + ……) ≈ 2100万
   ```

   > 2009年1月3日，中本聪挖出--创世区块，比特币网络诞生，奖励50。
   > 第一次减半：2012年11月28日，奖励25
   > 第二次减半：2016年7月10日，奖励12.5
   > 第二次减半：2020年5月12日，奖励6.25

   ②ETH：总量无上限。15s出一个块。

   奖励：普通块5eth+数块引用

   ```css
   以太币的总量存在形式：
   
   Pre-mine（矿前）+Block rewards（区块奖励）+Uncle rewards（叔块奖励）+Uncle referencing rewards（叔块引用奖励）
   ```

   > **矿前：**2014年7月/8月间，以太坊为众筹大约发行了7200万以太币。这些币有的时候被称之为“矿前”。众筹阶段之后，以太币每年的产量被限制在7200万以太币的25%（每年以太币的矿产量，不高于1800万）
   >
   > **区块奖励：**目前，每产生一个新区块就会产生5个新以太币。
   >
   > **叔块奖励：**每个叔块会为挖矿者产出大约4.375个以太币（5个以太币奖励的7/8）。
   >
   > **叔块引用奖励：**矿工每引用一个叔块，就得到了大约0.15个以太币（5个以太币奖励的1/32，最多引用两个叔块）

11. 关于挖矿：区块链中固定时间出一个块，无交易时便是空块。

# 以太坊

1. 以太坊升级路线：

	> https://eips.ethereum.org/

  | 区块高度  | 升级代号（English） | 升级代号（中文） | 北京时间       | 阶段(Egnlish) | 阶段（中文） |
  | --------- | ------------------- | ---------------- | -------------- | ------------- | ------------ |
  | -         | Olympic             | 奥林匹克         | 2015/5/9       | Frontier      | 前沿         |
  | 1         | Frontier            | 前沿             | 2015/7/30      |               |              |
  | 200,000   | Frontier Thrawing   | 前沿解冻         | 2015/9/7       |               |              |
  | 1,150,000 | HomeStead           | 家园             | 2016/3/14      | HomeStead     | 家园         |
  | 1,920,000 | DAO Fork            | DAO分叉          | 2016/7/20      |               |              |
  | 2,463,000 | Tangerine Whistle   | 橘子口哨         | 2016/10/18     |               |              |
  | 2,675,000 | Spurious Dragon     | 伪龙             | 2016/11/22     |               |              |
  | 4,370,000 | Byzantium           | 拜占庭           | 2017/10/16     | Metropolis    | 大都会       |
  | 7,280,000 | Constantinople      | 君士坦丁堡       | 2019/2/28      |               |              |
  | 9,069,000 | Istanbul            | 伊斯坦布尔       | 2019/12/8      | Serenity      | 宁静         |
  | 9,200,000 | Muir Glacier        | 谬尔冰川         | 2019/12/31     |               |              |
  | 待更新    | Berlin              | 柏林             | 2020/8月或更迟 |               |              |
  | 待更新    | London              | 伦敦             |                |               |              |
  | 待更新    | Shanghai            | 上海             |                |               |              |

2. RPC实现方式：

   以太坊rpc有4种实现方式分别是**inproc**，**ipc**，**http**，**ws**

   > inproc：是进程内部调用，为console使用；
   >
   > http：是以http接口方式提供访问；
   >
   > ws：是以websocket的方式提供访问。
   >
   > **ipc**：便是进程间通信，以npipe为底层实现，上层采用Json-Rpc为消息格式，并使用go的reflect包实现对内部Api的调用。 ipc通信是用于同一个主机间钱包等客户端与geth之间的通信。

3. 区块高度：区块编号（既区块的坐标）

   > 首先，“区块”是什么？
   >
   > 把区块链想象成一本记账的笔记本的话，“区块”就是笔记本上的一页页纸，纸上面的内容就是记账的内容（A什么时间转了多少钱给B，B什么时间转了多少钱给C...）。
   >
   > 那么，区块的编号其实就是“区块高度”。还是用账本举例，比如在一本100页的账本中，我想查看其中第50页的账目内容，那么这页的“区块高度”就是50。
   >
   > 所以“区块高度”相当于区块链上的经纬度，它给区块一个“坐标”，通过区块高度，准确地描述出某一区块在链上的位置。

# Solidity

1. 在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。
2. Getter函数：编译器自动为所有public状态变量创建getter函数。





# 临时记录

ERC-20---以太坊的代币编写标准

https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md

![AC2D18DA-0A15-445E-9918-D772AB0B3C37](https://tva1.sinaimg.cn/large/007S8ZIlly1ghhizofqlfj30g20200t5.jpg)

![21E745A4-188C-45D5-8F4B-ECCEC6732929](https://tva1.sinaimg.cn/large/007S8ZIlly1ghhizuwpxoj30nr03amy7.jpg)



![6B896FDE-1E05-4AAF-A257-9AB436E12E71](https://tva1.sinaimg.cn/large/007S8ZIlly1ghhj0n3ei8j30ko0anadr.jpg)

![4450A10E-90CD-4680-9224-5536632CCEA1](https://tva1.sinaimg.cn/large/007S8ZIlly1ghio88dnenj30lb07pdj7.jpg)

向大家请教问题,我在solidity中，当在设置了一个变量， 比如：mapping ( address => uint ) public _get; 时，即 加上public的，会自动通生成一个function _get() 的方法， 这个方法，在remix可以找到和调用，但我用 web3.js 无法调用，求解决，

Mapping、地址自动生成带参函数