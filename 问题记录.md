# Java

## 字符串

1.截取字符串

> substring() 方法返回字符串的子字符串。
>
>
> public String substring(int beginIndex)
>
> public String substring(int beginIndex, int endIndex)
>
> 参数：
>
> beginIndex -- 起始索引（包括）
>
> endIndex -- 结束索引（不包括）

```java
//获取文件名
String realName="F:/and/name.txt";
String extension = realName.substring(realName.lastIndexOf('/'),realName.indexOf("."));
String truename = extension.replace("/", "");
System.out.println(truename);// name
```

## 类型转换

1. String和Date相互转换

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String dateStr = sdf.format(new Date()));
        
Date date = null;
try {
    // 注意格式需要与上面一致，不然会出现异常
    date = sdf.parse("2005-12-15 15:30:23");
} catch (ParseException e) {
    e.printStackTrace();
}
System.out.println("字符串转换成时间:" + date);
}
```

## 参数

1.String[] args

> String[] args是main函数的形式参数,可以用来获取命令行用户输入进去的参数
>
> args是arguments的缩写默认名

```java
public class test {
  public static void main(String[] args) {
    for (int i = 0; i < args.length; i++) {
      System.out.println(args[i]);}}}
```

```js
➜  java测试 java test.java 测试1 测试2
测试1
测试2
```

## 随记

1. 类实现序列化

```java
//作用：给实体增加一个持久化的能力
public class User implements Serializable {}
```





# Servlet

1. **获取路径**

> 工程名为TEST为例：
>
> (1)得到包含工程名的当前页面全路径：request.getRequestURI()
> 结果：/TEST/test.jsp
>
> (2)得到工程名：request.getContextPath()
> 结果：/TEST
>
> (3)得到当前页面所在目录下全名称：request.getServletPath()
> 结果：如果页面在jsp目录下 /TEST/jsp/test.jsp
>
> (4)得到页面所在服务器的全路径：application.getRealPath("页面.jsp")
> 结果：D:\resin\webapps\TEST\test.jsp
>
> (5)得到页面所在服务器的绝对路径：absPath=new java.io.File(application.getRealPath(request.getRequestURI())).getParent();
> 结果：D:\resin\webapps\TEST





# 工具

## IDEA

1. maven工程修改为idea标准web工程

> Project Strugture --> facets--> 添加web模块 -->修改上下两部分路径为：
>
> src\main\webapp-->修改web.xml版本号-->Create Artifact-->ok

2. 依赖未发布：编辑Artifacts--> 全部选中Put into/WEB-INF/lib 手动发布

## Maven

1. 依赖的scope

   去除部署不需要的jar包

```xml
<dependency>

    < groupId>javax.servlet</groupId>

    < artifactId>jsp-api</artifactId>

    < version>2.0</version>

    < scope>provided</scope>

< /dependency>
```

> **compile** 默认的scope，表示 dependency 都可以在生命周期中使用。而且，这些dependencies 会传递到依赖的项目中。适用于所有阶段，会随着项目一起发布 
>
> **provided** 跟compile相似，但是表明了dependency 由JDK或者容器提供，例如Servlet AP和一些Java EE APIs。这个scope 只能作用在编译和测试时，同时没有传递性。     
>
> **runtime** 表示dependency不作用在编译时，但会作用在运行和测试时，如JDBC驱动，适用运行和测试阶段。 
>
> **test** 表示dependency作用在测试时，不作用在运行时。 只在测试时使用，用于编译和运行测试代码。不会随项目发布。 
>
> **system** 跟provided 相似，但是在系统中要以外部JAR包的形式提供，maven不会在repository查找它。

```css
你通过maven引入的jar包，里面的类，都是已经编译好的字节码，跟runtime或者provided没关系。

简单来说，compile、runtime和provided的区别，需要在执行mvn package命令，且打包格式是war之类（而不是默认的jar）的时候才能看出来。

通过compile和provided引入的jar包，里面的类，你在项目中可以直接import进来用，编译没问题，但是runtime引入的jar包中的类，项目代码里不能直接用，用了无法通过编译，只能通过反射之类的方式来用。

通过compile和runtime引入的jar包，会出现在你的项目war包里，而provided引入的jar包则不会。
```



# 杂记

##1.矢量图

> 矢量图，也称为面向对象的图像或绘图图像，只能靠软件生成，这种类型的图像文件包含独立的分离图像，可以自由无限制的重新组合，文件中的图形元素称为对象，每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。
>
> 矢量图，在数学上定义为一系列由线连接的点。矢量图形最大的优点，是它不受分辨率的影响。因此在印刷时，可以任意放大或缩小图形而不会影响出图的清晰度，可以按最高分辨率显示到输出设备上。适用于图形设计、文字设计和一些标志设计、版式设计等。但它也有一个最大的缺点，就是难以表现色彩层次丰富的逼真图像效果。

## 2.URL、URI、CURL

**URL：**L统一资源定位符（uniform resource locator）

**URI**：统一资源标识符（Uniform Resource Identifier)

**CURL**：是一个利用URL在命令行下工作的文件传输工具

> ```CSS
> CURL重要参数：
> -X/--request [GET|POST|PUT|DELETE|…]  使用指定的http method
> -H/--header                           设置request里的header信息，比如content-type
> -i/--include                          显示response的header
> -d/--data                             设置 http parameters 
> -v/--verbose                          输出详细信息
> -u/--user                             指定使用者账户，密码
> -b/--cookie                           cookie  
> 
> 示例：
> curl -X GET "http://localhost:8080/restful/xml" -H "accept: application/xml"
> ```

![v2-806538492da1f9bbb0af6afa13193eee_r](https://tva1.sinaimg.cn/large/007S8ZIlly1gfu72vhmxbj30vu0kmgqn.jpg)