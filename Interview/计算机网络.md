# OSI

计算机网络体系大致分为三种：OSI七层模型、TCP/IP四层模型、五层模型。

![img](https://tva1.sinaimg.cn/large/008i3skNly1gv179ah1asj60iq0agwfk02.jpg)

- 应用层：
  - 在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。
  - 原因：此时虽然发送方知道自己发送的是什么东西，转换成字节数组之后有多长，但接收方肯定不知道，应用层应运而生。
  - 作用：为应用程序提供交互服务；规定发送发和接收方使用一个固定长度的消息头，消息头里记录用于消息解析的一系列信息，以方便接收方能够正确解析。
    - 至于数据的传递没有该层也可以在两台电脑间开干，只不过穿来穿去就是一堆0和1组成的字节数组。
  - 本层数据为APDU(应用协议数据单元)；本层协议：DNS、HTTP、SMTP
- 表示层：
  - 负责数据格式的转换，如加密解密、压缩解压缩等。
  - 原因：linux给windows发包，两个系统语法不一致，像安装包exe不能在linux执行。表示层应运而生。
  - 作用：解决不同系统之间的通信语法的问题；在表示层数据将按照网络能够理解的方案进行格式化，这种格式化也因所使用的网络的类型不同而不同。
  - 本层数据为PPDU(表示协议数据单元)；
- 会话层：
  - 原因：这时，用户级别的体验仍不好。难道每次都要调用TCP去打包，再用IP协议去找路由？所以要建立一个自动收发包，自动寻址的功能，会话层应运而生。
  - 作用：建立和管理应用程序之间的通信；保证应用程序自动收发包和自动寻址。
  - 本层数据为PPDU(会话协议数据单元)；
- 运输层：
  - 负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。
  - 原因：随着网络通信需求的进一步扩大，通信过程中需要发送大量数据，如海量文件传输，可能需要很长时间，而网络在通信过程中会中断好多次，为保证传输大量文件时的准确性，需要对发送数据进行切分，切分为一个一个的段落，既segment进行发送，那么其中段落丢失该怎么办，要不要重传，每个段落要按照顺序到达吗；传输层应运而生。
  - 作用：解决主机间的数据传输问题；传输层根据网络能处理的数据最大尺寸，将较长的数据包进行强制分割，例如以太坊无法接受大于1500字节的数据包， 发送方节点的传输层将数据包分割为较小的数据片，同时对每一数据片设置一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。
  - 本层数据为段；传输层的协议主要有传输控制协议TCP和用户数据协议UDP
  - 这时已经可以保证给正确的计算机发送正确的信息。
- 网络层：
  - 原因：随着网络节点的不断增加，点对点通信时需要经过多个节点，如何找到目标节点，如何选择最佳路径，此时网络层应运而生。
  - 作用：将网络地址翻译成对应的物理地址 ，并决定如何将数据从发送方路由到接收方；网络层通过综合考虑：发送优先权、网络拥塞程度、以及可选路由的花费，来决定A->B的最佳路径。
  - 路由器工作在这一层。
  - 本层数据为包；本层主要包括IP协议。
- 数据链路层：
  - 原因：传输比特流过程中，会出现错传、数据不完整的可能，因此数据链路层应运而生。
  - 作用：定义了如何格式化数据以进行传输，以及如何控制数据对物理介质的访问；还提供错误监测和纠正，以确保数据传输的可靠性。
  - 交换机工作在这层
  - 本层数据为帧；将网络层传下来的IP数据包组装成帧。
- 物理层：
  - 解决物理机间的通讯需求：机器A向机器B发送比特流
  - 定义物理设备标准：网线类型、光纤接口类型、各种传输介质的传输速率等。
  - 主要作用：传输比特流，既0101二进制数据，将它们转化为电流强弱进行传输，到达目的地后再转换为0101的机器码，既数模转换和模数转换。
  - 网卡工作在物理层和数据链路层的MAC子层。
  - 本层数据为比特流。

# TCP/IP

OSI参考模型并不是一个标准，而是一个在制定标准时所使用的一个概念性的框架，事实的标准是TCP/IP四层架构参考模型 ；TCP/IP并不完全符合OSI模型。

![image-20210903214834647](https://tva1.sinaimg.cn/large/008i3skNly1gv23b3scy0j60yu0jmwgx02.jpg)

![image-20210903215651449](https://tva1.sinaimg.cn/large/008i3skNly1gv23ds4kc7j618w0jmjt802.jpg)

# TCP和UDP

## 报文头

### TCP

![img](https://tva1.sinaimg.cn/large/008i3skNly1gv251xo79uj60hs0780t302.jpg)

- 源端口和目的端口：
  - 各占 2 个字节。IP 地址 + 端口号就可以确定一个进程地址
- 序列号：
  - 在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。
  - 例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。
- 确认号 ack：
  - 期望收到对方下一个报文段的第一个字节的序号。
  - 若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。
- 数据偏移（首部长度）：
  - 它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。
- 保留：
  - 占 6 位，应置为 0，保留为今后使用。
- 控制位：TCP 用来说明该报文段的性质。
  - **紧急位 URG**：
    - 是否为紧急数据
    - 当 URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。
    - 该控制位需配合紧急指针使用。
  - **确认位 ACK**：
    - 确认号是否有效
    - 仅当 ACK = 1 时确认号才有效，当 ACK = 0 时确认号无效。
    - TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。
  - **推送位 PSH**：
    - 请求立即响应
    - 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。
    - 在这种情况下，发送方 TCP 把 PSH 置为 1。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付给接收应用进程。而不用等到整个缓存都填满了后再向上交付。
  - **重置位 RST**：
    - 重置连接
    - 当 RST = 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。
  - **同步位 SYN**：
    - 建立连接
    - SYN = 1 表示这是一个连接请求或连接接受报文。
    - 当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文。
    - 当 SYN = 1 而 ACK = 1 时，表明这是一个连接接收报文。
  - **终止位 FIN**：
    - 释放连接
    - 用来释放一个连接。当 FIN = 1时，表明此报文段的发送的数据已发送完毕，并要求释放连接。
- 窗口：
  - 标识滑动窗口大小。
  - 用于接收方通知发送方自己还有多少缓冲区可以接收数据。
- 检验和：
  - 检查数据在传输过程中是否被损坏
  - 由发送端计算，然后由接收端验证。
  - 其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。
- 紧急指针：
  - 指出本报文段中紧急数据的字节数。
- 可选项：
  - 长度可变，定义一些其他的可选参数。

### UDP

![image-20211003155112689](https://tva1.sinaimg.cn/large/008i3skNly1gv269xepewj60rg0bi3z602.jpg)

- 长度：
  - 表示 UDP 数据报长度
  - 包含 UDP 报文头和 UDP 数据长度。
- 校验和：
  - 检查数据在传输过程中是否被损坏
  - 由发送端计算，然后由接收端验证。
  - 其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。

## 滑动窗口

TCP最基本的传输可靠性，来源于确认重传机制，TCP滑动窗口的可靠性也来源于确认重传机制。

> - RTT :发送一个数据包到收到对应的ACK ,所花费的时间
>
> - RTO :重传时间间隔；（RTO不是固定写死的是RTT通过算法计算出来的）

原因：

- TCP会将数据拆分成段发送，出于效率的考虑，不可能法一段等到确认再发，需要批量发送；这时TCP必须解决包乱序问题。
- 接收端的缓存大小，以此控制发送端发送数据的速率；这时TCP必须解决流量控制问题。

作用：

- 乱序重排
- 流量控制

### 发送方

![image-20211003154243400](https://tva1.sinaimg.cn/large/008i3skNly1gv2613kjqbj61480l841i02.jpg)

发送方任何时候，对其缓存内的数据都可以分为四类：

1. 已经发送并且得到回应的
2. 发送还没收到回应的
3. 未发送但对端允许发送的
4. 未发送且由于达到了window的大小对端不允许发送的

> 2和3所属的连续空间就属于发送窗口，当收到接收方新的ack（对于发送窗口中后续字节的确认值），窗口就会发生滑动
>
> 如果35被确认，33，34未确认不会滑动；
>
> 既前面字节未确认，后面字节先收到确认，窗口不会移动，既确保对端重传确认。

### 接收方

![image-20211003154704804](https://tva1.sinaimg.cn/large/008i3skNly1gv265mh61gj60z40ie40j02.jpg)

接收方任何时候，对其缓存内的数据都可以分为三类：

1. 已接收并已经发送回执
2. 已接收并未发送回执
3. 未接收，但可以接收，既准备接受
4. 未接收，不能接受

> 2为接收窗口，滑动机制与前面发送方一直 

## TCP和UDP区别

1. 连接：
   - TCP面向连接；UDP是无连接的，即发送数据之前不需要建立连接 ；
2. 可靠：
   - TCP提供可靠交付服务；UDP不保证可靠交付 ；
3. 面向：
   - TCP面向字节流，把数据看成一连串无结构的字节流；UDP是面向报文的；
4. 拥塞：
   - TCP有拥塞控制；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如语音通话，视频通话等） 
5. 点对点：
   - 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信 ；
6. 报文头：
   - TCP包头20字节+可变长度；
   - UDP包头8字节 ；
7. 全双工：
   - TCP每一次连接提供全双工通信；
   - UDP每一次连接都是单向的，既单工通信；

## TCP和UDP场景

 TCP 是面向连接的可靠性交付，常用于：

- FTP文件传输 
- HTTP / HTTPS 

UDP 是无连接的不可靠性交付；传输简单、高效；常用于：

- 包总量较少的通信，如 DNS 、SNMP等 
- 视频、音频等多媒体通信 
- 广播通信

## 三次握手

> - SYN=1表示要建立一个连接，ACK=1表示确认序列号有效
> - B收到A发出的确认报文段后建立连接，若没收到A发出的确认报文段，B就会重传连接确认报文段。 

![三次握手](https://tva1.sinaimg.cn/large/008i3skNly1gv23p09pxbj60je0czq4b02.jpg)

## 四次挥手

> - FIN=1表示要关闭一个连接，ACK=1表示确认序号有效
> - A进入TIME-WAIT状态。此时TCP未释放掉，需要经过2MSL时间（最大报文段生存时间）后，A才进入CLOSED状态。
> - B收到A发出的确认报文段后关闭连接，若没收到A发出的确认报文段，B就会重传连接释放报文段。 

![四次挥手](https://tva1.sinaimg.cn/large/008i3skNly1gv23tnvtdoj60k10eygnh02.jpg)

## 问题

### 为什么三次握手

1. TCP是全双工通信，双方都需要发送和接收SYN包和确认包，这样才能确认双方是可发可收的。
2. 避免新旧连接混淆。
   - 防止已失效的连接请求报文段突然又传送到了B，两次握手直接建立连接。
3. 初始化序列号，以便让对方知道接下来接收数据的时候如何按序列号组装数据。

### 为什么四次挥手

1. TCP是全双工通信，双方都需要发送和接收FIN包和确认包，这样才能确认双方都是可以关闭的。
   - 由于服务端在发送ACK包后，可能还有数据未发送完，需要等到发送完后，再发送释放报文，这样就比三次握手多了一次。

### 为什么需要TIME-WAIT状态

1. 保证A发送的最后一个ACK报文段能够到达B
   - 最后一个ACK报文段有可能丢失，B收不到这个确认报文，就会超时重传连接释放报文段，然后A可以在2MSL时间内收到这个重传的连接释放报文段，接着A重传一次确认，重启2MSL计时器。
2. 避免新旧连接混淆。
   - 经过2MSL，可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。

### Initial Sequence Number是固定的吗

- 当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。
- 如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

### 三次握手过程中可以携带数据吗

- 第一次、第二次握手不可以携带数据，即 SYN = 1的时候不能携带数据。
  - 假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。
  - 这样就会占用连接资源，使其他客户端无法正常连接。
- 第三次握手的时候，是可以携带数据的。
  - 此时对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。

### 半连接队列

- 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。
- 当然还有一个全连接队列，完成三次握手后建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

### SYN洪泛攻击

- SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时。
- 这些伪造的 SYN 包将长时间占用半连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

### 第三次握手丢失

- 服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。
- 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

# Socket

> - 单机中：PID唯一标识一个进程
> - 网络中：协议+IP地址+端口号唯一标识一个进程
> - 标识后就可以使用socket进行通信了

## 概念

- Socket是应用层与TCP/IP协议族通信的中间抽象层，它是一组接口。
- 在设计模式中，Socket就是一个门面模式，它把复杂的TCP/IP协议族操作隐藏在Socket接口后面。
- socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口

![img](https://tva1.sinaimg.cn/large/008i3skNly1gv26l9k5tjj60d60dmjs202.jpg)

- 初始化Socket
- 绑定端口(bind)
- 监听端口(listen)
- accept阻塞线程，等待客户端连接

## 实现

### TCPServer

```java
public class Server {
  public static void main(String[] args) throws IOException {
    final ServerSocket serverSocket = new ServerSocket(8090);
    ExecutorService executorService = Executors.newFixedThreadPool(6);
    while (true) {
      //阻塞直到收到新的客户端连接
      final Socket clientSocket = serverSocket.accept();
      //创建子线程处理客户端请求
      executorService.execute(() -> {
        try (BufferedReader br = new BufferedReader(
            new InputStreamReader(clientSocket.getInputStream()));
             BufferedReader in = new BufferedReader(
                 new InputStreamReader(System.in));
             PrintWriter pw = new PrintWriter(clientSocket.getOutputStream(), true)) {
          while (true) {
            if (br.ready()) {
              System.out.println("客户端:" + br.readLine());
            }
            if (in.ready()) {
              String msg = in.readLine();
              pw.println(msg);
              pw.flush();
              System.out.println("服务端:" + msg);
            }
          }
        } catch (IOException e) {
          e.printStackTrace();
        }
      });
    }
  }
}
```

### TCPClient

```java
public class Client {
  public static void main(String[] args) throws IOException {
    //Socket socket = new Socket("127.0.0.1", 8888);
    Socket socket = new Socket();
    String ip = "127.0.0.1";
    int port = 8090;
    socket.connect(new InetSocketAddress(ip, port));
    try (BufferedWriter bw = new BufferedWriter(
        new OutputStreamWriter(socket.getOutputStream()));
         BufferedReader in = new BufferedReader(
             new InputStreamReader(System.in));
         BufferedReader br = new BufferedReader(
             new InputStreamReader(socket.getInputStream()))) {
      while (true) {
        if (br.ready()) {
          System.out.println("服务端:" + br.readLine());
        }
        if (in.ready()) {
          String msg = in.readLine();
          System.out.println("客户端:" + msg);
          bw.write(msg + "\n");
          bw.flush();
        }
      }
    }
  }
}
```

### UDPServer

```java
public class UDPServer {
  public static void main(String[] args) throws IOException {
    // 接收数据
    DatagramSocket socket = new DatagramSocket(8800);
    byte[] data = new byte[1024];
    DatagramPacket packet = new DatagramPacket(data, data.length);
    socket.receive(packet);  // 此方法在接收到数据报之前会一直阻塞
    String info = new String(data, 0, packet.getLength());
    System.out.println("我是服务器，客户端说：" + info);
    //发送数据
    InetAddress address = packet.getAddress();
    int port = packet.getPort();
    byte[] data2 = "欢迎您!".getBytes();
    DatagramPacket packet2 = new DatagramPacket(data2, data2.length, address, port);
    socket.send(packet2);
    socket.close();
  }
}
```

### UDPClient

```java
public class UDPClient {
  public static void main(String[] args) throws IOException {
    // 发送数据
    DatagramSocket socket = new DatagramSocket();
    InetAddress address = InetAddress.getByName("localhost");
    int port = 8800;
    byte[] data = "用户名：admin;密码：123".getBytes();
    DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
    socket.send(packet);
    // 接收数据
    byte[] data2 = new byte[1024];
    DatagramPacket packet2 = new DatagramPacket(data2, data2.length);
    socket.receive(packet2);  // 此方法在接收到数据报之前会一直阻塞
    String info = new String(data2, 0, packet2.getLength());
    System.out.println("我是客户端，服务器说：" + info);
    socket.close();
  }
}
```

# HTTP

> 超文本传输协议，基于请求与响应模式的无连接、无状态的应用层协议，传输层使用TCP

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gv4f2kzmj2j60r40fmt9m02.jpg" alt="image-20210904162056027" style="zoom:33%;" />

## 特点

1. 无连接：
   - 是指服务端对于客户端每次发送的请求都认为它是一个新的请求；
   - 优点：在于解放了服务器，不会造成不必要连接占用；
2. 无状态：
   - 上一次会话和下一次会话没联系，如果后续处理需要前面的信息，则必须被重传；
   - 缺点：重传信息，导致每次连接传送的数据量增大。 
3. 灵活：允许传输任意类型的数据。传输的类型由Content-Type加以标记。 
4. 简单快速：
   - 客户向服务器请求服务时，只需传送请求方法和路径。常用的请求方法有GET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE。每种方法规定了客户端与服务器联系的类型不同。
5. 支持客户端/服务器模式。 

## 请求&响应报文

HTTP请求报文由请求行、请求头部、空行和请求体四个部分组成。

- 请求行：请求方法，访问的资源URL，HTTP协议版本；
- 请求头包含一些属性，格式为“属性名:属性值”，服务端据此获取客户端信息；
  - 主要有cookie、host、connection、accept-language、accept-encoding、user-agent。 
- 请求体：用户的请求数据如用户名，密码等。 

![image-20211005134720907](https://tva1.sinaimg.cn/large/008i3skNly1gv4dxnk504j60z40bc0tx02.jpg)

HTTP响应也由四个部分组成，分别是：状态行、响应头、空行和响应体。

- 响应行：协议版本，状态码及状态描述。 
- 响应头：connection、content-type、content-encoding、content-length、set-cookie、Last-Modified，、Cache-Control、Expires。 
- 响应体：服务器返回给客户端的内容。 

![image-20211005134937067](https://tva1.sinaimg.cn/large/008i3skNly1gv4e012xl1j60xy0a43zg02.jpg)

## 状态码

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gv4e5p1azij612k0iyq5a02.jpg" alt="image-20211005135504662" style="zoom: 33%;" />

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gv4e3mgsqoj60u20natb102.jpg" alt="image-20211005135304749" style="zoom: 43%;" />

## POST和GET

- Http报文层面: GET将请求信息放在URL, POST放在报文体中；
- 数据库层面: CET符合幂等性和安全性, POST不符合；
  - 幂等性：对数据库的一次操作和多次操作获得的结果是一致的
  - 安全性：对数据库的操作没有改变数据库的数据；
- 其他层面： 
  - GET可以被缓存,而POST不行（除非手动设置）
  - GET产生一个TCP数据包；POST产生两个TCP数据包。
    - 对于GET方式的请求，浏览器会把请求头和请求体一并发送出去；
    - 而对于POST，浏览器先发送请求头，服务器响应100 continue，浏览器再发送请求体。
  - GET请求只能进行url编码，而POST支持多种编码方式。 
    - application/x-www-form-urlencoded：get、post原生form表单
    - multipart/form-data
    - application/json
    - text/xml

## 长连接和短连接

**HTTP1.0默认使用的是短连接**。浏览器和服务器每进行一次HTTP操作，就建立一次TCP连接，任务结束就中断连接。

**HTTP/1.1起，默认使用长连接**。要使用长连接，客户端和服务器的HTTP首部的Connection都要设置为keep-alive，才能支持长连接。如果Connection:close直接释放连接。

HTTP长连接，指的是**复用TCP连接**。多个HTTP请求可以复用同一个TCP连接，这就节省了TCP连接建立和断开的消耗。

## HTTP1.0和HTTP1.1

- **长连接**：
  - HTTP1.0默认使用短连接，每次请求都需要建立新的TCP连接，连接不能复用。
  - HTTP1.1支持长连接，复用TCP连接。
- **缓存处理**：
  - 在HTTP1.0中主要使用header里的`If-Modified-Since,Expires`来做为缓存判断的标准。
  - HTTP1.1则引入了更多的缓存控制策略，有可供选择的缓存头来控制缓存策略。
- **带宽优化及网络连接的使用**：
  - HTTP1.0中不支持断点续传功能，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。
  - HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）。
- **错误通知的管理**：
  - 在HTTP1.1中新增了24个错误状态响应码。
    - 如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
- **Host头处理**：
  - 在HTTP1.0中认为每台服务器都绑定一个唯一IP地址，因此，请求消息中的URL并没有传递主机名。
  - 但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

## HTTP1.1和 HTTP2.0

HTTP2.0相比HTTP1.1支持的新特性：

- **新的二进制格式**：HTTP1.1的协议解析是基于文本。HTTP2.0的协议解析采用二进制格式，实现方便且健壮。
- **多路复用**：一个request对应一个id，这样一个连接上可以有多个request，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- **头部压缩**，HTTP1.1的header带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小。
- **服务端推送**：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，无需客户端请求。

# HTTPS

<img src="/Users/hao/Library/Application Support/typora-user-images/image-20211005145221240.png" alt="image-20211005145221240" style="zoom:33%;" />

- SSL(Security Sockets Layer ,安全套接层)
  - 为网络通信提供安全及数据完整性的一种安全协议
  - 是操作系统对外的API, SSL3.0后更名为TLS
  - 采用身份验证和数据加密保证网络通信的安全和数据的完整性

## 加密方式

> 加密过程：加密算法+明文+ 秘钥------》密文
>
> 解密过程：解密算法+密文+ 秘钥------》明文

- 对称加密：加密和解密都使用同一个密钥
  - DES，三重DES，AES
  - 安全性低，适应于大量数据加密
- 非对称加密：加密使用的密钥和解密使用的密钥是不相同的
  - 公钥加密私钥解密
  - 私钥加密公钥解密
  - RAS，ECC椭圆曲线
  - 安全性高，适应于少量数据加密，能加密的数据长度是有限的
- 哈希算法（单向散列函数）：将任意长度的信息转换为固定长度的值，算法不可逆
  - 验证消息是否被修改
  - MD5，SHA-256，SHA-1，SHA-2
- 消息认证码：hash(秘钥+消息)
  - 加秘钥验证消息是否被修改
- 数字签名：证明某个消息是某人发出
  - 发送者：hash(消息)，对这个摘要用私钥加密=数字签名
  - 接收者：用公钥解密拿到hash值进行对比
- 数字证书：证明公钥是某人的（上例公钥）
  - 发送者：去CA为公钥做认证，对公钥和一些个人/组织相关信息加密，生成数字证书
  - 接受者：用CA公钥验证数字证书，拿到真实公钥，再验证数字签名

## 与HTTP区别

1. HTTPS到CA申请证书, HTTP不需要
2. HTTPS密文传输, HTTP明文传输
3. 连接方式不同, HTTPS默认使用443端口, HTTP使用80端口
4. HTTPS=HTTP+认证+加密+完整性保护，较HTTP安全

## HTTPS原理

1. 首先是TCP三次握手
2. 客户端先发一个Client Hello的包
   - 告知服务端自己当前的一些信息，包括客户端要使用的TLS版本，支持的加密算法，要访问的域名等
3. 服务端响应一个Server Hello的包
   - 告诉客户端服务端选中的加密算法
4. 服务端给客户端发来了2个证书。第二个证书是第一个证书的签发机构（CA）的证书。
5. 客户端使用CA公开发布的RSA公钥对该证书进行验证，拿到服务器的公钥。
6. 浏览器和服务器通过密钥交换算法产生共享的对称密钥。
   - 或者，浏览器生成对称加密秘钥，使用服务器的公钥对client key进行加密，传输给服务器。（这样如果服务器的私钥丢失，也会有风险）
7. 服务器通过对称加密，加密数据，响应给客户端。

![img](https://img-blog.csdnimg.cn/20190509111404989.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NldWphdmFfZXI=,size_16,color_FFFFFF,t_70)

# Session和Coockie

> - 同源策略是要求IP、端口、协议全一致，不一致的请求就是跨域请求。cookies是可以跨域共享的，但是不能跨域名(IP)共享。
> - Jsessionid只是tomcat对sessionid的叫法

## 单体应用Session

![image-20211005194207620](https://tva1.sinaimg.cn/large/008i3skNly1gv4o8e60euj31bu0iu77p.jpg)

## 分布式Session

Session正常是由Servlet容器来维护的（内存里面，每个服务器内存是不共享的），这样Session就无法共享。如果希望Session共享，就需要把sessionID的存储放到一个统一的地方，如：redis。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gv4o9crb5aj61by0peabp02.jpg" alt="image-20211005194434874" style="zoom: 50%;" />

## 作用

- 记录客户状态
- 会话跟踪
  - 由于HTTP协议是无状态的协议，需要用某种机制来识别具体的用户身份，用来coockie和session跟踪用户的整个会话

## 区别

- 位置：Cookie数据存放在客户的浏览器上，Session数据放在服务器上
- 维护：Coockie由浏览器自动维护，Session由服务器维护
- 安全：Session相对于Cookie更安全
- 存储：单个Cookie保存的数据不能超过 4K，Session可存储数据远高于 Cookie
- 失效：
  - cookie没设置过期时间，保存在内存，生命周期为浏览器会话期间，关闭浏览器窗口，cookie消失
  - cookie设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。
  - session的默认有效时间是30min

## 保存什么数据

- Session用于保存每个用户的专用信息（用户的登录状态、角色、权限），如告白墙：
  - UserKey.login.openid：是否管理员
  - UserKey.秒杀商品id.openid: 数量
- Cookie用于保存客户端的请求信息，程序员也可以用它存放非敏感性的用户信息，如告白墙：
  - openid：UserKey.login.openid

## SessionId管理

- Cookies传递Sessionid
- URL回写，就是把session id直接附加在URL路径的后面
  - Tomcat的session实现机制是一开始同时使用coockie和url回写机制，如果发现客户端支持coockie就继续使用coockie停止使用url回写，如果发现coockie被禁用就一直使用URL回写。
- Header传递Session（方便类似于APP这种没有cookies的客户端进行Session共享）

# ARP协议

地址解析协议，Address Resolution Protocol，根据IP地址获取物理地址的一个TCP/IP协议，工作在数据链路层。

- 每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。 
- 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向网络中发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、物理地址、及目的主机的IP地址。 
- 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。 
- 源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。 
- 如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

# 输入URL

1. 解析域名，找到主机IP。 
   - 缓存：浏览器缓存、系统缓存、host文件、路由器缓存、本地域名服务器缓存
   - 请求：根域名服务器、顶级域名服务器、权限域名服务器
2. 浏览器以一个随机端口，根据IP和对应端口与服务器3次握手建立 TCP 连接。
3. 浏览器向服务器发起一个HTTP请求。 
4. 服务器响应请求，返回响应。 
5. 浏览器收到数据，解析渲染页面。 
6. 结束 --> 如果长连接等一会，4次挥手。

# 单点登录

1. 基于redis的分布式session
   - 用户信息存在分布式session，不同的服务器去同一个redis或redis集群获取
2. 基于JWT
   - 无状态应用：没有独立的状态存储。
     - 无状态应用，用户的登录状态、角色、权限这些数据放在JWT令牌
   - 有状态应用：用户的数据是存储在session里面，或者CAS Server提供认证状态，或者redis session状态集中存储。

- JWT实现方式
  - 方式一：JWT中只含用户的唯一标志，用户每一次访问资源都使用该唯一标志重新去数据库加载用户状态信息数据。
  - 方式二：JWT中包含所有的用户状态信息数据，这样做的坏处是增加了网络带宽的负担，但是因为完全不需要session，从而降低了对于内存的需求。<img src="https://tva1.sinaimg.cn/large/008i3skNly1gv4pvkxsodj60oe0elq4b02.jpg" alt="img" style="zoom: 67%;" />

# 正向&反向代理

## 作用

> 代为收发请求和响应

![img](https://tva1.sinaimg.cn/large/008i3skNly1gv5plj8nr4j60ei0icgma02.jpg)



## 区别

> 代理的对象同

- 正向代理代理的对象是客户端
  - 服务器不知道是谁发送的请求，只能感受到代理服务器
  - 客户端知道服务器地址，通过正向代理服务器访问
- 反向代理代理的对象是服务端
  - 客户端不知道请求的哪个服务器，只能感受到代理服务器
  - 客户端不知道服务器地址，通过反向代理服务器访问

## 应用场景

- 正向代理：
  - **隐藏客户端信息**：隐藏客户端IP等信息。
  - **突破访问限制** ：访问国外网站，教育网等。
  - **提高访问速度**：对静态内容及短时间内有大量访问请求的动态内容做缓存，加速访问。
  - **访问授权**：对客户端进行访问授权，上网进行认证。
- 反向代理：
  - **隐藏服务器信息**：隐藏服务器IP等信息。
  - **负载均衡**：根据服务器的负载情况，将客户端请求分发到不同的服务器上。
  - **提高访问速度**：对静态内容及短时间内有大量访问请求的动态内容做缓存，加速访问。
  - **保证内网安全**：通常将反向代理地址作为公网访问地址，Web服务器地址作为内网地址。

# 负载均衡

## 概念

> - 将服务器接收到的请求按照规则分发给不同服务器，使各服务器负载区域均衡的过程，称为负载均衡。
>
> - 负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，相对造价昂贵成本较高，但是数据的稳定性安全性更好。

## 算法

nginx负载均衡调度算法：

> - upstream是nginx的负载均衡模块
> - 服务器后面的down表示server暂不参与负载 

1. round robin（默认）：
   - 轮询方式，依次将请求分配到各个后台服务器中，默认的负载均衡方式。 
   - 用于后台机器性能一致的情况。 挂掉的机器可以自动从服务列表中剔除。
2. weight：
   - 根据权重来分发请求到不同的机器中，指定轮询几率，weight和访问比率成正比。
   - 用于后端服务器性能不均的情况。  

```nginx
server {
    listen 8081 default;
    server_name test.csdn.net;
    charset utf-8;
    location /get {
        proxy_pass http://somestream;
    }  
}

upstream bakend {    
    server 192.168.0.14 weight=10;    
    server 192.168.0.15 weight=10 dowm;    
}  
```

3. ip_hash：
   - 根据请求者ip的hash值将请求发送到后台指定服务器中。
   - 用户来自同一ip的请求被打到固定的机器上的情况，解决session共享问题。

```nginx
upstream bakend {    
    ip_hash;    
    server 192.168.0.14:88;    
    server 192.168.0.15:80;    
}   
```

4. url_hash（第三方）：nginx默认不支持，需安装相关模块
   - 根据请求的url的hash值将请求分到不同的机器中，提高服务器缓存效率。

```nginx
upstream somestream {
    hash $request_uri;
    server 192.168.244.1:8080;
    server 192.168.244.2:8080;
}
```

5. fair（第三方）：nginx默认不支持，需安装相关模块
   - 根据后台响应时间来分发请求，响应时间短的分发的请求多。

```nginx
upstream backserver { 
    fair; 
        server 192.168.0.14; 
    server 192.168.0.15; 
} 
```

# Nginx&Apache

> nginx和apache都可以做正向代理和反向代理

## nginx.conf

```nginx
user root owner;
worker_processes  1;


events {
    worker_connections  1024;
}


http {
    autoindex on;                    # 显示文件目录 
    autoindex_exact_size on;         # 显示文件大小 
    autoindex_localtime on;          # 显示文件时间 

    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;

    keepalive_timeout  65;

    server {
        listen       666; #文件服务器
        server_name  localhost;
        charset utf-8;
        root /Users/hao/Desktop/;

        location /a {
            return 602;  #返回状态码
            #root   html;
            #index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }

    server {
        listen       888; # 反向代理
        server_name  localhost;

        location / {
            proxy_pass http://demo;
        }

        upstream demo{  # 负载均衡
            server localhost:8081 weight=1 max_fails=2 fail_timeout=30s;
            server localhost:8082 weight=2 max_fails=2 fail_timeout=30s;
        }

        include servers/*;
    }
```


# REST

## 概念

> REST-是一种设计理念，一种架构风格
>
> REST-表现层状态转换，既资源在网络中以某种表现形式进行状态转移
>
> 「表现层」其实指的是「资源」的「表现层」。
>
> - Resource：资源，即数据。由URI来指定，比如usenames/users/friends/menu/order等
> - Representational：表现层。某种数据表现形式，比如用JSON，XML等
> - State Transfer：状态转移。通过HTTP动作实现，既Get、Post、Put、Delete
>

## RESTful

> - RESTful-是基于REST理念的一套开发风格，是具体的开发规则
> - 是一套编写接口的开发规范，定义如何编写接口、如何设置返回值、状态码等信息。

## 规范

### 域名

- 应该尽量将API部署在专用域名之下或在主域名后跟上api这个标识

```javascript
https://api.example.com
https://example.org/api/
```

### 版本

- 应该将API的版本号放入URL中

```
https://api.example.com/v1/
```

### 路径

- 在RESTful架构中，每个URL代表一种资源（resource），所以URL中不能有动词，只能有名词

```
https://api.example.com/v1/zoos
https://api.example.com/v1/animals
https://api.example.com/v1/employees
```

### 动词

- 动作含义由具体的请求方法来实现：
  - restful接口: 同一个url，根据method不同在后端做不同的处理，比如：post 创建数据、get获取数据、put和patch修改数据、delete删除数据。  
  -  no restfull接口: 需要多个url，每个url代表一个功能，比如：add_user/delte_user/edit_user/

> - GET（SELECT）：从服务器取出资源（一项或多项）。
> - POST（CREATE）：在服务器新建一个资源。
> - PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。
> - PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。
> - DELETE（DELETE）：从服务器删除资源。

> - HEAD：获取资源的元数据。
> - OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。

> - GET /zoos：列出所有动物园
> - POST /zoos：新建一个动物园
> - GET /zoos/ID：获取某个指定动物园的信息
> - PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
> - PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
> - DELETE /zoos/ID：删除某个动物园
> - GET /zoos/ID/animals：列出某个指定动物园的所有动物
> - DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物

### 过滤

- API应该提供参数，过滤返回结果。

- 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。

> - ?limit=10：指定返回记录的数量
> - ?offset=10：指定返回记录的开始位置。
> - ?page=2&per_page=100：指定第几页，以及每页的记录数。
> - ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
> - ?animal_type_id=1：指定筛选条件

### 错误处理

- 如果状态码是4xx，应向用户返回出错信息。一般将error作为键名，出错信息作为键值。

```javascript
{
    error: "Invalid API key"
}
```

### 返回结果

- 只返回数据(JSON I XML)，不包含任何视图

> - GET /collection：返回资源对象的列表（数组）
> - GET /collection/resource：返回单个资源对象
> - POST /collection：返回新生成的资源对象
> - PUT /collection/resource：返回完整的资源对象
> - PATCH /collection/resource：返回完整的资源对象
> - DELETE /collection/resource：返回一个空文档

## 场景

-  传统mvc模式返回视图，不适合前后端分离的场景
- 只以数据交互，适用于多种设备

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gv5rybsm4qj60t70gvjss02.jpg" alt="42B18F5E-A3E3-4286-ABD1-5163035592C5" style="zoom:67%;" align="left"/>


