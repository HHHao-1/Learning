# 基础功能

- 用户创建
- redis中user session构建
- 告白墙数据增删改查
- 商品数据增删改查

# 图片管理

## 图片上传

- 登录权限
- 告白墙上传
- 商品上传

根据日期与时间：建立文件夹，如：2021.09.09 --> am --> sort

```java
String wallUpload(MultipartFile file, String sort, String openid);
String goodsUpload(MultipartFile file, String goodsName, String openid);
```

## 图片获取

- 无权限
- 从缓存获取

缓存存储一天的告白墙数据；所有的商品封面数据；

- 数据库获取

告白墙每滑动一次日期减1，增加一天的数据到缓存，expire=5min；

商品详细信息先查缓存，没有就去数据库获取，然后存到缓存，expire=5min；

## 数据格式

- 告白墙图片

```json
[
	{
	"date":"20210909",
	"am":{
		"gaobai":[
			"http://192.168.1.9/data/img/20210909/am/gaobai/123123.jpeg",
			"http://192.168.1.9/data/img/20210909/am/gaobai/123123.jpeg",
		    ],
		"looking":[
			"http://192.168.1.9/data/img/20210909/am/looking/123123.jpeg",
			"http://192.168.1.9/data/img/20210909/am/looking/123123.jpeg",
		    ]
	    }
	},
	"pm":{
		"gaobai":[
			"http://192.168.1.9/data/img/20210909/pm/gaobai/123123.jpeg",
			"http://192.168.1.9/data/img/20210909/pm/gaobai/123123.jpeg",
		    ],
		"looking":[
			"http://192.168.1.9/data/img/20210909/pm/looking/123123.jpeg",
			"http://192.168.1.9/data/img/20210909/pm/looking/123123.jpeg",
		    ]
	    }
	}
]
```

- 秒杀活动图片

```json
[
	{
		"name":"奶茶",
        "goodsId":"1",
        "repertory":10,
		"price":"3",
		"begin-time":"2021.09.09 12:00:00",
		"cover-image":"http://192.168.1.9/data/goods/milky-tea/奶茶1.jpeg",	
	}
]
```

# 秒杀活动

## 商品上传

- 管理员权限
- 商品名称+库存+商品秒杀时间+商品封面+商品详情

## 商品秒杀

### 接口优化

- 增加数字验（google kaptcha）
  - 时间校验：防止提前获取、提前秒杀
  - 秒杀是否结束校验
  - 并发分流作用
- 秒杀接口隐藏
  1. 校验验证码
  2. 获取秒杀path参数
     - 参数生成：`MD5.encode(UUID.randomUUID().toString().replaceAll("-","")+salt)`
     - 设置`redisService.set(MiaoshaKey.getMiaoshaPath, "" + user.getId() + goodsId, pathId，10s);`
  3. 拼接秒杀地址
     - /miaosha/"+path+"/do_miaosha
     - 校验path，校验成功-->删除缓存中这个path-->开始秒杀
     - 秒杀成功缓存设置openid+goodsId-->1
- 接口限流防刷
  - 注解+拦截器
  - 获取path接口，每分钟限流10次
  - 缓存添加key，value每访问一次incr，过期时间60s
- 防止用户重复秒杀
  - 注解+拦截器
  - 检查openid+goodsId是否等于1

### 库存预减

- 商品上架时将商品库存初始化到缓存
- 收到秒杀请求，redis预减库存，库存不足直接返回秒杀失败，否则进入下一步，进入消息队列
- 请求进入消息队列，并立即返回秒杀中
- 请求出队，生成订单，减少数据库库存
- 用户客户端轮询result接口，是否秒杀成功

### 内存标记

- 目的：减少redis访问
- controller添加字段，HashMap
- goodsId-->true(库存小于0添加)
- 之后判断这条记录是否为true，减少redis访问

### 遇到问题

1. 货物超卖
   - sql语句，减库存时加数量判断，防止库存变负数
   - 若都不允许重复购买，可在用户秒杀表加唯一键

# Nginx

```shell
user root owner;
worker_processes  1;


events {
    worker_connections  1024;
}


http {

    autoindex on;                    # 显示文件目录 
    autoindex_exact_size on;         # 显示文件大小 
    autoindex_localtime on;          # 显示文件时间 

    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
   
    keepalive_timeout  65;

    server {
        listen       666;
        server_name  localhost;
        charset utf-8;
        root /Users/hao/Desktop/;

        location /a {
            return 602;  #返回状态码
            #root   html;
            #index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }

    server {
        listen       888;
        server_name  localhost;

        location / {
            proxy_pass http://demo;
    }

    upstream demo{
        server localhost:8081 weight=1 max_fails=2 fail_timeout=30s;
        server localhost:8082 weight=2 max_fails=2 fail_timeout=30s;
    }

    include servers/*;
}

```

# RabbitMQ

## 结构

下图是AMQP的协议模型：AMQP协议模型有三部分组成：生产者、消费者、服务器

![img](https://tva1.sinaimg.cn/large/008i3skNgy1guollrcxrmj60kg09cjry02.jpg)

RabbitMQ是基于AMQP协议实现的，其结构如下图所示，和AMQP协议基本一模一样。

![img](https://tva1.sinaimg.cn/large/008i3skNgy1guollo2ag9j60ls0bv0th02.jpg)

## MQ的作用

**1. 解耦：**充当中间者，松散耦合发送者和接收者，它们彼此不需要了解远程过程调用RPC与网络协议的细节；

**2. 异步通信：**能提供C/S之间同步与异步连接，在任何时刻都可以将消息进行传送或者存储转发；

**3. 可恢复性：**当消息接收方宕机或网络不通的情况下，消息转储于MQ中，网络恢复或接收方恢复再进行转发；

**4. 广播订阅：**方便的实现消息的广播订阅模式；

## 交换器类型

> direct、topic、fanout、headers

### Direct Exchange

将所有发送到该交换器的消息，通过routing key发送到绑定了同样routing key的队列中

![img](https://tva1.sinaimg.cn/large/008i3skNgy1guolq3m2e7j60kf09tgm502.jpg)

### Topic Exchange

将所有发送到Topic Exchange的消息，转发到所有绑定的队列中指定的Topic的队列上面。

支持模糊匹配，“*”用来匹配一个词，“#”用于匹配一个或者多个词。

不使用模糊匹配，则Exchange的表现与类型driect一致。

单独使用 # ，会接收所有的消息，这与类型 fanout一致。

![img](https://tva1.sinaimg.cn/large/008i3skNgy1guolq5t2jdj60m30aqq4a02.jpg)

### Fanout Exchange

该类型不处理路由键，会把所有发送到交换器的消息路由到所有绑定的队列中。优点是广播转发快，性能好。

![img](https://tva1.sinaimg.cn/large/008i3skNgy1guolq74yw7j60m10cfdgp02.jpg)

### Headers Exchange

- 不依赖路由规则来路由消息
- 根据消息内容中的header属性进行匹配
- header类型交换器性能差，在实际中并不常用。

## 应用

- 启动rabbitMQ服务器

- config

  ```java
  /**
  * Direct模式 交换机Exchange
  * */
  @Bean
  public Queue queue() {
      return new Queue(QUEUE, true);
  }
  
  /**
  * Topic模式 交换机Exchange
  * */
  @Bean
  public Queue topicQueue1() {
      return new Queue(TOPIC_QUEUE1, true);
  }
  @Bean
  public Queue topicQueue2() {
      return new Queue(TOPIC_QUEUE2, true);
  }
  @Bean
  public TopicExchange topicExchage(){
      return new TopicExchange(TOPIC_EXCHANGE);
  }
  @Bean
  public Binding topicBinding1() {
      return BindingBuilder.bind(topicQueue1()).to(topicExchage()).with("topic.key1");
  }
  @Bean
  public Binding topicBinding2() {
      return BindingBuilder.bind(topicQueue2()).to(topicExchage()).with("topic.#");
  }
  /**
  * Fanout模式 交换机Exchange
  * */
  @Bean
  public FanoutExchange fanoutExchage(){
      return new FanoutExchange(FANOUT_EXCHANGE);
  }
  @Bean
  public Binding FanoutBinding1() {
      return BindingBuilder.bind(topicQueue1()).to(fanoutExchage());
  }
  @Bean
  public Binding FanoutBinding2() {
      return BindingBuilder.bind(topicQueue2()).to(fanoutExchage());
  }
  /**
  * Header模式 交换机Exchange
  * */
  @Bean
  public HeadersExchange headersExchage(){
      return new HeadersExchange(HEADERS_EXCHANGE);
  }
  @Bean
  public Queue headerQueue1() {
      return new Queue(HEADER_QUEUE, true);
  }
  @Bean
  public Binding headerBinding() {
      Map<String, Object> map = new HashMap<String, Object>();
      map.put("header1", "value1");
      map.put("header2", "value2");
      return BindingBuilder.bind(headerQueue1()).to(headersExchage()).whereAll(map).match();
  }
  ```

- sender

  ```java
  @Autowired
  AmqpTemplate amqpTemplate ;
  
  public void sendMiaoshaMessage(MiaoshaMessage mm) {
      String msg = RedisService.beanToString(mm);
      log.info("send message:"+msg);
      amqpTemplate.convertAndSend(MQConfig.MIAOSHA_QUEUE, msg);
  }
  
  
  public void send(Object message) {
      String msg = RedisService.beanToString(message);
      log.info("send message:"+msg);
      amqpTemplate.convertAndSend(MQConfig.QUEUE, msg);
  }
  
  public void sendTopic(Object message) {
      String msg = RedisService.beanToString(message);
      log.info("send topic message:"+msg);
      amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE, "topic.key1", msg+"1");
      amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE, "topic.key2", msg+"2");
  }
  
  public void sendFanout(Object message) {
      String msg = RedisService.beanToString(message);
      log.info("send fanout message:"+msg);
      amqpTemplate.convertAndSend(MQConfig.FANOUT_EXCHANGE, "", msg);
  }
  
  public void sendHeader(Object message) {
      String msg = RedisService.beanToString(message);
      log.info("send fanout message:"+msg);
      MessageProperties properties = new MessageProperties();
      properties.setHeader("header1", "value1");
      properties.setHeader("header2", "value2");
      Message obj = new Message(msg.getBytes(), properties);
      amqpTemplate.convertAndSend(MQConfig.HEADERS_EXCHANGE, "", obj);
  }
  ```

- reciever

  ```java
  @RabbitListener(queues=MQConfig.MIAOSHA_QUEUE)
  public void receive(String message) {
      log.info("receive message:"+message);
      MiaoshaMessage mm  = RedisService.stringToBean(message, MiaoshaMessage.class);
      MiaoshaUser user = mm.getUser();
      long goodsId = mm.getGoodsId();
      GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);
      int stock = goods.getStockCount();
      if(stock <= 0) {
          return;
      }
      //判断是否已经秒杀到了
      MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);
      if(order != null) {
          return;
      }
      //减库存 下订单 写入秒杀订单
      miaoshaService.miaosha(user, goods);
  }
  ```

# JMeter

