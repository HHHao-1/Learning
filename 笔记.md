<html>
	<head>
		<meta charset="UTF-8"></meta>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
	</head>
	<body>
    <div class="alert alert-dark" role="alert" align="center">
      <h3><img src="assets/icon.png" alt="icon.png" height="50" width="50">&emsp;HHHAo的笔记本</h3>
    </div>
    <div class="jumbotron">

## 版本控制
<details>
<summary>版本控制</summary>
<details>
<summary>Git</summary>

### Git :monkey:
<details>
<summary>GIT 原理</summary>

---
#### GIT原理

---
- 工作流
```
克隆 Git 资源作为工作目录。
在克隆的资源上添加或修改文件。
如果其他人修改了，你可以更新资源。
在提交前查看修改。
提交修改。
在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。
```
![git](assets/59c31e4400013bc911720340.jpeg)
</details>
<details>
<summary>快速使用</summary>

---
#### 快速使用

---
```git
$ git init

$ git add 文件名

# 添加当前目录的所有文件到暂存区
$ git add .

$ git commmit -m  "代码提交信息"

$ git remote add origin(远程仓库名) 链接

$ git push origin master

$ git push origin HEAD:test

$ git pull [remote] [branch]

$ git status

$ git log

# 下载远程仓库的所有变动
$ git fetch [remote]

# 管理远程仓库
$ git remote rm origin
$ git remote set-url origin 链接
$ git remote -v

#克隆:本地/远程SSH/远程HTTPS
$ git clone /path/to/repository
$ git clone username@host:/path/to/repository
$ git clone 连接地址
```
</details>
<details>
<summary>命令大全</summary>

---
#### Git命令大全

---
##### 1.新建代码库
```git
# 在当前目录新建一个Git代码库
$ git init
 
# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]
 
# 下载一个项目和它的整个代码历史
```
###### 2.配置
```git
# 显示当前的Git配置
$ git config --list
 
# 编辑Git配置文件
$ git config -e [--global]
 
# 设置提交代码时的用户信息
$ git config [--global] user.name "[name]"
$ git config [--global] user.email "[email address]"
```
###### 3.增加/删除文件
```git
# 添加指定文件到暂存区
$ git add [file1] [file2] ...
 
# 添加指定目录到暂存区，包括子目录
$ git add [dir]
 
# 添加当前目录的所有文件到暂存区
$ git add .
 
# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p
 
# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...
 
# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]
 
# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
```
##### 4.代码提交
```git
# 提交暂存区到仓库区
$ git commit -m [message]
 
# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]
 
# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a
 
# 提交时显示所有diff信息
$ git commit -v
 
# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]
 
# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
```
##### 5.分支
```git
# 列出所有本地分支
$ git branch
 
# 列出所有远程分支
$ git branch -r
 
# 列出所有本地分支和远程分支
$ git branch -a
 
# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]
 
# 新建一个分支，并切换到该分支
$ git checkout -b [branch]
 
# 新建一个分支，指向指定commit
$ git branch [branch] [commit]
 
# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]
 
# 切换到指定分支，并更新工作区
$ git checkout [branch-name]
 
# 切换到上一个分支
$ git checkout -
 
# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]
 
# 合并指定分支到当前分支
$ git merge [branch]
 
# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]
 
# 删除分支
$ git branch -d [branch-name]
 
# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
```
##### 6.标签
```git
# 列出所有tag
$ git tag
 
# 新建一个tag在当前commit
$ git tag [tag]
 
# 新建一个tag在指定commit
$ git tag [tag] [commit]
 
# 删除本地tag
$ git tag -d [tag]
 
# 删除远程tag
$ git push origin :refs/tags/[tagName]
 
# 查看tag信息
$ git show [tag]
 
# 提交指定tag
$ git push [remote] [tag]
 
# 提交所有tag
$ git push [remote] --tags
 
# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
```
##### 7.远程同步
```git
# 下载远程仓库的所有变动
$ git fetch [remote]
 
# 显示所有远程仓库
$ git remote -v
 
# 显示某个远程仓库的信息
$ git remote show [remote]
 
# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]
 
# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]
 
# 上传本地指定分支到远程仓库
$ git push [remote] [branch]
 
# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force
 
# 推送所有分支到远程仓库
$ git push [remote] --all
```
##### 8.查看信息
```git
# 显示有变更的文件
$ git status
 
# 显示当前分支的版本历史
$ git log
 
# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat
 
# 搜索提交历史，根据关键词
$ git log -S [keyword]
 
# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s
 
# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件
$ git log [tag] HEAD --grep feature
 
# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]
 
# 显示指定文件相关的每一次diff
$ git log -p [file]
 
# 显示过去5次提交
$ git log -5 --pretty --oneline
 
# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn
 
# 显示指定文件是什么人在什么时间修改过
$ git blame [file]
 
# 显示暂存区和工作区的差异
$ git diff
 
# 显示暂存区和上一个commit的差异
$ git diff --cached [file]
 
# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD
 
# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]
 
# 显示今天你写了多少行代码
$ git diff --shortstat "@{0 day ago}"
 
# 显示某次提交的元数据和内容变化
$ git show [commit]
 
# 显示某次提交发生变化的文件
$ git show --name-only [commit]
 
# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]
 
# 显示当前分支的最近几次提交
$ git reflog
```
##### 9.撤销
```git
# 恢复暂存区的指定文件到工作区
$ git checkout [file]
 
# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]
 
# 恢复暂存区的所有文件到工作区
$ git checkout .
 
# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]
 
# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard
 
# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]
 
# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]
 
# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]
 
# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]
 
# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
```
</details>
<details>
<summary>问题记录</summary>

---
#### 问题记录

---

##### github无法显示图片
- 输入raw.githubusercontent.com查询IP地址
- 修改hosts文件:sudo vi /etc/hosts
- 添加以下内容保存即可 （IP地址查询后相应修改，可以ping不同IP的延时 选择最佳IP地址）
```
# GitHub Start
52.74.223.119 github.com
192.30.253.119 gist.github.com
54.169.195.247 api.github.com
185.199.111.153 assets-cdn.github.com
151.101.76.133 raw.githubusercontent.com
151.101.108.133 user-images.githubusercontent.com
151.101.76.133 gist.githubusercontent.com
151.101.76.133 cloud.githubusercontent.com
151.101.76.133 camo.githubusercontent.com
151.101.76.133 avatars0.githubusercontent.com
151.101.76.133 avatars1.githubusercontent.com
151.101.76.133 avatars2.githubusercontent.com
151.101.76.133 avatars3.githubusercontent.com
151.101.76.133 avatars4.githubusercontent.com
151.101.76.133 avatars5.githubusercontent.com
151.101.76.133 avatars6.githubusercontent.com
151.101.76.133 avatars7.githubusercontent.com
151.101.76.133 avatars8.githubusercontent.com
# GitHub End
```
</details>
</details>


<details>
<summary>SVN</summary>

### SVN :monkey:
<details>
<summary>原理</summary>

---
#### SVN 原理

---

##### SVN 简介

- Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。

##### SVN 的一些概念
- repository（源代码库）:源代码统一存放的地方
- Checkout（提取）:当你手上没有源代码的时候，你需要从repository checkout一份
- Commit（提交）:当你已经修改了代码，你就需要Commit到repository
- Update（更新）:当你已经Checkout了一份源代码， Update一下你就可以和Repository上的源代码同步，你手上的代码就会有最新的变更
- 日常工作流程：Checkout（克隆,一段时间后）---> Update(获得最新的代码) --> 作出自己的修改并调试成功 --> Commit(大家就可以看到你的修改了) 。
-  Conflict（冲突）: 如果两个程序员同时修改了同一个文件呢, SVN 可以合并这两个程序员的改动，实际上SVN管理源代码是以行为单位的，就是说两个程序员只要不是修改了同一行程序，SVN都会自动合并两种修改。如果是同一行，SVN 会提示文件 Conflict,冲突，需要手动确认。
##### SVN 工作流程
- 创建版本库
  - 版本库相当于一个集中的空间，用于存放开发者所有的工作成果。版本库不仅能存放文件，还包括了每次修改的历史，即每个文件的变动历史。
  - Create 操作是用来创建一个新的版本库。大多数情况下这个操作只会执行一次。当你创建一个新的版本库的时候，你的版本控制系统会让你提供一些信息来标识版本库，例如创建的位置和版本库的名字。
- 检出
  - Checkout 操作是用来从版本库创建一个工作副本。工作副本是开发者私人的工作空间，可以进行内容的修改，然后提交到版本库中。
- 更新
  - update 操作是用来更新版本库的。这个操作将工作副本与版本库进行同步。由于版本库是由整个团队共用的，当其他人提交了他们的改动之后，你的工作副本就会过期。
- 执行变更
  - 当检出之后，你就可以做很多操作来执行变更。编辑是最常用的操作。你可以编辑已存在的文件，例如进行文件的添加/删除操作。
  - 你可以添加、删除、Rename、移动文件/目录。但是这些变更的文件目录不会立刻成为版本库的一部分，而是被添加进待变更列表中，直到执行了 commit 操作后才会成为版本库的一部分。
- 复查变化
  - 当你检出工作副本或者更新工作副本后，你的工作副本就跟版本库完全同步了。但是当你对工作副本进行一些修改之后，你的工作副本会比版本库要新。在 commit 操作之前复查下你的修改是一个很好的习惯。
  - Status 操作列出了工作副本中所进行的变动。正如我们之前提到的，你对工作副本的任何改动都会成为待变更列表的一部分。Status 操作就是用来查看这个待变更列表。
  - Status 操作只是提供了一个变动列表，但并不提供变动的详细信息。你可以用 diff 操作来查看这些变动的详细信息。
- 修复错误
  - 我们来假设你对工作副本做了许多修改，但是现在你不想要这些修改了，这时候 revert 操作将会帮助你。
  - Revert 操作重置了对工作副本的修改。它可以重置一个或多个文件/目录。当然它也可以重置整个工作副本。在这种情况下，revert 操作将会销毁待变更列表并将工作副本恢复到原始状态。
- 解决冲突
  - 合并的时候可能会发生冲突。Merge 操作会自动处理可以安全合并的东西。其它的会被当做冲突。例如，"hello.c" 文件在一个分支上被修改，在另一个分支上被删除了。这种情况就需要人为处理。Resolve 操作就是用来帮助用户找出冲突并告诉版本库如何处理这些冲突。
- 提交更改
  - Commit 操作是用来将更改从工作副本到版本库。这个操作会修改版本库的内容，其它开发者可以通过更新他们的工作副本来查看这些修改。
  - 在提交之前，你必须将文件/目录添加到待变更列表中。列表中记录了将会被提交的改动。当提交的时候，我们通常会提供一个注释来说明为什么会进行这些改动。这个注释也会成为版本库历史记录的一部分。
  - Commit 是一个原子操作，也就是说要么完全提交成功，要么失败回滚。用户不会看到成功提交一半的情况。
</details>
<details>
<summary>快速使用</summary>

---
#### 快速使用

---
```shell
svnadmin create /Users/apple/svn/mycode

svnserve -d -r /path/svn  

#初始化导入svn服务器
svn import /Users/apple/webSite svn://localhost/mycode/webSite --username=mj --password=123 -m "初始化导入"

svn checkout svn://localhost/mycode --username=mj --password=123 /Users/apple/svnwebSite

#提交更改过的代码到服务器
cd /Users/apple/svnwebSite
svn commit -m "修改了webSite文件"

#更新服务器端的代码到客户端
cd /Users/apple/svnwebSite
svn update

svn help
svnserve --version
```
</details>
<details>
<summary>配置及启动</summary>

---
#### 配置及启动

---
- 手动新建版本库目录
  ```mkdir /opt/svn```
- 创建版本库
  ```svnadmin create /opt/svn/runoob```
- 修改仓库配置
  - 修改conf文件夹下的svnserve.conf文件
    ```properties
    [general]
    #anon-access = none，这样禁止匿名访问，需要帐号密码才能访问
    anon-access = none
    auth-access = write
    password-db = passwd
    authz-db = authz
    [sasl]
    ```
  - 修改conf下的passwd文件，在[users]后面加入用户和密码
      ```
      administrator = admin@Svnserver
      xiayong = xiayong
      ```
- 启动svn服务
  - ```svnserve -d -r 目录 --log-file=/var/log/svn.log --listen-port 端口号```
    - -r: 配置方式决定了版本库访问方式。
    - --log-file=/var/log/svn.log: 指定日志路径
    - --listen-port: 指定SVN监听端口，不加此参数，SVN默认监听3690
- 两种启动方式
  - 由于-r 配置方式的不一样，SVN启动就可以有两种不同的访问方式
  - 方式一：
    - -r直接指定到版本库(称之为单库svnserve方式)
  ```svnserve -d -r /opt/svn/runoob```
一个svnserve只能为一个版本库工作
    - authz配置文件中对版本库权限的配置应这样写：
      ```properties
      [groups]
      admin=user1
      dev=user2
      [/]
      @admin=rw
      user2=r
      ```
    - 使用类似这样的URL：svn://192.168.0.1/　即可访问runoob版本库
  - 方式二：
    - 指定到版本库的上级目录(称之为多库svnserve方式)
    ```svnserve -d -r /opt/svn```
一个svnserve可以为多个版本库工作
    - authz配置文件中对版本库权限的配置应这样写：
      ```properties
      [groups]
      admin=user1
      dev=user2
      [runoob:/]
      @admin=rw
      user2=r
      [runoob01:/]
      @admin=rw
      user2=r
      ```
      如果此时你还用[/]，则表示所有库的根目录，同理，[/src]表示所有库的根目录下的src目录。
    - 使用类似这样的URL：svn://192.168.0.1/runoob　即可访问runoob版本库。
- 启动测试(可选)
  ```  telnet localhost 3690```
- 创建默认目录结构(可选)
  - 首先在本地把目录结构建立好
    ```shell
    $ sudo mkdir -p /tmp/svntemp
    $ cd /tmp/svntemp/
    $ sudo mkdir tags trunk branches

    1.trunk是主分支，是日常开发进行的地方。
    2.branches是分支。一些阶段性的release版本，这些版本是可以继续进行开发和维护的，则放在branches目录中。又比如为不同用户客制化的版本，也可以放在分支中进行开发。
    3.tags目录一般是只读的，这里存储阶段性的发布版本，只是作为一个里程碑的版本进行存档。
    ```
  - 接下来将本地目录结构导入到我们的svn仓库中
    ```shell
    $ sudo svn import -m 'init repo' /tmp/svntemp/ svn://localhost/local
    Authentication realm: <svn://localhost:3690> af662c40-23bf-43f4-93fa-8bf7eff40771
    Password for 'root':
    Authentication realm: <svn://localhost:3690> af662c40-23bf-43f4-93fa-8bf7eff40771
    Username: administrator
    Password for 'administrator':
    Adding         /tmp/svntemp/trunk
    Adding         /tmp/svntemp/branches
    Adding         /tmp/svntemp/tags
    Committed revision 1.
    ```
    我是使用administrator这个用户导入的，因为目前只有这个用户才有权限。
  - 现在我们的svn服务器已经可以用了，可以使用svn://localhost/local来访问我们的local这个仓库，当然不要忘记了，我们刚才新添加了目录，需要修改权限。
      ```properties
      [local:/branches]
      @user = rw
      [local:/tags]
      @user = r
      [local:/trunk]
      @user = rw
      ```
- svn开机启动（可选）
  - 编辑/etc/rc.local文件，在这个文件中加入以下内容(此文件在Mac系统中是没有的，需要手动创建)
      ```shell
      # to run the svnserver on the automatically.
      svnserve -d -r /data/svn/repositories
      ```
</details>
<details>
<summary>问题记录</summary>

---
#### 问题记录
---
```shell
#linux 下停止所有的svn服务
killall svnserve

#windows 下停止svn服务
net stop svn 【停止服务】

#windows 下删除svn服务
sc delete svn 【删除服务】

#启动认证失败
#删除认证缓存设置即可
rm -rf ~/.subversion/auth
```
</details>
</details>
</details>

## 模板引擎
<details>
<summary>模板引擎</summary>
<details>
<summary>简介</summary>

---
### 简介 :monkey:
---
- 一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。
&emsp; 
- Thymeleaf与FreeMarker比较
&emsp; 
  - Thymeleaf
    `Html里写模板`
    - 优点
    `静态html嵌入标签属性，浏览器可以直接打开模板文件，便于前后端联调`
    - 特点
      - 动静结合
    `Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。`
      - 与SpringBoot完美整合
    `SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。`
    - 缺点
    `模板必须符合xml规范
    js脚本必须加入/*<![CDATA[*/标识，否则一个&符号就会导致后台模板合成抛异常，而且错误信息巨不友好，害得我调试了好几个小时才明白是怎么回事。js里面还好办，这样是在html里面含有&等符号，还需要转义？忒麻烦了！`
    `Thymaleaf的自定义方法较难实现完美的数据转换`
&emsp; 
  - FreeMarker
    `模板里写Html`
      - 优点
     `严格的 MVC (模型 视图 控制器) 模式`
     `宏的强大和自定义节点转换方法函数适合特殊、复杂数据的转化`
      - 缺点
      `前后端联调不方便`

</details>
<details>
<summary>Tymeleaf</summary>

---
### Tymeleaf :monkey:
---
<details>
<summary>快速使用</summary>

#### 快速使用
- 我们的表达式写在一个名为：th:text的标签属性中，这个叫做指令
```html
<!-- 引入命名空间前缀 -->
<html lang="en" xmlns:th="http://www.thymeleaforg">
<!-- 取值：先在request中找，然后session，再servlet context -->
<body>
  <h1 th:text="${msg}">test</h1>
</body>
```
```java
// 后台model将数据写入request
@GetMapping("test2")
public String test2(Model model){
    User user = new User();
    user.setAge(21);
    user.setName("Jackson");
    user.setFriend(new User("李小龙", 30));
    model.addAttribute("user", user);
    return "hello2";
}
```
```java
 String msg = "<h1>啦啦啦</h1>";
```
```html
th:text与th:utexte区别
<!-- 用th:text不会解析html，用th:utext会解析html，在页面中显示相应的样式 -->
 <p th:text="采用text标签： + ${msg}"></p>
<!-- 采用text标签：<h1>啦啦啦</h1> -->
 <p th:utext="采用utext标签： + ${msg}"></p>
<!-- 采用utext标签：
     啦啦啦 -->
```
</details>
<details>
<summary>语法</summary>

#### 语法
- 变量（取值）、方法、条件判断、循环、运算、逻辑运算、布尔运算、比较运算、条件运算、其它
```html
变量
<!-- 
如果不支持这种th:的命名空间写法，那么可以把th:text换成 data-th-text
获取变量值，我们使用的是经典的对象.属性名方式。
有些情况下，我们的属性名可能本身也是变量：例如：${user.name} 可以写作${user['name']}
 -->

变量_自定义变量
<h2>
    <p>Name: <span th:text="${user.name}">Jack</span>.</p>
    <p>Age: <span th:text="${user.age}">21</span>.</p>
    <p>friend: <span th:text="${user.friend.name}">Rose</span>.</p>
</h2>
<!-- 我们获取用户的所有信息，分别展示。
当数据量比较多的时候，频繁的写user.就会非常麻烦。因此，Thymeleaf提供了自定义变量来解决 -->
<h2 th:object="${user}">
    <p>Name: <span th:text="*{name}">Jack</span>.</p>
    <p>Age: <span th:text="*{age}">21</span>.</p>
    <p>friend: <span th:text="*{friend.name}">Rose</span>.</p>
</h2>
<!-- 首先在 h2上 用 th:object="${user}"获取user的值，并且保存
然后，在h2内部的任意元素上，可以通过 *{属性名}的方式，来获取user中的属性，这样就省去了大量的user.前缀了 -->

方法

方法_拼接
<span th:text="'欢迎您:' + ${user.name} + '!'"></span>
<!-- 字符串字面值需要用''，拼接起来非常麻烦，Thymeleaf对此进行了简化，使用一对|即可： -->
<span th:text="|欢迎您:${user.name}|"></span>

方法调用
<!-- ognl表达式本身就支持方法调用 -->
<h2 th:object="${user}">
    <p>FirstName: <span th:text="*{name.split(' ')[0]}">Jack</span>.</p>
    <p>LastName: <span th:text="*{name.split(' ')[1]}">Li</span>.</p>
</h2>
<!-- 这里我们调用了name（是一个字符串）的split方法。 -->

方法——内置对象：后面

运算
<span th:text="${user.sex} ? '男':'女'"></span>

循环
<tr th:each="user : ${users}">
    <td th:text="${user.name}">Onions</td>
    <td th:text="${user.age}">2.41</td>
</tr>
<tr th:each="user,stat : ${users}">
    <td th:text="${user.name}">Onions</td>
    <td th:text="${user.age}">2.41</td>
</tr>
<!-- 
stat对象包含以下属性：
index，从0开始的角标
count，元素的个数，从1开始
size，总元素个数
current，当前遍历到的元素
even/odd，返回是否为偶/奇，boolean值
first/last，返回是否为第一或最后，boolean值 
-->

逻辑判断if
<!-- 使用th:if 或者 th:unless ，两者的意思恰好相反。 -->
<!-- 如果表达式的值为true，则标签会渲染到页面，否则不进行渲染。 -->
<span th:if="${user.age} > 24">老油条</span>

分支控制switch
<!-- 需要注意的是，一旦有一个th:case成立，其它的则不再判断。与java中的switch是一样的。 -->
<!-- 另外th:case="*"表示默认，放最后。 -->
<div th:switch="${user.role}">
  <p th:case="'admin'">用户是管理员</p>
  <p th:case="'manager'">用户是经理</p>
  <p th:case="*">用户是别的玩意</p>
</div>

JS模板
<!-- 模板引擎不仅可以渲染html，也可以对JS中的进行预处理。为在纯静态环境下可以运行，Thymeleaf代码可被注释起来 -->
<!-- 在script标签中通过th:inline="javascript"来声明这是要特殊处理的js脚本 -->
<script th:inline="javascript">
    const user = /*[[${user}]]*/ {};
    const age = /*[[${user.age}]]*/ 20;
    console.log(user);
    console.log(age)
</script>
<!-- 语法结构：const user = /*[[Thymeleaf表达式]]*/ "静态环境下的默认值"; -->
<!-- 因为Thymeleaf被注释起来，因此即便是静态环境下， js代码也不会报错，而是采用表达式后面跟着的默认值。且User对象会被直接处理为json格式。 -->
```
##### 内置对象
- 这些对象中提供了一些方法，方便我们来调用。获取这些对象，需要使用#对象名来引用。

##### 环境相关对象

| 对象            | 作用                                          |
| --------------- | --------------------------------------------- |
| #ctx            | 获取Thymeleaf自己的Context对象                |
| #requset        | 如果是web程序，可以获取HttpServletRequest对象 |
| #response       | 如果是web程序，可以获取HttpServletReponse对象 |
| #session        | 如果是web程序，可以获取HttpSession对象        |
| #servletContext | 如果是web程序，可以获取HttpServletContext对象 |
##### 全局对象  

| 对象       | 作用                             |
| ---------- | -------------------------------- |
| #dates     | 处理java.util.date的工具对象     |
| #calendars | 处理java.util.calendar的工具对象 |
| #numbers   | 用来对数字格式化的方法           |
| #strings   | 用来处理字符串的方法             |
| #bools     | 用来判断布尔值的方法             |
| #arrays    | 用来护理数组的方法               |
| #lists     | 用来处理List集合的方法           |
| #sets      | 用来处理set集合的方法            |
| #maps      | 用来处理map集合的方法            |

##### 应用
```java
@GetMapping("test3")
public String show3(Model model){
    model.addAttribute("today", new Date());
    return "hello3";
}
```
```html
<p>
  今天是: <span th:text="${#dates.format(today,'yyyy-MM-dd')}">2018-04-25</span>
</p>
```
</details>
</details>
<details>
<summary>FreeMarker</summary>

---
### FreeMarker :monkey:
---
<details>
<summary>快速使用</summary>

#### 快速使用
- 数据（java）+模板（ftl）= 结果（html）
```html
这里是ftl文件
<!-- 先在request中找，然后session，再servlet context -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Insert title here</title>
  </head>
  <body>
    <h1>你好： ${username}</h1>
  </body>
</html>
```
```java
java后台整合
//1.加载模板、创建核心配置对象
Configuration configuration = new Configuration (configuration. VERSION_2_3_28);
//设置加载的目录
// 在本类所在包中加载ft1文件, "代表当前包的意思confiquration.setclassForTemplateLoading(本类.class.")
//设置编码
configuration. setDefaultEncoding "UTF-8" );
// 得到模板对象
Template template- confiquration.getTemplate ("demo.ft1");
//2.处理数据
Map-String, Object> data = new HashMap-String, Object>();
data.put ("site", "百度");
data.put ("ur","www.baidu.com");
// 3.产生输出
// System.out向控制台输出,是一个printStream字节流,要转换为字符流
template.process (data, new outputstreamwriter(System.out));
```
```ftl
站点：${site}-- 地址：${ur}}
```
</details>
<details>
<summary>命令大全</summary>

#### 语法
- 变量（取值）、方法、条件判断、循环、运算、逻辑运算、布尔运算、比较运算、条件运算、其它
```markdown
取值
$ {属性名} 可对属性进行计算
$ {属性名!默认值} 使用默认
$ {属性名?string} 格式化输出

示例
    {date?string("yyyy年MM月dd日HH:mm:ss SSS)}
    {number?string("0.00"}
    SN:${computer.sn}
    型号:${computer.model}
    状态:${computer.state}
    用户:${computer.user}
    采购时间:${computer.dop?string("yyyy年MM月dd日)}
    采购价格:${computer.price?string("0.00"}
    配置信息:
        CPU:${computer.info["cpu"]}
        内存:${computer.info["memory"] !"无内存信息"}
```
```markdown
空值判断、处理
<!-- FreeMarker的变量必须赋值，否则就会抛出异常。而对于FreeMarker来说，null值和不存在的变量是完全一样的，因为FreeMarker无法理解null值。 -->
FreeMarker提供两个运算符来避免空值:

1. !：指定缺失变量的默认值
    !运算符有两种用法：
        variable!或variable!defaultValue
        第一种用法不给变量指定默认值，表明默认值是空字符串、长度为0的集合、或长度为0的Map对象。
    注意：使用!运算符指定默认值并不要求默认值的类型和变量类型相同。

测试空值：
    ${sss} <#--没有定义这个变量，会报异常！-->
    ${sss!} <#--没有定义这个变量，默认值是空字符串！-->
    ${sss!"abc"} <#--没有定义这个变量，默认值是字符串abc！-->

2. ??：判断变量是否存在
    ??运算符返回布尔值，如：variable??，如果变量存在，返回true，否则返回false。
```
```markdown

assign指令：
用于为该模板页面创建或替换一个顶层变量
<#assign name=value [in namespacehash]>,
<!-- 这个用法用于指定一个名为name的变量,该变量的值为value
     此外,FreeMarker允许在使用assign指令里增加in子句
     in子句用于将创建的name变量放入namespacehash命名空间中. -->
  <#assign name="李四">
    姓名：${name}
  <#assign info={"name":"张三","address":"上海"}>
    姓名：${info.name}
    地址：${info.address}
  <#assign seq = ["foo", "bar", "baz"]>

字符串输出:
    ${"Hello ${name} !"} / ${"Hello " + name + " !"}
    <#assign cname=r"特殊字符完成输出(http:\www.baidu.com)">
    ${cname}

字符串截取 ： 
    通过下标直接获取下标对应的字母： ${name[2]}
    起点下标..结尾下标截取字符串：${name[0..5]}

算数运算：
    <#-- 支持"+"、"－"、"*"、"/"、"%"运算符 -->
    <#assign number1 = 10>
    <#assign number2 = 5>
    "+" : ${number1 + number2}
    "－" : ${number1 - number2}
    "*" : ${number1 * number2}
    "/" : ${number1 / number2}
    "%" : ${number1 % number2}

比较运算符：
<!-- 
      EQ 就是 EQUAL等于
      NE就是 NOT EQUAL不等于
      GT 就是 GREATER THAN大于　
      LT 就是 LESS THAN小于
      GE 就是 GREATER THAN OR EQUAL 大于等于
      LE 就是 LESS THAN OR EQUAL 小于等于 
-->
<!--freemarker里面不能包含 ">", "<" 所以要用到大于和小于,就要用gt,lt -->
  <#if number1 + number2 gte 12 || number1 - number2 lt 6>
      "*" : ${number1 * number2}
  <#else>
      "/" : ${number1 / number2}
  </#if>

内建函数：
    <#assign data = "abcd1234">
    第一个字母大写：${data?cap_first}
    所有字母小写：${data?lower_case}
    所有字母大写：${data?upper_case}
    <#assign floatData = 12.34>
    数值取整数：${floatData?int}
    获取集合的长度：${users?size}
    时间格式化：${dateTime?string("yyyy-MM-dd")}

空判断和对象集合：
  <#if users??>
      <#list users as user >
          ${user.id} - ${user.name}
      </#list>
  <#else>
      ${user!"变量为空则给一个默认值"}
  </#if>

Map集合：
  <#assign mapData={"name":"程序员", "salary":15000}>

  直接通过Key获取 Value值：${mapData["name"]}

  通过Key遍历Map：
  <#list mapData?keys as key>
      Key: ${key} - Value: ${mapData[key]}
  </#list>

  通过Value遍历Map：
  <#list mapData?values as value>
      Value: ${value}
  </#list>

List集合：
  <#assign listData=["ITDragon", "blog", "is", "cool"]>
  <#list listData as value>${value} </#list>

include指令：
  引入其他文件：<#include "otherFreeMarker.ftl" />

macro宏指令：
  <#macro mo>
    定义无参数的宏macro--${name}
  </#macro>
    使用宏macro: <@mo />
  <#macro moArgs a b c>
    定义带参数的宏macro-- ${a+b+c}
  </#macro>
    使用带参数的宏macro: <@moArgs a=1 b=2 c=3 />

命名空间：
  <#import "otherFreeMarker.ftl" as otherFtl>
  ${otherFtl.otherName}
  <@otherFtl.addMethod a=10 b=20 />
  <#assign otherName="修改otherFreeMarker.ftl中的otherName变量值"/>
  ${otherFtl.otherName}
  <#assign otherName="修改otherFreeMarker.ftl中的otherName变量值" in otherFtl />
  ${otherFtl.otherName}
```
</details>
</details>
</details>

## Spring Boot
<details>
<summary>Spring Boot</summary>
<details>
<summary>Dependency</summary>

---
### Dependency :monkey:
---
<details>
<summary>各依赖介绍</summary>

#### Spring Web
集成了Tomcat、SpringMVC、RESTful
#### DevTools
代码修改热更新，无需重启
监控程序的变化，然后进行自动重新启动
#### Lombok
消除模板代码
getter、setter、构造器、toString()、equals()等
在运行过程中，自动生成，注解后便可直接调用
  - 注解介绍
    ```properties
    @NonNull : 让你不在担忧并且爱上NullPointerException

    @CleanUp : 自动资源管理：不用再在finally中添加资源的close方法

    @Setter/@Getter : 自动生成set和get方法

    @ToString : 自动生成toString方法

    @EqualsAndHashcode : 从对象的字段中生成hashCode和equals的实现

    @NoArgsConstructor/@RequiredArgsConstructor/@AllArgsConstructor:自动生成构造方法

    @Data : 自动生成set/get方法，toString方法，equals方法，hashCode方法，不带参数的构造方法

    @Value : 用于注解final类

    @Builder : 产生复杂的构建器api类

    @SneakyThrows : 异常处理（谨慎使用）

    @Synchronized : 同步方法安全的转化

    @Getter(lazy=true) :
        （1）该标注用于生成一个 lazy 版的 getter，它会在第一次调用这个 getter 时计算一次值，然后从那里开始缓存它。如果计算该值需要大量 CPU，或者该值占用大量内存，这可能很有用。
        注意：Lombok 会自动去管理线程安全的问题，所以不会存在重复赋值的问题。
        （2）要使用此功能，需要创建一个 private final 变量，并且使用运行成本高的表达式对其进行初始化，同时使用 @Getter(lazy=true) 注解进行标注。
        示例

    @Log : 支持各种logger对象，使用时用对应的注解，如：@Log4j

    使用技巧:
        在 Bean / Entity 类上使用 @Data 注解。
        需要使用 Log 对象的地方使用 @Log4j（依项目日志框架决定）。
        注意：lombok 的注解不能被继承。
    ```
#### Spring Configuration Processor
让配置文件有提示
使用其他配置文件xml或properties
  - 示例
使用 @EnableConfigurationProperties开启 @ConfigurationProperties注解
    ```java
    @Data
    @Component
    @ConfigurationProperties(prefix = "author")
    @PropertySource(value = {"classpath:demo.properties" }, ignoreResourceNotFound = false, encoding = "UTF-8", name = "demo.properties")
    public class Demo {
      private String name;
      private int age;
    }
    ```
    ```java
    @RestController
    @EnableConfigurationProperties
    public class DemoController {
        @Autowired
        Demo demo;
        @RequestMapping("/")
        public String index(){
            return "author's name is " + demo.getName() + ",ahtuor's age is " + demo.getAge();
        }
    }
    ```
    使用 @Value 需要注入的值较多时，代码就会显得冗余，于是 @ConfigurationProperties登场了
    ```java
    @Data
    @Component
    @PropertySource(value = {"classpath:static/config/demo.properties" }, ignoreResourceNotFound = false, encoding = "UTF-8", name = "demo.properties")
    public class AuthorTest {
        @Value ("${author.name}") 
        private String name;
        @value ("${author. age}"
        private int age;
    }
    ```
#### Spring Session
- 为什么使用
布式应用和集群应用中，用户的请求可能被负载分发至不同的服务器，此时传统的web容器管理用户会话session的方式即行不通。除非集群或者分布式web应用能够共享session，尽管tomcat等支持这样做。但是这样存在以下两点问题：
  - 需要侵入web容器，提高问题的复杂
  - web容器之间共享session，集群机器之间势必要交互耦合
- session容器
  - 使用第三方仓储来实现集群session管理，也就是常说的分布式session容器，替换应用容器（如tomcat的session容器）。仓储的实现，Spring Session提供了三个实现（redis，mongodb，jdbc），其中redis使我们最常用的。
  - 可以非常方便的扩展Cookie和自定义Session相关的Listener，Filter。
  - 可以很方便的与Spring Security集成，增加诸如findSessionsByUserName，rememberMe，限制同一个账号可以同时在线的Session数（如设置成1，即可达到把前一次登录顶掉的效果）等等

- Spring Reactive Web
  - Spring 的reactive web框架：webflux
  - spring-webflux
    - spring-webflux与spring-webmvc平级
    - webmvc是servlet stack  based,而webflux是reactive stack based。
    - webflux是一个完全的reactive并且非阻塞的web框架。
    - flux：“流”的意思（stream, flux, rate, class, blast, grade）
作用：就是webflux可以让你在web应用下也可以体验tcp长连接传输流数据的快感了。这在过去我们都是通过一些奇技淫巧才能实现的能力。
</details>
</details>
<details>
<summary>Files Introduce</summary>

---
### Files Introduce :monkey:
---
<details>
<summary>各文件介绍</summary>

#### mvnw
- 作用:
mvnw是一个maven wrapper script,它可以让你在没有安装maven或者maven版本不兼容的条件下运行maven的命令.
**注意，需要与mvnw软件区分开，spring项目中的mvnw仅仅是个脚本，并非软件。**
- 原理:
  1. 首先寻找maven在你电脑环境变量path中的路径
  2. 如果没有找到这个路径它就会自动下载maven到一个默认的路径下,之后你就可以运行maven命令
  3. 如果碰到一些项目的peoject和你本地的maven不兼容,它会帮你下载合适的maven版本,然后运行
####mvnw.cmd
- 执行mvnw脚本的cmd入口
####.gitignore
- 分布式版本控制系统git的配置文件，意为忽略提交
- 在.gitingore 文件中，遵循相应的语法，在每一行指定一个忽略规则
</details>
</details>
<details>
<summary>application.properties</summary>

---
### application.properties :monkey:
---
<details>
<summary>各组件配置文件</summary>

#### Spring MVC
```properties
# 异步请求处理超时之前的时间量（以毫秒为单位）
spring.mvc.async.request-timeout=
# 要使用的日期格式 例如`dd / MM / yyyy`
spring.mvc.date-format=
# 发送TRACE请求到FrameworkServlet doService方法
spring.mvc.dispatch-trace-request= false
# 发送OPTIONS请求到FrameworkServlet doService方法
spring.mvc.dispatch-options-request= false
# 启用favicon.ico的解析
spring.mvc.favicon.enabled= true
# 如果在重定向方案期间应该忽略“默认”模型的内容
spring.mvc.ignore-default-model-on-redirect= true
# 要使用的区域设置
spring.mvc.locale=
# 将文件扩展名映射到内容协商的媒体类型
spring.mvc.media-types.*=
# 消息代码格式策略 例如`PREFIX_ERROR_CODE`
spring.mvc.message-codes-resolver-format=
# 用于静态资源的路径模式
spring.mvc.static-path-pattern= /**
# 如果没有发现处理程序来处理请求，则应抛出“NoHandlerFoundException”
spring.mvc.throw-exception-if-no-handler-found= false
# Spring MVC视图前缀
spring.mvc.view.prefix=
# Spring MVC视图后缀
spring.mvc.view.suffix=
```
#### FreeMarker
```properties
spring.freemarker.allow-request-override=false
设置是否允许HttpServletRequest属性覆盖(隐藏)控制器生成的同名模型属性。
spring.freemarker.allow-session-override=false
设置是否允许HttpSession属性覆盖(隐藏)控制器生成的同名模型属性。
spring.freemarker.cache=false
启用模板缓存
spring.freemarker.charset=UTF-8
设置编码格式
spring.freemarker.check-template-location=true
检查模板位置是否存在。
spring.freemarker.content-type=text/html
内容类型值
spring.freemarker.enabled=true
为这种技术启用MVC视图解决方案。
spring.freemarker.expose-request-attributes=false
设置是否应该在与模板合并之前将所有请求属性添加到模型中。
spring.freemarker.expose-session-attributes=false
设置是否在与模板合并之前将所有HttpSession属性添加到模型中。
spring.freemarker.expose-spring-macro-helpers=true
设置是否公开RequestContext供Spring宏库使用，名称为“SpringMacroRequestContext”。
spring.freemarker.prefer-file-system-access=true
更喜欢文件系统访问模板加载。文件系统访问允许对模板更改进行热检测。
spring.freemarker.prefix=
前缀，用于在构建URL时查看名称
spring.freemarker.request-context-attribute=
所有视图的RequestContext属性的名称。
spring.freemarker.settings.*=
众所周知的FreeMarker密钥将传递给FreeMarker的配置。
spring.freemarker.suffix=
后缀，该后缀用于在构建URL时查看名称。
spring.freemarker.template-loader-path=classpath:/templates/
以逗号分隔的模板路径列表。
spring.freemarker.view-names=
可以解析的视图名称的白列表。
```
#### Thymeleaf
```properties
spring.thymeleaf.cache = true #启用模板缓存
spring.thymeleaf.check-template-location = true #检查模板位置是否存在
spring.thymeleaf.content-type = text / html #Content-Type值
spring.thymeleaf.enabled = true #启用MVC Thymeleaf视图分辨率
spring.thymeleaf.encoding = UTF-8 #模板编码
spring.thymeleaf.excluded-view-names = #应该从解决方案中排除的视图名称的逗号分隔列表
spring.thymeleaf.mode = HTML5 #应用于模板的模板模式另请参见

StandardTemplateModeHandlers
spring.thymeleaf.prefix = classpath：/ templates / #在构建URL时预先查看名称的前缀
spring.thymeleaf.suffix = .html #构建URL时附加查看名称的后缀
spring.thymeleaf.template-resolver-order = #链中模板解析器的顺序
spring.thymeleaf.view-names = #可以解析的视图名称的逗号分隔列表
```
#### DataSource
```properties
spring.datasource.continue-on-error = false #初始化数据库时发生错误时不要停止
spring.datasource.data = #Data（DML）脚本资源引用
spring.datasource.driver-class-name = #JDBC驱动程序的完全限定名称默认情况下，根据URL自动检测
spring.datasource.initialize = true #使用'data.sql'填充数据库
spring.datasource.jmx-enabled = false #启用JMX支持（如果由底层池提供）
spring.datasource.jndi-name = #数据源的JNDI位置设置时，类，网址，用户名和密码将被忽略
spring.datasource.max-active = #例如100
spring.datasource.max-idle = #例如8
spring.datasource.max等待=
spring.datasource.min-evictable空闲时间-米利斯=
spring.datasource.min-idle = 8
spring.datasource.name = testdb #数据源的名称
spring.datasource.password = #登录数据库的密码
spring.datasource.platform = all #在资源模式（schema - $ {platform} .sql）中使用的平台
spring.datasource.schema = #Schema（DDL）脚本资源引用
spring.datasource.separator =;  #语句分隔符在SQL初始化脚本中
spring.datasource.sql-script-encoding = #SQL脚本编码
spring.datasource.test-on-borrow = #例如`false`
spring.datasource.test-on-return = #例如`false`
spring.datasource.test-while-idle = #
spring.datasource.time-between-eviction-runs-millis = 1
spring.datasource.type = #要使用的连接池实现的完全限定名称默认情况下，它是从类路径自动检测的
spring.datasource.url = #数据库的JDBC url
spring.datasource.username=
spring.datasource.validation-query=
```
#### Redis
```properties
# 连接工厂使用的数据库索引
spring.redis.database= 0
# Redis服务器主机
spring.redis.host= localhost
# 登录redis服务器的密码
spring.redis.password=
# 给定时间池可以分配的最大连接数 使用负值为无限制
spring.redis.pool.max-active= 8
# 池中“空闲”连接的最大数量 使用负值来表示无限数量的空闲连接
spring.redis.pool.max-idle= 8
# 连接分配在池耗尽之前在抛出异常之前应阻止的最大时间量（以毫秒为单位） 使用负值无限期地阻止
spring.redis.pool.max-wait= -1
# 定义池中维护的最小空闲连接数 此设置只有在正值时才有效果
spring.redis.pool.min-idle= 0
# redis服务器端口
spring.redis.port= 6379
# redis服务器名称
spring.redis.sentinel.master=
#
spring.redis.sentinel.nodes=
# 连接超时（毫秒）
spring.redis.timeout= 0
```
#### JMS
```properties
# 连接工厂JNDI名称 设置时，优先于其他连接工厂自动配置
spring.jms.jndi-name=
# 容器的确认模式 默认情况下，监听器被自动确认处理
spring.jms.listener.acknowledge-mode=
# 启动时自动启动容器
spring.jms.listener.auto-startup= true
# 最小并发消费者数
spring.jms.listener.concurrency=
# 最大并发消费者数
spring.jms.listener.max-concurrency=
# 指定默认的目的地类型是否为主题
spring.jms.pub-sub-domain= false
```
#### DEVTools
```properties
# DEVTOOLS（开发工具属性）
# 启用一个livereload.com兼容的服务器
spring.devtools.livereload.enabled= true
#  # Server port.
spring.devtools.livereload.port= 35729
# 应该排除的触发完全重新启动的其他模式
spring.devtools.restart.additional-exclude=
# 观看更改的附加路径
spring.devtools.restart.additional-paths=
# 启用自动重启功能
spring.devtools.restart.enabled= true
# 应该排除的模式触发完全重新启动
spring.devtools.restart.exclude= META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties
# 轮询类路径更改之间等待的时间量（以毫秒为单位）
spring.devtools.restart.poll-interval= 1000
# 触发重新启动之前没有任何类路径更改所需的安静时间量（以毫秒为单位）
spring.devtools.restart.quiet-period= 400
# 更改后的特定文件的名称将触发重新启动检查 如果未指定任何类路径文件更改将触发重新启动
spring.devtools.restart.trigger-file=
Spring batch
spring.batch.initializer.enabled = true #如果需要，在启动时创建所需的批处理表
spring.batch.job.enabled = true #在启动时执行上下文中的所有Spring批处理作业
spring.batch.job.names = #在启动时执行的作业名称的逗号分隔列表（例如`job1，job2`） 默认情况下，执行在上下文中找到的所有作业
spring.batch.schema = classpath：org / springframework / batch / core / schema - @@ platform @@sql #用于初始化数据库模式的SQL文件的路径
spring.batch.table-prefix = #所有批次元数据表的表前缀
```
#### 远程开发工具
```properties
# 用于处理远程连接的上下文路径
spring.devtools.remote.context-path= /.~~spring-boot!~
# 启用远程调试支持
spring.devtools.remote.debug.enabled= true
# 本地远程调试服务器端口
spring.devtools.remote.debug.local-port= 8000
# 用于连接到远程应用程序的代理主机
spring.devtools.remote.proxy.host=
# 用于连接到远程应用程序的代理端口
spring.devtools.remote.proxy.port=
# 启用远程重启
spring.devtools.remote.restart.enabled= true
# 建立连接所需的共享密钥（需要启用远程支持）
spring.devtools.remote.secret=
# HTTP头用于传输共享密钥</ span>
spring.devtools.remote.secret-header-name= X-AUTH-TOKEN
```
</details>
</details>
</details>

      
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
