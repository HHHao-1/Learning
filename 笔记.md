<center><font size=7><b>HHHAo的笔记本 📒</b></font></center>


# 版本控制
## Git 
### GIT原理

#### 1. 工作流

```css
克隆 Git 资源作为工作目录。
在克隆的资源上添加或修改文件。
如果其他人修改了，你可以更新资源。
在提交前查看修改。
提交修改。
在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。
```
![59c31e4400013bc911720340](https://tva1.sinaimg.cn/large/007S8ZIlly1gf9fhb12v0j30wk09gdg2.jpg)


### 快速使用


```shell
$ git init

$ git add 文件名

# 添加当前目录的所有文件到暂存区
$ git add .

$ git commmit -m  "代码提交信息"

$ git remote add origin(远程仓库名) 链接

$ git push origin master

$ git push origin HEAD:test

$ git pull [remote] [branch]

$ git status

$ git log

# 下载远程仓库的所有变动
$ git fetch [remote]

# 管理远程仓库
$ git remote rm origin
$ git remote set-url origin 链接
$ git remote -v

#克隆:本地/远程SSH/远程HTTPS
$ git clone /path/to/repository
$ git clone username@host:/path/to/repository
$ git clone 连接地址
```


### Git命令大全

#### 1. 新建代码库

```shell
# 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
```
#### 2. 配置
```shell
# 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name "[name]"
$ git config [--global] user.email "[email address]"
```
#### 3. 增加/删除文件
```shell
# 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
```
#### 4. 代码提交

```shell
# 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
```
#### 5. 分支

```shell
# 列出所有本地分支
$ git branch
 
# 列出所有远程分支
$ git branch -r
 
# 列出所有本地分支和远程分支
$ git branch -a
 
# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]
 
# 新建一个分支，并切换到该分支
$ git checkout -b [branch]
 
# 新建一个分支，指向指定commit
$ git branch [branch] [commit]
 
# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]
 
# 切换到指定分支，并更新工作区
$ git checkout [branch-name]
 
# 切换到上一个分支
$ git checkout -
 
# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]
 
# 合并指定分支到当前分支
$ git merge [branch]
 
# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]
 
# 删除分支
$ git branch -d [branch-name]
 
# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
```
#### 6. 标签

```shell
# 列出所有tag
$ git tag
 
# 新建一个tag在当前commit
$ git tag [tag]
 
# 新建一个tag在指定commit
$ git tag [tag] [commit]
 
# 删除本地tag
$ git tag -d [tag]
 
# 删除远程tag
$ git push origin :refs/tags/[tagName]
 
# 查看tag信息
$ git show [tag]
 
# 提交指定tag
$ git push [remote] [tag]
 
# 提交所有tag
$ git push [remote] --tags
 
# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
```
#### 7.远程同步

```shell
# 下载远程仓库的所有变动
$ git fetch [remote]
 
# 显示所有远程仓库
$ git remote -v
 
# 显示某个远程仓库的信息
$ git remote show [remote]
 
# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]
 
# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]
 
# 上传本地指定分支到远程仓库
$ git push [remote] [branch]
 
# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force
 
# 推送所有分支到远程仓库
$ git push [remote] --all
```
#### 8. 查看信息

```shell
# 显示有变更的文件
$ git status
 
# 显示当前分支的版本历史
$ git log
 
# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat
 
# 搜索提交历史，根据关键词
$ git log -S [keyword]
 
# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s
 
# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件
$ git log [tag] HEAD --grep feature
 
# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]
 
# 显示指定文件相关的每一次diff
$ git log -p [file]
 
# 显示过去5次提交
$ git log -5 --pretty --oneline
 
# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn
 
# 显示指定文件是什么人在什么时间修改过
$ git blame [file]
 
# 显示暂存区和工作区的差异
$ git diff
 
# 显示暂存区和上一个commit的差异
$ git diff --cached [file]
 
# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD
 
# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]
 
# 显示今天你写了多少行代码
$ git diff --shortstat "@{0 day ago}"
 
# 显示某次提交的元数据和内容变化
$ git show [commit]
 
# 显示某次提交发生变化的文件
$ git show --name-only [commit]
 
# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]
 
# 显示当前分支的最近几次提交
$ git reflog

#查看用户名和邮箱地址
$ git config user.name
$ git config user.email

#修改用户名和邮箱地址
$  git config --global user.name  "xxxx"
S  git config --global user.email  "xxxx"
```
#### 9. 撤销

```shell
# 恢复暂存区的指定文件到工作区
$ git checkout [file]
 
# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]
 
# 恢复暂存区的所有文件到工作区
$ git checkout .
 
# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]
 
# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard
 
# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]
 
# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]
 
# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]
 
# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]
 
# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
```
#### 10. 忽略文件
**.gitignore忽略优先级**

```css
在 .gitingore 文件中，每一行指定一个忽略规则，Git 检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：
- 从命令行中读取可用的忽略规则
- 当前目录定义的规则
- 父级目录定义的规则，依次递推
- $GIT_DIR/info/exclude 文件中定义的规则
- core.excludesfile中定义的全局规则
```

  **.gitignore匹配语法**

```css
在 .gitignore 文件中，每一行的忽略规则的语法如下：
- 空格不匹配任意文件，可作为分隔符，可用反斜杠转义
- \# 开头的文件标识注释，可以使用反斜杠进行转义
- ! 开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用 ! 也不会再次被包含。可以使用反斜杠进行转义
- / 结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件
- / 开始的模式匹配项目跟目录
- 如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录
- ** 匹配多级目录，可在开始，中间，结束
- ? 通用匹配单个字符
- [] 通用匹配单个字符列表
```
**常用匹配示例**

```css
- bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件
- /bin: 忽略根目录下的bin文件
- /*.c: 忽略 cat.c，不忽略 build/cat.c
- debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj
- **/foo: 忽略/foo, a/foo, a/b/foo等
- a/**/b: 忽略a/b, a/x/b, a/x/y/b等
- !/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件
- *.log: 忽略所有 .log 文件
- config.php: 忽略当前路径的 config.php 文件
```
**忽略不生效**
		.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决方法就是先把本地缓存删除（改变成未track状态），然后再提交:

```shell
git rm -r --cached .``git add .``git commit -m ``'update .gitignore'
```

### 问题记录

#### 1. github无法显示图片

- 输入raw.githubusercontent.com查询IP地址
- 修改hosts文件:sudo vi /etc/hosts
- 添加以下内容保存即可 （IP地址查询后相应修改，可以ping不同IP的延时 选择最佳IP地址）
```css
# GitHub Start
52.74.223.119 github.com
192.30.253.119 gist.github.com
54.169.195.247 api.github.com
185.199.111.153 assets-cdn.github.com
151.101.76.133 raw.githubusercontent.com
151.101.108.133 user-images.githubusercontent.com
151.101.76.133 gist.githubusercontent.com
151.101.76.133 cloud.githubusercontent.com
151.101.76.133 camo.githubusercontent.com
151.101.76.133 avatars0.githubusercontent.com
151.101.76.133 avatars1.githubusercontent.com
151.101.76.133 avatars2.githubusercontent.com
151.101.76.133 avatars3.githubusercontent.com
151.101.76.133 avatars4.githubusercontent.com
151.101.76.133 avatars5.githubusercontent.com
151.101.76.133 avatars6.githubusercontent.com
151.101.76.133 avatars7.githubusercontent.com
151.101.76.133 avatars8.githubusercontent.com
# GitHub End
```

## SVN 

### SVN 原理
#### SVN 简介
Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。

##### 1. SVN 的一些概念
**repository（源代码库）**:源代码统一存放的地方

**Checkout（提取）**:当你手上没有源代码的时候，你需要从repository checkout一份

**Commit（提交）**:当你已经修改了代码，你就需要Commit到repository

**Update（更新）**:当你已经Checkout了一份源代码， Update一下你就可以和Repository上的源代码同步，你手上的代码就会有最新的变更

**日常工作流程**：Checkout（克隆,一段时间后）--> Update(获得最新的代码) -->  作出自己的修改并调试成功 --> Commit(大家就可以看到你的修改了) 。

**Conflict（冲突）**: 如果两个程序员同时修改了同一个文件呢, SVN 可以合并这两个程序员的改动，实际上SVN管理源代码是以行为单位的，就是说两个程序员只要不是修改了同一行程序，SVN都会自动合并两种修改。如果是同一行，SVN 会提示文件 Conflict,冲突，需要手动确认。

##### 2. SVN 工作流程
**创建版本库**

```css
版本库相当于一个集中的空间，用于存放开发者所有的工作成果。版本库不仅能存放文件，还包括了每次修改的历史，即每个文件的变动历史。

Create 操作是用来创建一个新的版本库。大多数情况下这个操作只会执行一次。当你创建一个新的版本库的时候，你的版本控制系统会让你提供一些信息来标识版本库，例如创建的位置和版本库的名字。
```

**检出**

```css
Checkout 操作是用来从版本库创建一个工作副本。工作副本是开发者私人的工作空间，可以进行内容的修改，然后提交到版本库中。
```
**更新**

```css
Update 操作是用来更新版本库的。这个操作将工作副本与版本库进行同步。由于版本库是由整个团队共用的，当其他人提交了他们的改动之后，你的工作副本就会过期。
```

**执行变更**

```css
当检出之后，你就可以做很多操作来执行变更。编辑是最常用的操作。你可以编辑已存在的文件，例如进行文件的添加/删除操作。

你可以添加、删除、Rename、移动文件/目录。但是这些变更的文件目录不会立刻成为版本库的一部分，而是被添加进待变更列表中，直到执行了 commit 操作后才会成为版本库的一部分。
```

**复查变化**

```css
当你检出工作副本或者更新工作副本后，你的工作副本就跟版本库完全同步了。但是当你对工作副本进行一些修改之后，你的工作副本会比版本库要新。在 commit 操作之前复查下你的修改是一个很好的习惯。

Status 操作列出了工作副本中所进行的变动。正如我们之前提到的，你对工作副本的任何改动都会成为待变更列表的一部分。Status 操作就是用来查看这个待变更列表。

Status 操作只是提供了一个变动列表，但并不提供变动的详细信息。你可以用 diff 操作来查看这些变动的详细信息。
```

**修复错误**

```css
我们来假设你对工作副本做了许多修改，但是现在你不想要这些修改了，这时候 revert 操作将会帮助你。

Revert 操作重置了对工作副本的修改。它可以重置一个或多个文件/目录。当然它也可以重置整个工作副本。在这种情况下，revert 操作将会销毁待变更列表并将工作副本恢复到原始状态。
```

**解决冲突**

```css
合并的时候可能会发生冲突。Merge 操作会自动处理可以安全合并的东西。其它的会被当做冲突。例如，"hello.c" 文件在一个分支上被修改，在另一个分支上被删除了。这种情况就需要人为处理。Resolve 操作就是用来帮助用户找出冲突并告诉版本库如何处理这些冲突。
```

**提交更改**

```css
Commit 操作是用来将更改从工作副本到版本库。这个操作会修改版本库的内容，其它开发者可以通过更新他们的工作副本来查看这些修改。

在提交之前，你必须将文件/目录添加到待变更列表中。列表中记录了将会被提交的改动。当提交的时候，我们通常会提供一个注释来说明为什么会进行这些改动。这个注释也会成为版本库历史记录的一部分。

Commit 是一个原子操作，也就是说要么完全提交成功，要么失败回滚。用户不会看到成功提交一半的情况。
```

### 快速使用

```shell
svnadmin create /Users/apple/svn/mycode

svnserve -d -r /path/svn  

#初始化导入svn服务器
svn import /Users/apple/webSite svn://localhost/mycode/webSite --username=mj --password=123 -m "初始化导入"

svn checkout svn://localhost/mycode --username=mj --password=123 /Users/apple/svnwebSite

#提交更改过的代码到服务器
cd /Users/apple/svnwebSite
svn commit -m "修改了webSite文件"

#更新服务器端的代码到客户端
cd /Users/apple/svnwebSite
svn update

svn help
svnserve --version
```
### 配置及启动

**手动新建版本库目录**

```shell
mkdir /opt/svn
```

**创建版本库**

```shell
svnadmin create /opt/svn/runoob
```

**修改仓库配置**

修改conf文件夹下的svnserve.conf文件
```properties
[general]
#anon-access = none，这样禁止匿名访问，需要帐号密码才能访问
anon-access = none
auth-access = write
password-db = passwd
authz-db = authz
[sasl]
```

修改conf下的passwd文件，在[users]后面加入用户和密码
```css
  administrator = admin@Svnserver
  xiayong = xiayong
```

**启动svn服务**

> svnserve -d -r 目录 --log-file=/var/log/svn.log --listen-port 端口号
>

```css
-r: 配置方式决定了版本库访问方式。

--log-file=/var/log/svn.log: 指定日志路径

--listen-port: 指定SVN监听端口，不加此参数，SVN默认监听3690
```

> 两种启动方式：由于-r 配置方式的不一样，SVN启动就可以有两种不同的访问方式
>

> 方式一：
>

-r直接指定到版本库(称之为单库svnserve方式)，一个svnserve只能为一个版本库工作

```shell
svnserve -d -r /opt/svn/runoob
```
authz配置文件中对版本库权限的配置应这样写：
```properties
[groups]
admin=user1
dev=user2
[/]
@admin=rw
user2=r
```

使用类似这样的URL：svn://192.168.0.1/　即可访问runoob版本库

> 方式二：

指定到版本库的上级目录(称之为多库svnserve方式)，一个svnserve可以为多个版本库工作

```shell
svnserve -d -r /opt/svn
```


authz配置文件中对版本库权限的配置应这样写：

```properties
[groups]
admin=user1
dev=user2
[runoob:/]
@admin=rw
user2=r
[runoob01:/]
@admin=rw
user2=r
```
如果此时你还用[/]，则表示所有库的根目录，同理，[/src]表示所有库的根目录下的src目录。

使用类似这样的URL：svn://192.168.0.1/runoob　即可访问runoob版本库。

**启动测试(可选)**

```shell
telnet localhost 3690
```

**创建默认目录结构(可选)**

首先在本地把目录结构建立好
```shell
$ sudo mkdir -p /tmp/svntemp
$ cd /tmp/svntemp/
$ sudo mkdir tags trunk branches

1.trunk是主分支，是日常开发进行的地方。
2.branches是分支。一些阶段性的release版本，这些版本是可以继续进行开发和维护的，则放在branches目录中。又比如为不同用户客制化的版本，也可以放在分支中进行开发。
3.tags目录一般是只读的，这里存储阶段性的发布版本，只是作为一个里程碑的版本进行存档。
```

接下来将本地目录结构导入到我们的svn仓库中
```shell
$ sudo svn import -m 'init repo' /tmp/svntemp/ svn://localhost/local
Authentication realm: <svn://localhost:3690> af662c40-23bf-43f4-93fa-8bf7eff40771
Password for 'root':
Authentication realm: <svn://localhost:3690> af662c40-23bf-43f4-93fa-8bf7eff40771
Username: administrator
Password for 'administrator':
Adding         /tmp/svntemp/trunk
Adding         /tmp/svntemp/branches
Adding         /tmp/svntemp/tags
Committed revision 1.
```
我是使用administrator这个用户导入的，因为目前只有这个用户才有权限。

现在我们的svn服务器已经可以用了，可以使用svn://localhost/local来访问我们的local这个仓库，当然不要忘记了，我们刚才新添加了目录，需要修改权限。
```properties
[local:/branches]
@user = rw
[local:/tags]
@user = r
[local:/trunk]
@user = rw
```

**svn开机启动（可选）**

编辑/etc/rc.local文件，在这个文件中加入以下内容(此文件在Mac系统中是没有的，需要手动创建)
```shell
# to run the svnserver on the automatically.
svnserve -d -r /data/svn/repositories
```

### 问题记录

```shell
#linux 下停止所有的svn服务
killall svnserve

#windows 下停止svn服务
net stop svn 【停止服务】

#windows 下删除svn服务
sc delete svn 【删除服务】

#启动认证失败
#删除认证缓存设置即可
rm -rf ~/.subversion/auth
```
#### 1. apache+svn

**mac系统在Apache中安装SVN插件**

编辑 /etc/apache2/httpd.conf 这个文件，确保该文件中有以下配置项(若没有，请加上，若注释掉的请取消注释)。注意，编辑此文件需要root权限。

```css
LoadModule dav_module libexec/apache2/mod_dav.so
LoadModule dav_fs_module libexec/apache2/mod_dav_fs.so
LoadModule dav_svn_module libexec/apache2/mod_dav_svn.so
LoadModule authz_svn_module libexec/apache2/mod_authz_svn.so
```

确认 /usr/libexec/apache2/ 目录下有上面配置项里的4个.so文件，`mod_dav``.so和mod_dav_fs.so这两个文件应该已经存在，mod_dav_svn.so和mod_authz_svn.so这两个文件需要到svn安装目录去拷贝。我假设你将svn安装在 /opt/subversion/ 下，使用如下命令拷贝文件，如果你的svn不是安装在这里，请到你的目录下面拷贝`

```bash
$ sudo cp /opt/subversion/lib/svn-apache/mod_dav_svn.so /usr/libexec/apache2/
$ sudo cp /opt/subversion/lib/svn-apache/mod_authz_svn.so /usr/libexec/apache2/
```

``

**在Apache中配置SVN**

```css
创建 /etc/apache2/other/svn.conf 这个文件，注意使用root权限才可以。
在此文件中加入以下配置
<Location /svn>
    DAV svn
    SVNParentPath /usr/local/data/svn/repositories
    SVNListParentPath on
    AuthType Basic
    AuthName "Subversion repositories"
    AuthUserFile /usr/local/data/svn/repositories/passwd
    AuthzSVNAccessFile /usr/local/data/svn/repositories/authz
    Require valid-user
</Location>
```

简单解释一下此配置

```css
SVNParentPath 目录指向我们svn仓库的上一级目录，这个目录下面的每个文件夹都会作为一个仓库。注意：我后来已经将仓库移动到了/usr/local/data/svn/repositories下面，如果大家按照我上一篇博文来配置的SVN仓库，这里的配置请改成你的SVN仓库的地址！

AuthUserFile 该配置指向svn用户配置文件

AuthzSVNAccessFile 该配置指向svn权限配置文件

AuthUserFile 和 AuthzSVNAccessFile这两个配置项建议不要指向原来仓库的配置文件，建议创建新的，SVN仓库中的配置文件只作用于某个仓库，而这里指向的配置文件作用于所有的仓库。
```

**创建用户、验证配置**

使用htpasswd命令添加用户

```bash
$ sudo htpasswd -c /usr/local/data/svn/repositories/passwd admin
New password:
Re-type new password:
Adding password for user admin
```

我们成功的添加了一个用户 admin， 并为其初始化了密码，首次添加用户使用了 -c 这个参数，以后可以不加此参数。/usr/local/data/svn/repositories/passwd是在 /etc/apache2/other/svn.conf 文件中AuthUserFile配置项指向的文件。刚添加的admin这个用户就写入了这个文件中。另外请手动在 /usr/local/data/svn/repositories/authz 为此用户配置权限。

**启动**

使用如下命令重启Apache

```bash
$ sudo apachectl restart
```

打开浏览器，在地址栏中访问http://localhost/svn/你将看到浏览器弹出了密码框让我们输入用户名密码。



# 模板引擎

## 简介 

**概述**

一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。

**Thymeleaf与FreeMarker比较**

1. Thymeleaf（Html里写模板）

```css
优点：

静态html嵌入标签属性，浏览器可以直接打开模板文件，便于前后端联调

动静结合
Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。

与SpringBoot完美整合
SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。
```

```css
缺点

模板必须符合xml规范

js脚本必须加入/*<![CDATA[*/标识，否则一个&符号就会导致后台模板合成抛异常，而且错误信息巨不友好，害得我调试了好几个小时才明白是怎么回事。

js里面还好办，这样是在html里面含有&等符号，还需要转义？忒麻烦了！Thymaleaf的自定义方法较难实现完美的数据转换
```

2. FreeMarker（模板里写Html）

```css
优点：

严格的 MVC (模型 视图 控制器) 模式
宏的强大和自定义节点转换方法函数适合特殊、复杂数据的转化
```

```css
缺点
前后端联调不方便
```

## Tymeleaf 

### 快速使用
**我们的表达式写在一个名为：th:text的标签属性中，这个叫做指令**

```html
<!-- 引入命名空间前缀 -->
<html lang="en" xmlns:th="http://www.thymeleaforg">
<!-- 取值：先在request中找，然后session，再servlet context -->
<body>
  <h1 th:text="${msg}">test</h1>
</body>
```
```java
// 后台model将数据写入request
@GetMapping("test2")
public String test2(Model model){
    User user = new User();
    user.setAge(21);
    user.setName("Jackson");
    user.setFriend(new User("李小龙", 30));
    model.addAttribute("user", user);
    return "hello2";
}
```
```java
 String msg = "<h1>啦啦啦</h1>";
```
```html
th:text与th:utexte区别
<!-- 用th:text不会解析html，用th:utext会解析html，在页面中显示相应的样式 -->
 <p th:text="采用text标签： + ${msg}"></p>
<!-- 采用text标签：<h1>啦啦啦</h1> -->
 <p th:utext="采用utext标签： + ${msg}"></p>
<!-- 采用utext标签：
     啦啦啦 -->
```
### 语法
**变量（取值）、方法、条件判断、循环、运算、逻辑运算、布尔运算、比较运算、条件运算、其它**

```html
变量
<!-- 
如果不支持这种th:的命名空间写法，那么可以把th:text换成 data-th-text
获取变量值，我们使用的是经典的对象.属性名方式。
有些情况下，我们的属性名可能本身也是变量：例如：${user.name} 可以写作${user['name']}
 -->

变量_自定义变量
<h2>
    <p>Name: <span th:text="${user.name}">Jack</span>.</p>
    <p>Age: <span th:text="${user.age}">21</span>.</p>
    <p>friend: <span th:text="${user.friend.name}">Rose</span>.</p>
</h2>
<!-- 我们获取用户的所有信息，分别展示。
当数据量比较多的时候，频繁的写user.就会非常麻烦。因此，Thymeleaf提供了自定义变量来解决 -->
<h2 th:object="${user}">
    <p>Name: <span th:text="*{name}">Jack</span>.</p>
    <p>Age: <span th:text="*{age}">21</span>.</p>
    <p>friend: <span th:text="*{friend.name}">Rose</span>.</p>
</h2>
<!-- 首先在 h2上 用 th:object="${user}"获取user的值，并且保存
然后，在h2内部的任意元素上，可以通过 *{属性名}的方式，来获取user中的属性，这样就省去了大量的user.前缀了 -->

方法

方法_拼接
<span th:text="'欢迎您:' + ${user.name} + '!'"></span>
<!-- 字符串字面值需要用''，拼接起来非常麻烦，Thymeleaf对此进行了简化，使用一对|即可： -->
<span th:text="|欢迎您:${user.name}|"></span>

方法调用
<!-- ognl表达式本身就支持方法调用 -->
<h2 th:object="${user}">
    <p>FirstName: <span th:text="*{name.split(' ')[0]}">Jack</span>.</p>
    <p>LastName: <span th:text="*{name.split(' ')[1]}">Li</span>.</p>
</h2>
<!-- 这里我们调用了name（是一个字符串）的split方法。 -->

方法——内置对象：后面

运算
<span th:text="${user.sex} ? '男':'女'"></span>

循环
<tr th:each="user : ${users}">
    <td th:text="${user.name}">Onions</td>
    <td th:text="${user.age}">2.41</td>
</tr>
<tr th:each="user,stat : ${users}">
    <td th:text="${user.name}">Onions</td>
    <td th:text="${user.age}">2.41</td>
</tr>
<!-- 
stat对象包含以下属性：
index，从0开始的角标
count，元素的个数，从1开始
size，总元素个数
current，当前遍历到的元素
even/odd，返回是否为偶/奇，boolean值
first/last，返回是否为第一或最后，boolean值 
-->

逻辑判断if
<!-- 使用th:if 或者 th:unless ，两者的意思恰好相反。 -->
<!-- 如果表达式的值为true，则标签会渲染到页面，否则不进行渲染。 -->
<span th:if="${user.age} > 24">老油条</span>

分支控制switch
<!-- 需要注意的是，一旦有一个th:case成立，其它的则不再判断。与java中的switch是一样的。 -->
<!-- 另外th:case="*"表示默认，放最后。 -->
<div th:switch="${user.role}">
  <p th:case="'admin'">用户是管理员</p>
  <p th:case="'manager'">用户是经理</p>
  <p th:case="*">用户是别的玩意</p>
</div>

JS模板
<!-- 模板引擎不仅可以渲染html，也可以对JS中的进行预处理。为在纯静态环境下可以运行，Thymeleaf代码可被注释起来 -->
<!-- 在script标签中通过th:inline="javascript"来声明这是要特殊处理的js脚本 -->
<script th:inline="javascript">
    const user = /*[[${user}]]*/ {};
    const age = /*[[${user.age}]]*/ 20;
    console.log(user);
    console.log(age)
</script>
<!-- 语法结构：const user = /*[[Thymeleaf表达式]]*/ "静态环境下的默认值"; -->
<!-- 因为Thymeleaf被注释起来，因此即便是静态环境下， js代码也不会报错，而是采用表达式后面跟着的默认值。且User对象会被直接处理为json格式。 -->
```
**内置对象**

这些对象中提供了一些方法，方便我们来调用。获取这些对象，需要使用#对象名来引用。

**环境相关对象**

| 对象             | 作用                                      |
|---              |   ---                                     |
| #ctx            | 获取Thymeleaf自己的Context对象              |
| #requset        | 如果是web程序，可以获取HttpServletRequest对象 |
| #response       | 如果是web程序，可以获取HttpServletReponse对象 |
| #session        | 如果是web程序，可以获取HttpSession对象        |
| #servletContext | 如果是web程序，可以获取HttpServletContext对象 |
**全局对象**  

| 对象       | 作用                             |
| - | -- |
| #dates     | 处理java.util.date的工具对象     |
| #calendars | 处理java.util.calendar的工具对象 |
| #numbers   | 用来对数字格式化的方法           |
| #strings   | 用来处理字符串的方法             |
| #bools     | 用来判断布尔值的方法             |
| #arrays    | 用来护理数组的方法               |
| #lists     | 用来处理List集合的方法           |
| #sets      | 用来处理set集合的方法            |
| #maps      | 用来处理map集合的方法            |

### 应用
```java
@GetMapping("test3")
public String show3(Model model){
    model.addAttribute("today", new Date());
    return "hello3";
}
```
```html
<p>
  今天是: <span th:text="${#dates.format(today,'yyyy-MM-dd')}">2018-04-25</span>
</p>
```


## FreeMarker 

### 快速使用
**数据（java）+模板（ftl）= 结果（html）**

```html
这里是ftl文件
<!-- 先在request中找，然后session，再servlet context -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Insert title here</title>
  </head>
  <body>
    <h1>你好： ${username}</h1>
  </body>
</html>
```
```java
java后台整合
//1.加载模板、创建核心配置对象
Configuration configuration = new Configuration (configuration. VERSION_2_3_28);
//设置加载的目录
// 在本类所在包中加载ft1文件, "代表当前包的意思confiquration.setclassForTemplateLoading(本类.class.")
//设置编码
configuration. setDefaultEncoding "UTF-8" );
// 得到模板对象
Template template- confiquration.getTemplate ("demo.ft1");
//2.处理数据
Map-String, Object> data = new HashMap-String, Object>();
data.put ("site", "百度");
data.put ("ur","www.baidu.com");
// 3.产生输出
// System.out向控制台输出,是一个printStream字节流,要转换为字符流
template.process (data, new outputstreamwriter(System.out));
```
```css
站点：${site}-- 地址：${ur}}
```
### 语法
**变量（取值）、方法、条件判断、循环、运算、逻辑运算、布尔运算、比较运算、条件运算、其它**

```properties
取值
$ {属性名} 可对属性进行计算
$ {属性名!默认值} 使用默认
$ {属性名?string} 格式化输出

示例
    {date?string("yyyy年MM月dd日HH:mm:ss SSS)}
    {number?string("0.00"}
    SN:${computer.sn}
    型号:${computer.model}
    状态:${computer.state}
    用户:${computer.user}
    采购时间:${computer.dop?string("yyyy年MM月dd日)}
    采购价格:${computer.price?string("0.00"}
    配置信息:
        CPU:${computer.info["cpu"]}
        内存:${computer.info["memory"] !"无内存信息"}
```
```properties
空值判断、处理
<!-- FreeMarker的变量必须赋值，否则就会抛出异常。而对于FreeMarker来说，null值和不存在的变量是完全一样的，因为FreeMarker无法理解null值。 -->
FreeMarker提供两个运算符来避免空值:

1. !：指定缺失变量的默认值
    !运算符有两种用法：
        variable!或variable!defaultValue
        第一种用法不给变量指定默认值，表明默认值是空字符串、长度为0的集合、或长度为0的Map对象。
    注意：使用!运算符指定默认值并不要求默认值的类型和变量类型相同。

测试空值：
    ${sss} <#--没有定义这个变量，会报异常！-->
    ${sss!} <#--没有定义这个变量，默认值是空字符串！-->
    ${sss!"abc"} <#--没有定义这个变量，默认值是字符串abc！-->

2. ??：判断变量是否存在
    ??运算符返回布尔值，如：variable??，如果变量存在，返回true，否则返回false。
```
```properties

assign指令：
用于为该模板页面创建或替换一个顶层变量
<#assign name=value [in namespacehash]>,
<!-- 这个用法用于指定一个名为name的变量,该变量的值为value
     此外,FreeMarker允许在使用assign指令里增加in子句
     in子句用于将创建的name变量放入namespacehash命名空间中. -->
  <#assign name="李四">
    姓名：${name}
  <#assign info={"name":"张三","address":"上海"}>
    姓名：${info.name}
    地址：${info.address}
  <#assign seq = ["foo", "bar", "baz"]>

字符串输出:
    ${"Hello ${name} !"} / ${"Hello " + name + " !"}
    <#assign cname=r"特殊字符完成输出(http:\www.baidu.com)">
    ${cname}

字符串截取 ： 
    通过下标直接获取下标对应的字母： ${name[2]}
    起点下标..结尾下标截取字符串：${name[0..5]}

算数运算：
    <#-- 支持"+"、"－"、"*"、"/"、"%"运算符 -->
    <#assign number1 = 10>
    <#assign number2 = 5>
    "+" : ${number1 + number2}
    "－" : ${number1 - number2}
    "*" : ${number1 * number2}
    "/" : ${number1 / number2}
    "%" : ${number1 % number2}

比较运算符：
<!-- 
      EQ 就是 EQUAL等于
      NE就是 NOT EQUAL不等于
      GT 就是 GREATER THAN大于　
      LT 就是 LESS THAN小于
      GE 就是 GREATER THAN OR EQUAL 大于等于
      LE 就是 LESS THAN OR EQUAL 小于等于 
-->
<!--freemarker里面不能包含 ">", "<" 所以要用到大于和小于,就要用gt,lt -->
  <#if number1 + number2 gte 12 || number1 - number2 lt 6>
      "*" : ${number1 * number2}
  <#else>
      "/" : ${number1 / number2}
  </#if>

内建函数：
    <#assign data = "abcd1234">
    第一个字母大写：${data?cap_first}
    所有字母小写：${data?lower_case}
    所有字母大写：${data?upper_case}
    <#assign floatData = 12.34>
    数值取整数：${floatData?int}
    获取集合的长度：${users?size}
    时间格式化：${dateTime?string("yyyy-MM-dd")}

空判断和对象集合：
  <#if users??>
      <#list users as user >
          ${user.id} - ${user.name}
      </#list>
  <#else>
      ${user!"变量为空则给一个默认值"}
  </#if>

Map集合：
  <#assign mapData={"name":"程序员", "salary":15000}>

  直接通过Key获取 Value值：${mapData["name"]}

  通过Key遍历Map：
  <#list mapData?keys as key>
      Key: ${key} - Value: ${mapData[key]}
  </#list>

  通过Value遍历Map：
  <#list mapData?values as value>
      Value: ${value}
  </#list>

List集合：
  <#assign listData=["ITDragon", "blog", "is", "cool"]>
  <#list listData as value>${value} </#list>

include指令：
  引入其他文件：<#include "otherFreeMarker.ftl" />

macro宏指令：
  <#macro mo>
    定义无参数的宏macro--${name}
  </#macro>
    使用宏macro: <@mo />
  <#macro moArgs a b c>
    定义带参数的宏macro-- ${a+b+c}
  </#macro>
    使用带参数的宏macro: <@moArgs a=1 b=2 c=3 />

命名空间：
  <#import "otherFreeMarker.ftl" as otherFtl>
  ${otherFtl.otherName}
  <@otherFtl.addMethod a=10 b=20 />
  <#assign otherName="修改otherFreeMarker.ftl中的otherName变量值"/>
  ${otherFtl.otherName}
  <#assign otherName="修改otherFreeMarker.ftl中的otherName变量值" in otherFtl />
  ${otherFtl.otherName}
```

# Spring Boot

## 简介

**概述**

Spring Boot 是用来简化 Spring 的搭建和开发过程的全新框架。随着近些年来微服务技术的流行，Spring Boot 也成了时下炙手可热的热点技术。

Spring Boot 去除了大量的 xml 配置文件，简化了复杂的依赖管理，配合各种 starter 使用，基本上可以做到自动化配置。Spring 可以做的事情，现在用 Spring boot 都可以做。

**核心特性**

```css
1.可独立运行的spring项目：内嵌tomcat组件，随着spring boot的启动tomcat；spring boot编译时不再提供war包，而是java中标准的jar包；部署---将jar包批量上传至每一台服务器后，通过服务器段脚本自动启动。

2.“习惯有预配置”：spring boot对集成的组件进行了封装，极大的提高了开发效率，避免了重复生成可复用的代码。

3.极简的组件依赖：组件自动发现与自动装配，spring boot将最常用的配置提前处理好，我们只需在maven中制定一个starter启动器；如果某个框架或组件spring boot默认不支持，也可自己编写配置类。

4.提供运行时的应用监控：在程序开发工程中程序员往往只关注业务逻辑的实现，对服务器压力、内存占用、数据库负载等运行时重要指标置之度外，程序上线后只有在崩溃时才能得到反馈，无法提前预警；而spring boot提供了对应用监控的端口，可以通过后台直观了解到项目的运行情况，提前预防服务器宕机。

5.与分布式架构的天然集成：spring data用于海量数据处理与交互，spring cloud提供了分布式架构的底层支持，两者相辅相成，spring boot将这些框架粘合在一起，并提供了简单优化的应用方式。
```

**关于JSP**

SpringBoot不推荐使用JSP作为View，而是推荐我们使用模板（如：thymeleaf、freemarker等模板引擎），原因如下：

1. JSP性能较差

2. 绝对的前后端分离思想，JSP并不利于页面调试（运行依赖于web容器）

3. SpringBoot对内嵌web容器的支持默认也是用tomcat。但tomcat对web资源的处理上写死了要使用文件目录，对于打包成jar包的SpringBoot应用来说，显然不行，也有的人打包成war，然后还是部署到tomcat上，这样违反了SpringBoot的初衷，这样一来，等于否定了嵌入式容器，而且程序员还要处理嵌入式环境和外部tomcat环境的不同带来的问题。　

注意: 在访问jsp的过程中发生下载现象：1.排除jar的依赖问题；2.将jar中<scope> 设置为 compile

## Files Intro

### 1. 目录结构

springboot项目结构是maven的常规结构

```css
项目名+Application：springboot的程序启动类,通过此类启动项目

static：静态资源存放目录

templates：静态资源模板目录

/*YAML是树形结构，properties是K-V结构*/
application.properties：核心配置文件，两种形式：application.properties和application.yml

项目名+ApplicationTests：测试环境下的spring boot程序启动类
```

### 2. pom文件

**定义<parent>创建基础引用**

```xml
<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.0.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
</parent>

关于<relativePath/>：
查找顺序：relativePath元素中的地址–本地仓库–远程仓库；
<relativePath/>设定一个空值将始终从仓库中获取，不从本地路径获取；
子项目继承父类的时候会报must be "pom" but is "jar",需去掉此标签。
```

**添加依赖：是用一系列starter启动器描述引入的功能**

```xml
<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
            <!--排除依赖 ①在打包时排除此依赖
			②maven的依赖有传递性，B项目中引入A项目依赖时，排除此依赖 -->
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
	</dependencies>
```

**定义spring boot打包方式为独立可运行的jar包**

```xml
<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
    	</plugins>
</build>
```

### 3. mvnw

作用:

```css
mvnw是一个maven wrapper script,可以让你在没有安装maven或者maven版本不兼容的条件下运行maven的令.
注意，需要与mvnw软件区分开，spring项目中的mvnw仅仅是个脚本，并非软件。
```

原理:

```css
1. 首先寻找maven在你电脑环境变量path中的路径
2. 如果没有找到这个路径它就会自动下载maven到一个默认的路径下,之后你就可以运行maven命令
3. 如果碰到一些项目的peoject和你本地的maven不兼容,它会帮你下载合适的maven版本,然后运行
```


### 4. mvnw.cmd

执行mvnw脚本的cmd入口

## Dependency 

### 1. Spring Web
集成了Tomcat、SpringMVC、RESTful
### 2. DevTools
代码修改热更新，无需重启
监控程序的变化，然后进行自动重新启动
### 3. Lombok
消除模板代码：getter、setter、构造器、toString()、equals()等
		在运行过程中，自动生成，注解后便可直接调用

**注解介绍**

```properties
@NonNull : 让你不在担忧并且爱上NullPointerException

@CleanUp : 自动资源管理：不用再在finally中添加资源的close方法

@Setter/@Getter : 自动生成set和get方法

@ToString : 自动生成toString方法

@EqualsAndHashcode : 从对象的字段中生成hashCode和equals的实现

@NoArgsConstructor/@RequiredArgsConstructor/@AllArgsConstructor:自动生成构造方法

@Data : 自动生成set/get方法，toString方法，equals方法，hashCode方法，不带参数的构造方法

@Value : 用于注解final类

@Builder : 产生复杂的构建器api类

@SneakyThrows : 异常处理（谨慎使用）

@Synchronized : 同步方法安全的转化

@Getter(lazy=true) :
    （1）该标注用于生成一个 lazy 版的 getter，它会在第一次调用这个 getter 时计算一次值，然后从那里开始缓存它。如果计算该值需要大量 CPU，或者该值占用大量内存，这可能很有用。
    注意：Lombok 会自动去管理线程安全的问题，所以不会存在重复赋值的问题。
    （2）要使用此功能，需要创建一个 private final 变量，并且使用运行成本高的表达式对其进行初始化，同时使用 @Getter(lazy=true) 注解进行标注。
    示例

@Log : 支持各种logger对象，使用时用对应的注解，如：@Log4j

使用技巧:
    在 Bean / Entity 类上使用 @Data 注解。
    需要使用 Log 对象的地方使用 @Log4j（依项目日志框架决定）。
    注意：lombok 的注解不能被继承。
```

### 4. Spring Configuration Processor

让配置文件有提示
		使用其他配置文件xml或properties

**示例**
		使用 @EnableConfigurationProperties开启 @ConfigurationProperties注解

```java
@Data
@Component
@ConfigurationProperties(prefix = "author")
@PropertySource(value = {"classpath:demo.properties" }, ignoreResourceNotFound = false, encoding = "UTF-8", name = "demo.properties")
public class Demo {
  private String name;
  private int age;
}
```
```java
@RestController
@EnableConfigurationProperties
public class DemoController {
    @Autowired
    Demo demo;
    @RequestMapping("/")
    public String index(){
        return "author's name is " + demo.getName() + ",ahtuor's age is " + demo.getAge();
    }
}
```
由于使用 @Value 需要注入的值较多时，代码就会显得冗余，于是 @ConfigurationProperties登场了
```java
@Data
@Component
@PropertySource(value = {"classpath:static/config/demo.properties" }, ignoreResourceNotFound = false, encoding = "UTF-8", name = "demo.properties")
public class AuthorTest {
    @Value ("${author.name}") 
    private String name;
    @value ("${author. age}"
    private int age;
}
```

### 5. Spring Session
**为什么使用**

```css
布式应用和集群应用中，用户的请求可能被负载分发至不同的服务器，此时传统的web容器管理用户会话session的方式即行不通。除非集群或者分布式web应用能够共享session，尽管tomcat等支持这样做。但是这样存在以下两点问题：

需要侵入web容器，提高问题的复杂

web容器之间共享session，集群机器之间势必要交互耦合
```

**session容器**

```css
使用第三方仓储来实现集群session管理，也就是常说的分布式session容器，替换应用容器（如tomcat的session容器）。仓储的实现，Spring Session提供了三个实现（redis，mongodb，jdbc），其中redis使我们最常用的。

可以非常方便的扩展Cookie和自定义Session相关的Listener，Filter。

可以很方便的与Spring Security集成，增加诸如findSessionsByUserName，rememberMe，限制同一个账号可以同时在线的Session数（如设置成1，即可达到把前一次登录顶掉的效果）等等
```



####6. Spring Reactive Web

Spring 的reactive web框架：webflux

```css
spring-webflux

spring-webflux与spring-webmvc平级

webmvc是servlet stack  based,而webflux是reactive stack based。

webflux是一个完全的reactive并且非阻塞的web框架。

flux：“流”的意思（stream, flux, rate, class, blast, grade）
作用：就是webflux可以让你在web应用下也可以体验tcp长连接传输流数据的快感了。这在过去我们都是通过一些奇技淫巧才能实现的能力。
```

## 配置文件 

### 0. 常用配置

**Server**

``` properties
server.address ---------服务器地址
server.port ---------服务器端口
server.context-parameters.[param name] ---------设置 servlet 上下文参数
server.context-path ---------应用上下文路径
```
**Session**

```properties
server.session.cookie.domain ------回话 Cookie 的域
server.session.cookie.comment Cookie ---------注释
server.session.cookie.max-age Cookie ---------最大保存时间（单位 s）
server.session.cookie.name Cookie ---------名称
server.session.cookie.timeout ---------超时时间
```
**Tomcat**

```properties
server.tomcat.accesslog.directory ----创建日志文件的目录
server.tomcat.accesslog.enabled ---------是否开启访问日志（默认：false）
server.tomcat.accesslog.pattern ---------访问日志的格式（默认common）
server.tomcat.accesslog.prefix ---------日志名前缀（默认：access_log）
server.tomcat.accesslog.suffix ---------日志名后缀（默认：.log）
server.tomcat.max-http-header-sizeHttp ---------消息头最大字节数（默认：0）
server.tomcat.uri-encoding ---------用来解码 URI 的字符编码
```
**日志配置**

```properties
# 日志配置文件的位置。 例如对于Logback的`classpath：logback.xml`
logging.config= 
# ％wEx#记录异常时使用的转换字。
logging.exception-conversion-word= 
# 日志文件名。 例如`myapp.log`
logging.file= 
# 日志级别严重性映射。 例如`logging.level.org.springframework = DEBUG`
logging.level.*= 
# 日志文件的位置。 例如`/ var / log`
logging.path= 
# 用于输出到控制台的Appender模式。 只支持默认的logback设置。
logging.pattern.console= 
# 用于输出到文件的Appender模式。 只支持默认的logback设置。
logging.pattern.file= 
# 日志级别的Appender模式（默认％5p）。 只支持默认的logback设置。
logging.pattern.level= 
#注册日志记录系统的初始化挂钩。
logging.register-shutdown-hook= false
```
**AOP 切面**

```properties
# 添加@EnableAspectJAutoProxy。
spring.aop.auto= true
# 是否要创建基于子类（CGLIB）的代理（true），而不是基于标准的基于Java接口的代理（false）
spring.aop.proxy-target-class= false
```
**应用程序上下文初始化器**

```properties
# 应用指标。
spring.application.index= 
# 应用程序名称。
spring.application.name= 
```
**国际化（消息源自动配置）**

```properties
spring.messages.basename= messages
# 以逗号分隔的基础名称列表，每个都在ResourceBundle约定之后。
# 加载的资源束文件缓存到期，以秒为单位。 设置为-1时，软件包将永久缓存。
spring.messages.cache-seconds= -1
# 消息编码。
spring.messages.encoding= UTF-8
# 设置是否返回到系统区域设置，如果没有找到特定语言环境的文件。
spring.messages.fallback-to-system-locale= true
```
### 1. Spring MVC
```properties
# 异步请求处理超时之前的时间量（以毫秒为单位）
spring.mvc.async.request-timeout=
# 要使用的日期格式 例如`dd / MM / yyyy`
spring.mvc.date-format=
# 发送TRACE请求到FrameworkServlet doService方法
spring.mvc.dispatch-trace-request= false
# 发送OPTIONS请求到FrameworkServlet doService方法
spring.mvc.dispatch-options-request= false
# 启用favicon.ico的解析
spring.mvc.favicon.enabled= true
# 如果在重定向方案期间应该忽略“默认”模型的内容
spring.mvc.ignore-default-model-on-redirect= true
# 要使用的区域设置
spring.mvc.locale=
# 将文件扩展名映射到内容协商的媒体类型
spring.mvc.media-types.*=
# 消息代码格式策略 例如`PREFIX_ERROR_CODE`
spring.mvc.message-codes-resolver-format=
# 用于静态资源的路径模式
spring.mvc.static-path-pattern= /**
# 如果没有发现处理程序来处理请求，则应抛出“NoHandlerFoundException”
spring.mvc.throw-exception-if-no-handler-found= false
# Spring MVC视图前缀
spring.mvc.view.prefix=
# Spring MVC视图后缀
spring.mvc.view.suffix=
```
### 2. FreeMarker
```properties
spring.freemarker.allow-request-override=false
设置是否允许HttpServletRequest属性覆盖(隐藏)控制器生成的同名模型属性。
spring.freemarker.allow-session-override=false
设置是否允许HttpSession属性覆盖(隐藏)控制器生成的同名模型属性。
spring.freemarker.cache=false
启用模板缓存
spring.freemarker.charset=UTF-8
设置编码格式
spring.freemarker.check-template-location=true
检查模板位置是否存在。
spring.freemarker.content-type=text/html
内容类型值
spring.freemarker.enabled=true
为这种技术启用MVC视图解决方案。
spring.freemarker.expose-request-attributes=false
设置是否应该在与模板合并之前将所有请求属性添加到模型中。
spring.freemarker.expose-session-attributes=false
设置是否在与模板合并之前将所有HttpSession属性添加到模型中。
spring.freemarker.expose-spring-macro-helpers=true
设置是否公开RequestContext供Spring宏库使用，名称为“SpringMacroRequestContext”。
spring.freemarker.prefer-file-system-access=true
更喜欢文件系统访问模板加载。文件系统访问允许对模板更改进行热检测。
spring.freemarker.prefix=
前缀，用于在构建URL时查看名称
spring.freemarker.request-context-attribute=
所有视图的RequestContext属性的名称。
spring.freemarker.settings.*=
众所周知的FreeMarker密钥将传递给FreeMarker的配置。
spring.freemarker.suffix=
后缀，该后缀用于在构建URL时查看名称。
spring.freemarker.template-loader-path=classpath:/templates/
以逗号分隔的模板路径列表。
spring.freemarker.view-names=
可以解析的视图名称的白列表。
```
### 3. Thymeleaf
```properties
spring.thymeleaf.cache = true #启用模板缓存
spring.thymeleaf.check-template-location = true #检查模板位置是否存在
spring.thymeleaf.content-type = text / html #Content-Type值
spring.thymeleaf.enabled = true #启用MVC Thymeleaf视图分辨率
spring.thymeleaf.encoding = UTF-8 #模板编码
spring.thymeleaf.excluded-view-names = #应该从解决方案中排除的视图名称的逗号分隔列表
spring.thymeleaf.mode = HTML5 #应用于模板的模板模式另请参见

StandardTemplateModeHandlers
spring.thymeleaf.prefix = classpath：/ templates / #在构建URL时预先查看名称的前缀
spring.thymeleaf.suffix = .html #构建URL时附加查看名称的后缀
spring.thymeleaf.template-resolver-order = #链中模板解析器的顺序
spring.thymeleaf.view-names = #可以解析的视图名称的逗号分隔列表
```
### 4. DataSource
```properties
spring.datasource.continue-on-error = false #初始化数据库时发生错误时不要停止
spring.datasource.data = #Data（DML）脚本资源引用
spring.datasource.driver-class-name = #JDBC驱动程序的完全限定名称默认情况下，根据URL自动检测
spring.datasource.initialize = true #使用'data.sql'填充数据库
spring.datasource.jmx-enabled = false #启用JMX支持（如果由底层池提供）
spring.datasource.jndi-name = #数据源的JNDI位置设置时，类，网址，用户名和密码将被忽略
spring.datasource.max-active = #例如100
spring.datasource.max-idle = #例如8
spring.datasource.max等待=
spring.datasource.min-evictable空闲时间-米利斯=
spring.datasource.min-idle = 8
spring.datasource.name = testdb #数据源的名称
spring.datasource.password = #登录数据库的密码
spring.datasource.platform = all #在资源模式（schema - $ {platform} .sql）中使用的平台
spring.datasource.schema = #Schema（DDL）脚本资源引用
spring.datasource.separator =;  #语句分隔符在SQL初始化脚本中
spring.datasource.sql-script-encoding = #SQL脚本编码
spring.datasource.test-on-borrow = #例如`false`
spring.datasource.test-on-return = #例如`false`
spring.datasource.test-while-idle = #
spring.datasource.time-between-eviction-runs-millis = 1
spring.datasource.type = #要使用的连接池实现的完全限定名称默认情况下，它是从类路径自动检测的
spring.datasource.url = #数据库的JDBC url
spring.datasource.username=
spring.datasource.validation-query=
```
### 5. Redis
```properties
# 连接工厂使用的数据库索引
spring.redis.database= 0
# Redis服务器主机
spring.redis.host= localhost
# 登录redis服务器的密码
spring.redis.password=
# 给定时间池可以分配的最大连接数 使用负值为无限制
spring.redis.pool.max-active= 8
# 池中“空闲”连接的最大数量 使用负值来表示无限数量的空闲连接
spring.redis.pool.max-idle= 8
# 连接分配在池耗尽之前在抛出异常之前应阻止的最大时间量（以毫秒为单位） 使用负值无限期地阻止
spring.redis.pool.max-wait= -1
# 定义池中维护的最小空闲连接数 此设置只有在正值时才有效果
spring.redis.pool.min-idle= 0
# redis服务器端口
spring.redis.port= 6379
# redis服务器名称
spring.redis.sentinel.master=
#
spring.redis.sentinel.nodes=
# 连接超时（毫秒）
spring.redis.timeout= 0
```
### 6. JMS
```properties
# 连接工厂JNDI名称 设置时，优先于其他连接工厂自动配置
spring.jms.jndi-name=
# 容器的确认模式 默认情况下，监听器被自动确认处理
spring.jms.listener.acknowledge-mode=
# 启动时自动启动容器
spring.jms.listener.auto-startup= true
# 最小并发消费者数
spring.jms.listener.concurrency=
# 最大并发消费者数
spring.jms.listener.max-concurrency=
# 指定默认的目的地类型是否为主题
spring.jms.pub-sub-domain= false
```
### 7. DEVTools
```properties
# DEVTOOLS（开发工具属性）
# 启用一个livereload.com兼容的服务器
spring.devtools.livereload.enabled= true
#  # Server port.
spring.devtools.livereload.port= 35729
# 应该排除的触发完全重新启动的其他模式
spring.devtools.restart.additional-exclude=
# 观看更改的附加路径
spring.devtools.restart.additional-paths=
# 启用自动重启功能
spring.devtools.restart.enabled= true
# 应该排除的模式触发完全重新启动
spring.devtools.restart.exclude= META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties
# 轮询类路径更改之间等待的时间量（以毫秒为单位）
spring.devtools.restart.poll-interval= 1000
# 触发重新启动之前没有任何类路径更改所需的安静时间量（以毫秒为单位）
spring.devtools.restart.quiet-period= 400
# 更改后的特定文件的名称将触发重新启动检查 如果未指定任何类路径文件更改将触发重新启动
spring.devtools.restart.trigger-file=
Spring batch
spring.batch.initializer.enabled = true #如果需要，在启动时创建所需的批处理表
spring.batch.job.enabled = true #在启动时执行上下文中的所有Spring批处理作业
spring.batch.job.names = #在启动时执行的作业名称的逗号分隔列表（例如`job1，job2`） 默认情况下，执行在上下文中找到的所有作业
spring.batch.schema = classpath：org / springframework / batch / core / schema - @@ platform @@sql #用于初始化数据库模式的SQL文件的路径
spring.batch.table-prefix = #所有批次元数据表的表前缀
```
### 8. 远程开发工具
```properties
# 用于处理远程连接的上下文路径
spring.devtools.remote.context-path= /.~~spring-boot!~
# 启用远程调试支持
spring.devtools.remote.debug.enabled= true
# 本地远程调试服务器端口
spring.devtools.remote.debug.local-port= 8000
# 用于连接到远程应用程序的代理主机
spring.devtools.remote.proxy.host=
# 用于连接到远程应用程序的代理端口
spring.devtools.remote.proxy.port=
# 启用远程重启
spring.devtools.remote.restart.enabled= true
# 建立连接所需的共享密钥（需要启用远程支持）
spring.devtools.remote.secret=
# HTTP头用于传输共享密钥</ span>
spring.devtools.remote.secret-header-name= X-AUTH-TOKEN
```

##  应用

### 1. 打包与运行

1. Maven的package命令,生成可独立运行的Jar包
2. 利用java -jar xxx.jar命令启动Spring Boot应用

```css
运行jar包的方式有三种
java -jar xxxxx.jar  // 当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序退出
java -jar xxxxx.jar &  //当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。
nohup Java -jar xxxxxx.jar &  //意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行

jobs 查看当前终端运行的任务
总结就是第一二种方式就是ssh窗口开着才运行；第三种方式是窗口关闭依然运行，若要退出kill进程
```

3. jar包可自动加载同目录的application配置文件

```css
将配置文件放置于jar包同目录下，程序优先读取，用于不同环境的配置，如：

生产环境（线上环境）application-prd.yml 
开发环境（线下环境）application-dev.yml
测试环境（单元测试）application-test.yml
```

```yaml
#总配置文件application.yml指定开发模式
spring:
 profiles:
  active: prd
```

### 2. 自定义属性配置

**添加:**

```properties
com.sam.name=sam
```

**读取:**

###### 		第一种：使用spring支持的@Value()加载

```java
@Component
public class Sam {
    //获取application.properties的属性
    @Value("${com.sam.name}")
    private String name;
}
```

###### 		第二种：使用@ConfigurationProperties(prefix="") 设置前缀，属性上不需要添加注解。

```java
@Data
@Component
@ConfigurationProperties(prefix = "com.sam")
public class Sam {
    private String name;
}

```

```java
@RestController
public class IndexController {
    @Autowired
    private Sam sam;
    @RequestMapping("/index")
    public String index() {
        System.out.println(sam.getName());
        return "index";
    }
}
```

# 服务器

## Apache

### 快速使用

#### 1. 启动 Apache 服务

在终端输入命令：`sudo apachectl start`

```properties
在浏览器中输入如下网址，检查 Apache 服务是否启动成功！
    http://localhost
    http://127.0.0.1
在打开的页面中，如果显示 It works！表示 Apache 服务启动成功。
```

#### 2. 查看 Apache 版本

在终端输入命令：`sudo apachectl -v`

```properties
在本机中版本信息如下:
    Server version: Apache/2.4.28 (Unix)
    Server built:   Oct 29 2017 19:28:54
```

#### 3. 关闭 Apache 服务

在终端输入命令：`sudo apachectl stop`

#### 4. 重启 Apache 服务

在终端输入命令：`sudo apachectl restart`

### 配置

#### 1. 安装路径

Apache 服务默认安装路径在 /private/etc/apache2/ ，属于系统私有目录，不可以直接在 Finder 中找到该路径

#### 2. 部署路径

Apache 服务部署路径在 资源库/WebServer/Documents/ ，我们的项目需要放置在该路径下才能正常访问。如果想要修改部署路径，可以在 /private/etc/apache2/目录下找到并打开httpd.conf文件，搜索 DocumentRoot 修改部署路径。

  **注意：Mac下修改路径后，部署文件需要使用  chmod  777  文件路径命令赋予访问权限。**

#### 3. 端口号

Apache 服务端口号默认为 80，如果想要修改端口号，可以在/private/etc/apache2/ 目录下找到并打开 httpd.conf 文件，搜索  Listen 80 修改端口号。

#### 4. PHP启动

PHP 启动只需在 Apache 服务中进行一下配置即可直接使用。首先，在 /private/etc/apache2/ 目录下找到并打开 httpd.conf 文件；其次，搜索 #LoadModule php5_module libexec/apache2/libphp5.so ，将前方的 "#" 删除；再次，重启 Apache 服务即可；最后，在部署路径下新建一个 test.php 测试（如：在浏览器中输入 http://localhost/test.php 查看PHP输出信息）。



# Script

## crontab

### 快速使用

#### 1、查看 crontab 是否启动（可选）

```shell
sudo launchctl list | grep cron
```

#### 2、命令行创建crontab执行文件

```shell
> crontab -l
> crontab -e
    */1 * * * * /bin/date >> /Users/xx/time.txt
    * * * * * /bin/date >> /Users/xx/time.txt
以上代码是每分钟执行一次date命令，输出时间到time.txt文本
```

**注意：若执行脚本要赋权限：chmod 777 test.sh**

#### 3、使用crontab命令调用crontab文件

```shell
crontab testing_crontab
```

### 命令及配置

#### 1. 启动-停止

```shell
linux
/sbin/service crond start   启动服务
/sbin/service crond stop    关闭服务
/sbin/service crond restart 重启服务
/sbin/service crond reload  重新载入配置
sudo /etc/init.d/cron start
sudo /etc/init.d/cron stop
sudo /etc/init.d/cron restart

mac
sudo /usr/sbin/cron start
sudo /usr/sbin/cron restart
sudo /usr/sbin/cron stop
```

#### 2. 命令格式

```shell
crontab [-u user] file 
crontab [-u user] [ -e | -l | -r ]
```

```css
*   -u user：用来设定某个用户的crontab服务；
*   file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。
*   -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。
*   -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。
*   -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。
*   -i：在删除用户的crontab文件时给确认提示。
```

#### 3. cron expression

```jsx
分 时 日 月 星期 要运行的命令
*   第1列分钟0～59
*   第2列小时0～23（0表示子夜）
*   第3列日1～31
*   第4列月1～12
*   第5列星期0～7（0和7表示星期天）
*   第6列要运行的命令
```

```jsx
”*” 代表取值范围内的数字
“/” 代表”每”
“-” 代表从某个数字到某个数字
“,” 分开几个离散的数字
```

#### 4. 使用实例

```shell
实例1：每1分钟执行一次myCommand
* * * * * myCommand

实例2：每小时的第3和第15分钟执行
3,15 * * * * myCommand

实例3：在上午8点到11点的第3和第15分钟执行
3,15 8-11 * * * myCommand

实例4：每隔两天的上午8点到11点的第3和第15分钟执行
3,15 8-11 */2  *  * myCommand

实例5：每周一上午8点到11点的第3和第15分钟执行
3,15 8-11 * * 1 myCommand

实例6：每晚的21:30重启smb
30 21 * * * /etc/init.d/smb restart

实例7：每月1、10、22日的4 : 45重启smb
45 4 1,10,22 * * /etc/init.d/smb restart

实例8：每周六、周日的1 : 10重启smb
10 1 * * 6,0 /etc/init.d/smb restart

实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb
0,30 18-23 * * * /etc/init.d/smb restart

实例10：每星期六的晚上11 : 00 pm重启smb
0 23 * * 6 /etc/init.d/smb restart

实例11：每一小时重启smb
* */1 * * * /etc/init.d/smb restart

实例12：晚上11点到早上7点之间，每隔一小时重启smb
0 23-7 * * * /etc/init.d/smb restart

实例13：每10秒执行一次
* * * * * /Users/hao/Desktop/test.sh
* * * * * sleep 10;/Users/hao/Desktop/test.sh
* * * * * sleep 20;/Users/hao/Desktop/test.sh
* * * * * sleep 30;/Users/hao/Desktop/test.sh
* * * * * sleep 40;/Users/hao/Desktop/test.sh
* * * * * sleep 50;/Users/hao/Desktop/test.sh
```

#### 5. 问题记录

**crontab无法执行git push**

```css
http连接：
在.git/config下配置好用户名密码
url = https://HHHao-1:chzaizg556677@github.com/HHHao-1/Notes.git
或者在脚本中
git push https://HHHao-1:chzaizg556677@github.com/HHHao-1/Notes.git master
    
ssh连接:
查看脚本log
00 12 * * * /home/user/project_path/push.sh >> /home/user/document/error.log 2>&1
$ cat /home/user/document/error.log
发现错误的是 id_rsa 的权限问题,id_rsa 的权限是 700
sudo chmod 700 ~/.ssh/id_rsa
```

### 附注

#### 1. 环境变量问题

有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。

不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：

1. 脚本中涉及文件路径时写全局路径；
2. 脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如:

```bash
cat start_cbp.sh
    !/bin/sh
    source /etc/profile
    export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf
    /usr/local/jboss-4.0.5/bin/run.sh -c mev &
```

当手动执行脚本OK，但是crontab死活不执行时,很可能是环境变量惹的祸，可尝试在crontab中直接引入环境变量解决问题。如:

```shell
0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh
```

#### 2. 清理系统用户邮件日志

每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。 例如，可以在crontab文件中设置如下形式，忽略日志输出:

```shell
0 */3 * * * /usr/local/apache2/apachectl restart >/dev/null 2>&1
```

“/dev/null 2>&1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。

#### 3. 关于/dev/null文件

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。如果希望屏蔽 stdout 和 stderr，可以这样写：

```shell
$ command > /dev/null 2>&1
```

> **注意：**0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。

#### 4. 级任务调度与用户级任务调度

系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过”crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。

#### 5. 其他注意事项
```shell
1. 新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。

2. 当crontab失效时，可以尝试重启解决问题。

   或者查看日志看某个job有没有执行/报错：tail -f /var/log/cron。

3. 千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。

4. 在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date +%d，对%需要使用\进行转义，否则不能按预期执行，正确做法为：
   echo "`date +\%d`" > /tmp/r1r.txt
   而不能为
   echo "`date +%d`" > /tmp/r1r.txt

5. 更新系统时间时区后需要重启cron。

6. crontab 是系统自动启动的守护进程，不能杀死，杀死后又会重生，因为人家是 crontab 啊，生来就是不能停止工作的。
```



## Shell

###日期输出

```shell
将当前时间和包含换行符的文本内容输出到文件

echo -e $(date) "\nHello World !" >> test.txt

将当前时间（格式化）和包含换行符的文本内容输出到文件

echo -e `date '+%Y-%m-%d %H:%M:%S %A'` "\nHello World !" >> test.txt

同上，简化版

echo -e `date '+%F %T %A'` "\nHello World !" >> test.txt

输出到以日期格式文件名

echo -e $(date) "\nHello World !" >> test`date +'%Y-%m-%d'`.txt
```



# Web前端

## CSS

### css定位

```CSS
position 属性的五个值：
static（无定位）、fixed（固定）、absolute（绝对）、relative（相对）、sticky（粘性）

重叠的元素：z-index
```

**示例**

```css
img {    
    /*HTML 元素的默认值，即没有定位，遵循正常的文档流对象;
    静态定位的元素不会受到 top, bottom, left, right影响。*/
    position:static; 
    
    /*元素的位置相对于浏览器窗口是固定位置；
	即使窗口是滚动的它也不会移动；
    Fixed定位使元素的位置与文档流无关，因此不占据空间。*/
    position:fixed; 
    
    /*绝对定位的元素的位置相对于最近的已定位父元素,
    如果元素没有已定位的父元素，那么它的位置相对于<html>;
    absolute 定位使元素的位置与文档流无关，因此不占据空间。*/
    position:absolute;
    
    /*相对定位元素的定位是相对其正常位置；
    移动相对定位元素，但它原本所占的空间不会改变；
    相对定位元素经常被用来作为绝对定位元素的容器块。*/
    position:relative;
    
    /*元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。
	既指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效，
    否则其行为与相对定位相同。*/
    /*滚动超出屏幕窗口，元素贴在边缘*/
    position:sticky;
    top: 0;
    
    /*元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素
	z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）
	一个元素可以有正数或负数的堆叠顺序*/
    z-index:-1; }
```

### @media

**@media 可以针对不同的屏幕尺寸设置不同的样式**

在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果：

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

width = device-width：宽度等于当前设备的宽度
height = device-height：高度等于当前设备的高度
initial-scale：初始的缩放比例（默认设置为1.0）  
minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）    
maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）   
user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 
```

**CSS 语法**

```css
@media *mediatype* and|not|only *(media feature)* {*
  CSS-Code;
*}
```

也可以针对不同的媒体使用不同 *stylesheets* :

```css
<link rel="stylesheet" media="*mediatype* and|not|only (*media feature*)" href="*mystylesheet.css*">
```

| mediatyp | 用于所有设备                         |
| -------- | ------------------------------------ |
| all      | 用于所有设备                         |
| print    | 用于打印机和打印预览                 |
| screen   | 用于电脑屏幕，平板电脑，智能手机等。 |
| speech   | 应用于屏幕阅读器等发声设备           |

| media feature           | 描述                                                         |
| :---------------------- | :----------------------------------------------------------- |
| aspect-ratio            | 定义输出设备中的页面可见区域宽度与高度的比率                 |
| color                   | 定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0 |
| color-index             | 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0 |
| device-aspect-ratio     | 定义输出设备的屏幕可见宽度与高度的比率。                     |
| device-height           | 定义输出设备的屏幕可见高度。                                 |
| device-width            | 定义输出设备的屏幕可见宽度。                                 |
| grid                    | 用来查询输出设备是否使用栅格或点阵。                         |
| height                  | 定义输出设备中的页面可见区域高度。                           |
| max-aspect-ratio        | 定义输出设备的屏幕可见宽度与高度的最大比率。                 |
| max-color               | 定义输出设备每一组彩色原件的最大个数。                       |
| max-color-index         | 定义在输出设备的彩色查询表中的最大条目数。                   |
| max-device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的最大比率。                 |
| max-device-height       | 定义输出设备的屏幕可见的最大高度。                           |
| max-device-width        | 定义输出设备的屏幕最大可见宽度。                             |
| max-height              | 定义输出设备中的页面最大可见区域高度。                       |
| max-monochrome          | 定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。     |
| max-resolution          | 定义设备的最大分辨率。                                       |
| max-width               | 定义输出设备中的页面最大可见区域宽度。                       |
| min-aspect-ratio        | 定义输出设备中的页面可见区域宽度与高度的最小比率。           |
| min-color               | 定义输出设备每一组彩色原件的最小个数。                       |
| min-color-index         | 定义在输出设备的彩色查询表中的最小条目数。                   |
| min-device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的最小比率。                 |
| min-device-width        | 定义输出设备的屏幕最小可见宽度。                             |
| min-device-height       | 定义输出设备的屏幕的最小可见高度。                           |
| min-height              | 定义输出设备中的页面最小可见区域高度。                       |
| min-monochrome          | 定义在一个单色框架缓冲区中每像素包含的最小单色原件个数       |
| min-resolution          | 定义设备的最小分辨率。                                       |
| min-width               | 定义输出设备中的页面最小可见区域宽度。                       |
| monochrome              | 定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0 |
| orientation             | 定义输出设备中的页面可见区域高度是否大于或等于宽度。         |
| resolution              | 定义设备的分辨率。如：96dpi, 300dpi, 118dpcm                 |
| scan                    | 定义电视类设备的扫描工序。                                   |
| width                   | 定义输出设备中的页面可见区域宽度。                           |

**示例**

```css
/*max-width: 500px为页面可见区域最大宽度，可在浏览器开发模式中查询各设备匹配值*/
@media only screen and (max-width: 500px) {
    .gridmenu {
        width:100%;
    }
    .gridmain {
        width:100%;
    }
    .gridright {
        width:100%;
    }
}

/*横屏*/
@media all and (orientation : landscape) { 
h2{color:red;}
} 

/*竖屏*/
@media all and (orientation : portrait){ 
h2{color:green;}
} 
```

## JSON

### 简介

JSON(JavaScript Object Notation：JavaScript对象表示法)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言的一种文本格式，并且可读性很高。这些特性使JSON成为理想的数据交换语言。**存储、传输数据**

### 应用

#### 语法

**一个json对象**

```json
{
  "students": [
    { "firstName": "san", "lastName": "zhang" },
    { "firstName": "si", "lastName": "li" },
  ]
}
```

**多个json对象**

```json
[
  {"students_1class": { "firstName": "san", "lastName": "zhang" }},
  {"students_2class": { "firstName": "si", "lastName": "li" }}
]

注意：key--value都要用双引号
```

**json对象与字符串互相转换**

JSON.parse( )方法将字符串转换为JSON对象

JSON.stringifyo)方法将JSON对象转换为字符串

```js
var str = '{"name":"小李"}';
var json = JSON.parse(str);
var json1 = { "name": "小王" };
var str1 = JSON.stringify(json1);
var json2 = {};
json2.name = "小周"
```

**json与java交互**

json解析工具：FastJson, Jackson, Gson等。

json使用FastJson序列化与反序列化：

```java
//@JSONField(format="yyyy-MM-dd HH:mm:ss SSS")
@JSONField(name = "hiredate" , format="yyyy-MM-dd")
private Date hdate;
@JSONField(serialize = false)
private String dname;

//java对象序列化为json字符串
//序列化自动忽略为null的对象属性
String json = JSON.toJSONString(employee);
//json字符串序列化为java对象
//反序列化不忽略json字符串中的null值
Employee emp = JSON.parseObject(json, Employee.class);

//java数组对象的序列化与反序列化
List emplist = new ArrayList();
for (int i = 1 ; i <= 100 ; i++) {
	Employee employee = new Employee();
	employee.setEmpno(4488 + i);
	emplist.add(employee);
}
String json = JSON.toJSONString(emplist);
List<Employee> emps = JSON.parseArray(json , Employee.class);
```

## XML

###  简介

扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 编写XML就是编写标签,与HTML非常类似，具有良好的人机可读性。**存储、传输数据**

### 语法

1. 第一行必须是XML声明

```css
XML声明说明XML文档的基本信息,包括版本号与字符集。
<?xml version="1.0" encoding="UTF-8"?>
```

2. 只有一个根节点，各个节点可增添属性

```xml
<shop-cart>
	<item sn="771938" category="电器">
		<name>XX空调</name>
		<price> 2000.00</price>
		<num>1</num>
	</item>
	<item sn="890321" category="食品"><name>法式面包</name>
		<price>10.00</price>
		<num>5</num>
	</item>
</shop-cart>
```

3. 有序的子元素

   在XML多层嵌套的子元素中,标签前后顺序应保持一致。

```xml
<shop-cart>
	<item sn="771938" category="电器"><name>XX空调</name>
		<price> 2000.00</price>
		<num>1</num>
	</item>
	<item sn="890321" category="食品"><name>法式面包</name>
		<price> 10.00</price>
		<num>5</num>
	</item>
</shop-cart>
```

4. 处理特殊字符

标签体中,出现"<"、">"特殊字符,会破坏文档结构

```xml
无效的XML :
<exam>
    <question>1+4<3是否正确? </question>
    <question>3+5>8是否正确? </question>
</exam>
```

解决方案1:使用实体引用

| \&lt;   | <    | 小于   |
| ------ | ---- | ------ |
| \&gt;   | >    | 大于   |
| \&amp;  | &    | 和号   |
| \&apos; | '    | 省略号 |
| \&quot; | "    | 引号   |

解决方案2 :使用CDATA标签

CDATA指的是不应由XML解析器进行解析的文本数据，从"<![CDATA[忽略检查的文本]]> "结束

```xml
在CDATA中将文本的内容写入，那么这段文本内容会被忽略检查，无论里面是否包含XML敏感内容，全部被当作普通的文本去看待。例如：
<content>
    <![ CDATA [
        <script language="javascript">
            function sayhello(){ alert("hello!"); }
        </script>
    ] ] >  
</content>
```

5. XML语义约束

XML文档结构正确，但可能不是有效的。例如,员工档案XML中绝不允许出现"植物品种"标签。XML语义约束就是用于规定XML文档中允许出现哪些元素。

**XML语义约束有两种定义方式:DTD与XML Schema**

① DTD(Document Type Definition ,文档类型定义)是一种简单易用的语义约束方式，扩展名为.dtd。

```dtd
<!--DTD中的<!ELEMENT>标签,可以定义XML文档中允许出现的节点及数量-->
定义hr节点下只允许出现1个employee子节点
<!ELEMENT hr (employee)>
employee节点下必须包含以下四个节点,且按顺序出现。
<!ELEMENT employee (name,age,salary,department)>
定义name标签体只能是文本, #PCDATA代表文本元素。
<!ELEMENT name (#PCDATA)>

<!--DTD定义节点数量-->
<!--如某个子节点需要多次重复出现,则需要在子节点后增加相应的描述符-->
hr节点下最少出现1个employee子节点。
<!ELEMENT hr (employee+)>
hr节点下可出现0..n个employee子节点。
<!ELEMENT hr (employee*)>
hr节点下最多出现1个emplovee子节点。
<!ELEMENT hr (employee?)>

<!--XML引用DTD文件-->
在XML中使用<!DOCTYPE>标签来引用DTD文件
<!DOCTYPE 根节点 SYSTEM "dtd文件路径">
<!DOCTYPE hr SYSTEM "hr.dtd">
```

② XML Schema比DTD更为复杂,提供了更多功能

提供了数据类型、格式限定、数据范围等特性；是W3C标准；扩展名.xsd

```xml
<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://www.w3.org/2001/XMLSchema">
	<element name="hr">
		<!-- complexType标签含义是复杂节点，包含子节点时必须使用这个标签 -->
		<complexType>
			<!--sequence序列，子节点必须按顺序前后严格书写-->
			<sequence>
				<!--minOccurs节点最少出现次数，maxOccurs节点最多出现次数-->
				<element name="employee" minOccurs="1" maxOccurs="9999">
					<complexType>
						<sequence>
							<element name="name" type="string"></element>
							<element name="age">
								<!--节点类型详细限制-->
								<simpleType>
									<restriction base="integer">
										<minInclusive value="18"></minInclusive>
										<maxInclusive value="60"></maxInclusive>
									</restriction>
								</simpleType>
							</element>
							<element name="salary" type="integer"></element>
							<element name="department">
								<complexType>
									<sequence>
										<element name="dname" type="string"></element>
										<element name="address" type="string"></element>
									</sequence>
								</complexType>
							</element>
						</sequence>
						<!--attribute定义属性，required表示在任意此节点下这个属性必须存在-->
						<attribute name="no" type="string" use="required"></attribute>	
					</complexType>
				</element>
			</sequence>
		</complexType>
	</element>	
</schema>


<!--xml引用xsd文件-->
<hr xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="hr.xsd">
```

6. DOM文档对象模型

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfffquniqvj30ye0e6wiq.jpg" alt="image-20200603214551959"  />

### XML 解析

**Dom4j简介**

Dom4j是一个易用的、开源的库，用于解析XML；

Dom4j将XML视为Document对象；

XML标签被Dom4j定义为Element对象；

**Dom4j遍历xml**

```java
public void readXml(){
    String file = "d:/workspace/xml/src/hr.xml";
    //SAXReader类是读取XML文件的核心类,用于将XML解析后以“树”的形式保存在内存中
    SAXReader reader = new SAXReader();
    try {
        Document document = reader.read(file);
        //获取XML文档的根节点,即hr标签
        Element root = document.getRootElement();
        //elements方法用于获取指定的标签集合
        List<Element> employees =  root.elements("employee");
        for(Element employee : employees){
            //element方法用于获取唯一的子节点对象
            Element name = employee.element("name");
            String empName = name.getText();//getText()方法用于获取标签文本
            System.out.println(empName);
            System.out.println(employee.elementText("age"));
            Element department = employee.element("department");
            System.out.println(department.element("dname").getText());
            Attribute att = employee.attribute("no");
            System.out.println(att.getText());
        }
    } 
}
```

**Dom4j更新xml**

```java
public void writeXml(){
		String file = "d:/workspace/xml/src/hr.xml";
		SAXReader reader = new SAXReader();
		try {
			Document document = reader.read(file);
			Element root = document.getRootElement();
			Element employee = root.addElement("employee");
			employee.addAttribute("no", "3311");
			Element name = employee.addElement("name");
			name.setText("李铁柱");
			employee.addElement("age").setText("37");
			employee.addElement("salary").setText("3600");
			Element department = employee.addElement("department");
			department.addElement("dname").setText("人事部");
			department.addElement("address").setText("XX大厦-B105");
            //将在内存中对xml的更新写入到xml文件
			Writer writer = new OutputStreamWriter(new FileOutputStream(file) , "UTF-8");
			document.write(writer);
			writer.close();
		} 
	}
```

### XPath路径表达式

XPath路径表达式是XML文档中查找数据的语言

**最常用的基本表达式**

| 表达式   | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| nodename | 选取此节点的所有子节点。                                     |
| /        | 从根节点选取。                                               |
| //       | 从匹配选择的当前节点选择文档中的节点,<br />而不考虑它们的位置。 |
| .        | 选取当前节点。                                               |
| ..       | 选取当前节点的父节点。                                       |
| @        | 选取属性。                                                   |

示例

| 路径表达式      | 结果                                                         |
| --------------- | ------------------------------------------------------------ |
| bookstore       | 选取bookstore元素的所有子节点。                              |
| /bookstore      | 选取根元素bookstore.<br/>注释:假如路径起始于正斜杠(/),则此路径始终代表到某元素的绝对路径! |
| bookstore/book  | 选取属于bookstore的子元素的所有book元素。                    |
| //book          | 选取所有book子元素,而不管它们在文档中的位置。                |
| bookstore//book | 选择属于bookstore元素的后代的所有book元素,而不管它们位于bookstore之下的什么位置。 |
| //@lang         | 选取名为lang的所有属性。                                     |

**XPath谓语表达式**

| 路径表达式                         | 结果                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| /bookstore/book[1]                 | 选取属于bookstore子元素的第一个book元素。                    |
| /bookstore/book[last()]            | 选取属于bookstore子元素的最后一个book元素。                  |
| /bookstore/book[last()-1]          | 选取属于bookstore子元素的倒数第二个book元素。                |
| /bookstore/books[position()<3]     | 选取最前面的两个属于bookstore元素的子元素的book元素          |
| //title[@lang]                     | 选取所有拥有名为lang的属性的title元素。                      |
| //title[@lang='eng']               | 选取所有title元素,且这些元素拥有值为eng的lang属性。          |
| /bookstore/book[price>35.00]       | 选取bookstore元素的所有book元素,且其中的price元素的值须大于35.00 |
| /bookstore/book[price>35.00]/title | 选取bookstore元素中的book元素的所有title元素,且其中的price元素的值须大于35.00 |

**XPath应用**

```java
public class XPathTestor {
   public void xpath(String xpathExp){
      String file = "E:/lianxi/xml/hr.xml";
      SAXReader reader = new SAXReader();
      try {
         Document document = reader.read(file);
         //Node是Element和Attribute的父类，在需要出进行类型转换
         List<Node> nodes = document.selectNodes(xpathExp);
         for(Node node : nodes){
            Element emp = (Element)node;
            System.out.println(emp.attributeValue("no"));
            System.out.println(emp.elementText("salary"));
         }      
      } catch (DocumentException e) {
         e.printStackTrace();
      }
   }   
   public static void main(String[] args) {
      XPathTestor testor = new XPathTestor();
//    testor.xpath("/hr/employee");
//    testor.xpath("//employee[salary<4000]");
//    testor.xpath("//employee[@no=3304]");
      testor.xpath("//employee[3] | //employee[8]");     
   }
}
```

