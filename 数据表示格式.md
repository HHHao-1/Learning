# JSON

## 简介

JSON(JavaScript Object Notation：JavaScript对象表示法)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言的一种文本格式，并且可读性很高。这些特性使JSON成为理想的数据交换语言。**存储、传输数据**

## 应用

### 语法

**一个json对象**

```json
{
  "students": [
    { "firstName": "san", "lastName": "zhang" },
    { "firstName": "si", "lastName": "li" },
  ]
}
```

**多个json对象**

```json
[
  {"students_1class": { "firstName": "san", "lastName": "zhang" }},
  {"students_2class": { "firstName": "si", "lastName": "li" }}
]

注意：key--value都要用双引号
```

**json对象与字符串互相转换**

JSON.parse( )方法将字符串转换为JSON对象

JSON.stringifyo)方法将JSON对象转换为字符串

```js
var str = '{"name":"小李"}';
var json = JSON.parse(str);
var json1 = { "name": "小王" };
var str1 = JSON.stringify(json1);
var json2 = {};
json2.name = "小周"
```

**json与java交互**

json解析工具：FastJson, Jackson, Gson等。

json使用FastJson序列化与反序列化：

```java
//@JSONField(format="yyyy-MM-dd HH:mm:ss SSS")
@JSONField(name = "hiredate" , format="yyyy-MM-dd")
private Date hdate;
@JSONField(serialize = false)
private String dname;

//java对象序列化为json字符串
//序列化自动忽略为null的对象属性
String json = JSON.toJSONString(employee);
//json字符串序列化为java对象
//反序列化不忽略json字符串中的null值
Employee emp = JSON.parseObject(json, Employee.class);

//java数组对象的序列化与反序列化
List emplist = new ArrayList();
for (int i = 1 ; i <= 100 ; i++) {
	Employee employee = new Employee();
	employee.setEmpno(4488 + i);
	emplist.add(employee);
}
String json = JSON.toJSONString(emplist);
List<Employee> emps = JSON.parseArray(json , Employee.class);
```

# XML

##  简介

扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 编写XML就是编写标签,与HTML非常类似，具有良好的人机可读性。**存储、传输数据**

## 语法

1. 第一行必须是XML声明

```css
XML声明说明XML文档的基本信息,包括版本号与字符集。
<?xml version="1.0" encoding="UTF-8"?>
```

2. 只有一个根节点，各个节点可增添属性

```xml
<shop-cart>
	<item sn="771938" category="电器">
		<name>XX空调</name>
		<price> 2000.00</price>
		<num>1</num>
	</item>
	<item sn="890321" category="食品"><name>法式面包</name>
		<price>10.00</price>
		<num>5</num>
	</item>
</shop-cart>
```

3. 有序的子元素

   在XML多层嵌套的子元素中,标签前后顺序应保持一致。

```xml
<shop-cart>
	<item sn="771938" category="电器"><name>XX空调</name>
		<price> 2000.00</price>
		<num>1</num>
	</item>
	<item sn="890321" category="食品"><name>法式面包</name>
		<price> 10.00</price>
		<num>5</num>
	</item>
</shop-cart>
```

4. 处理特殊字符

标签体中,出现"<"、">"特殊字符,会破坏文档结构

```xml
无效的XML :
<exam>
    <question>1+4<3是否正确? </question>
    <question>3+5>8是否正确? </question>
</exam>
```

解决方案1:使用实体引用

| \&lt;   | <    | 小于   |
| ------- | ---- | ------ |
| \&gt;   | >    | 大于   |
| \&amp;  | &    | 和号   |
| \&apos; | '    | 省略号 |
| \&quot; | "    | 引号   |

解决方案2 :使用CDATA标签

CDATA指的是不应由XML解析器进行解析的文本数据，从"<![CDATA[忽略检查的文本]]> "结束

```xml
在CDATA中将文本的内容写入，那么这段文本内容会被忽略检查，无论里面是否包含XML敏感内容，全部被当作普通的文本去看待。例如：
<content>
    <![ CDATA [
        <script language="javascript">
            function sayhello(){ alert("hello!"); }
        </script>
    ] ] >  
</content>
```

5. XML语义约束

XML文档结构正确，但可能不是有效的。例如,员工档案XML中绝不允许出现"植物品种"标签。XML语义约束就是用于规定XML文档中允许出现哪些元素。

**XML语义约束有两种定义方式:DTD与XML Schema**

① DTD(Document Type Definition ,文档类型定义)是一种简单易用的语义约束方式，扩展名为.dtd。

```dtd
<!--DTD中的<!ELEMENT>标签,可以定义XML文档中允许出现的节点及数量-->
定义hr节点下只允许出现1个employee子节点
<!ELEMENT hr (employee)>
employee节点下必须包含以下四个节点,且按顺序出现。
<!ELEMENT employee (name,age,salary,department)>
定义name标签体只能是文本, #PCDATA代表文本元素。
<!ELEMENT name (#PCDATA)>

<!--DTD定义节点数量-->
<!--如某个子节点需要多次重复出现,则需要在子节点后增加相应的描述符-->
hr节点下最少出现1个employee子节点。
<!ELEMENT hr (employee+)>
hr节点下可出现0..n个employee子节点。
<!ELEMENT hr (employee*)>
hr节点下最多出现1个emplovee子节点。
<!ELEMENT hr (employee?)>

<!--XML引用DTD文件-->
在XML中使用<!DOCTYPE>标签来引用DTD文件
<!DOCTYPE 根节点 SYSTEM "dtd文件路径">
<!DOCTYPE hr SYSTEM "hr.dtd">
```

② XML Schema比DTD更为复杂,提供了更多功能

提供了数据类型、格式限定、数据范围等特性；是W3C标准；扩展名.xsd

```xml
<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://www.w3.org/2001/XMLSchema">
	<element name="hr">
		<!-- complexType标签含义是复杂节点，包含子节点时必须使用这个标签 -->
		<complexType>
			<!--sequence序列，子节点必须按顺序前后严格书写-->
			<sequence>
				<!--minOccurs节点最少出现次数，maxOccurs节点最多出现次数-->
				<element name="employee" minOccurs="1" maxOccurs="9999">
					<complexType>
						<sequence>
							<element name="name" type="string"></element>
							<element name="age">
								<!--节点类型详细限制-->
								<simpleType>
									<restriction base="integer">
										<minInclusive value="18"></minInclusive>
										<maxInclusive value="60"></maxInclusive>
									</restriction>
								</simpleType>
							</element>
							<element name="salary" type="integer"></element>
							<element name="department">
								<complexType>
									<sequence>
										<element name="dname" type="string"></element>
										<element name="address" type="string"></element>
									</sequence>
								</complexType>
							</element>
						</sequence>
						<!--attribute定义属性，required表示在任意此节点下这个属性必须存在-->
						<attribute name="no" type="string" use="required"></attribute>	
					</complexType>
				</element>
			</sequence>
		</complexType>
	</element>	
</schema>


<!--xml引用xsd文件-->
<hr xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="hr.xsd">
```

6. DOM文档对象模型

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfffquniqvj30ye0e6wiq.jpg" alt="image-20200603214551959"  />

## XML解析

**Dom4j简介**

Dom4j是一个易用的、开源的库，用于解析XML；

Dom4j将XML视为Document对象；

XML标签被Dom4j定义为Element对象；

**Dom4j遍历xml**

```java
public void readXml(){
    String file = "d:/workspace/xml/src/hr.xml";
    //SAXReader类是读取XML文件的核心类,用于将XML解析后以“树”的形式保存在内存中
    SAXReader reader = new SAXReader();
    try {
        Document document = reader.read(file);
        //获取XML文档的根节点,即hr标签
        Element root = document.getRootElement();
        //elements方法用于获取指定的标签集合
        List<Element> employees =  root.elements("employee");
        for(Element employee : employees){
            //element方法用于获取唯一的子节点对象
            Element name = employee.element("name");
            String empName = name.getText();//getText()方法用于获取标签文本
            System.out.println(empName);
            System.out.println(employee.elementText("age"));
            Element department = employee.element("department");
            System.out.println(department.element("dname").getText());
            Attribute att = employee.attribute("no");
            System.out.println(att.getText());
        }
    } 
}
```

**Dom4j更新xml**

```java
public void writeXml(){
		String file = "d:/workspace/xml/src/hr.xml";
		SAXReader reader = new SAXReader();
		try {
			Document document = reader.read(file);
			Element root = document.getRootElement();
			Element employee = root.addElement("employee");
			employee.addAttribute("no", "3311");
			Element name = employee.addElement("name");
			name.setText("李铁柱");
			employee.addElement("age").setText("37");
			employee.addElement("salary").setText("3600");
			Element department = employee.addElement("department");
			department.addElement("dname").setText("人事部");
			department.addElement("address").setText("XX大厦-B105");
            //将在内存中对xml的更新写入到xml文件
			Writer writer = new OutputStreamWriter(new FileOutputStream(file) , "UTF-8");
			document.write(writer);
			writer.close();
		} 
	}
```

## XPath

XPath路径表达式是XML文档中查找数据的语言

**最常用的基本表达式**

| 表达式   | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| nodename | 选取此节点的所有子节点。                                     |
| /        | 从根节点选取。                                               |
| //       | 从匹配选择的当前节点选择文档中的节点,<br />而不考虑它们的位置。 |
| .        | 选取当前节点。                                               |
| ..       | 选取当前节点的父节点。                                       |
| @        | 选取属性。                                                   |

示例

| 路径表达式      | 结果                                                         |
| --------------- | ------------------------------------------------------------ |
| bookstore       | 选取bookstore元素的所有子节点。                              |
| /bookstore      | 选取根元素bookstore.<br/>注释:假如路径起始于正斜杠(/),则此路径始终代表到某元素的绝对路径! |
| bookstore/book  | 选取属于bookstore的子元素的所有book元素。                    |
| //book          | 选取所有book子元素,而不管它们在文档中的位置。                |
| bookstore//book | 选择属于bookstore元素的后代的所有book元素,而不管它们位于bookstore之下的什么位置。 |
| //@lang         | 选取名为lang的所有属性。                                     |

**XPath谓语表达式**

| 路径表达式                         | 结果                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| /bookstore/book[1]                 | 选取属于bookstore子元素的第一个book元素。                    |
| /bookstore/book[last()]            | 选取属于bookstore子元素的最后一个book元素。                  |
| /bookstore/book[last()-1]          | 选取属于bookstore子元素的倒数第二个book元素。                |
| /bookstore/books[position()<3]     | 选取最前面的两个属于bookstore元素的子元素的book元素          |
| //title[@lang]                     | 选取所有拥有名为lang的属性的title元素。                      |
| //title[@lang='eng']               | 选取所有title元素,且这些元素拥有值为eng的lang属性。          |
| /bookstore/book[price>35.00]       | 选取bookstore元素的所有book元素,且其中的price元素的值须大于35.00 |
| /bookstore/book[price>35.00]/title | 选取bookstore元素中的book元素的所有title元素,且其中的price元素的值须大于35.00 |

**XPath应用**

```java
public class XPathTestor {
   public void xpath(String xpathExp){
      String file = "E:/lianxi/xml/hr.xml";
      SAXReader reader = new SAXReader();
      try {
         Document document = reader.read(file);
         //Node是Element和Attribute的父类，在需要出进行类型转换
         List<Node> nodes = document.selectNodes(xpathExp);
         for(Node node : nodes){
            Element emp = (Element)node;
            System.out.println(emp.attributeValue("no"));
            System.out.println(emp.elementText("salary"));
         }      
      } catch (DocumentException e) {
         e.printStackTrace();
      }
   }   
   public static void main(String[] args) {
      XPathTestor testor = new XPathTestor();
//    testor.xpath("/hr/employee");
//    testor.xpath("//employee[salary<4000]");
//    testor.xpath("//employee[@no=3304]");
      testor.xpath("//employee[3] | //employee[8]");     
   }
}
```