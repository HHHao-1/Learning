# 以太坊

## 简介

> 去中心化应用平台
>
> 区块链2.0
>
> 是一个全新开放的区块链平台，允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。就像比特币一样，以太坊不受任何人控制，也不归任何人所有——它是一个开放源代码项目。和比特币协议有所不同的是，以太坊的设计十分灵活，极具适应性，在以太坊平台上创立新的应用十分简便。

## 详述

> 以太坊是可编程的区块链。它并不是给用户一系列预先设定好的操作（例如比特币交易），而是允许用户按照自己的意愿创建复杂的操作。这样一来，它就可以作为多种类型去中心化区块链应用的平台，包括加密货币在内但并不仅限于此。
>
> 以太坊狭义上是指一系列定义去中心化应用平台的协议，它的核心是**以太坊虚拟机（“EVM”）**，可以执行任意复杂算法的编码。在计算机科学术语中，以太坊是“图灵完备的”。开发者能够使用现有的JavaScript和Python等语言为模型的其他友好的编程语言，创建出在以太坊模拟机上运行的应用。
>
> 和其他区块链一样，以太坊也有一个点对点网络协议。以太坊区块链数据库由众多连接到网络的节点来维护和更新。每个网络节点都运行着以太坊模拟机并执行相同的指令。因此，人们有时形象地称以太坊为“世界电脑”。
>
> 这个贯穿整个以太坊网络的大规模并行运算并不是为了使运算更高效。实际上，这个过程使得在以太坊上的运算比在传统“电脑”上更慢更昂贵。然而，每个以太坊节点都运行着以太坊虚拟机是为了保持整个区块链的一致性。去中心化的一致使以太坊有极高的故障容错性，保证零停机，而且可以使存储在区块链上的数据保持永远不变且抗审查。
>
> 以太坊平台本身没有特点，没有价值性。和编程语言相似，它由企业家和开发者决定其用途。不过很明显，某些应用类型较之其他更能从以太坊的功能中获益。以太坊尤其适合那些在点与点之间自动进行直接交互或者跨网络促进小组协调活动的应用。例如，协调点对点市场的应用，或是复杂财务合约的自动化。比特币使个体能够不借助金融机构、银行或政府等其他中介来进行货币交换。以太坊的影响可能更为深远。理论上，任何复杂的金融活动或交易都能在以太坊上用编码自动且可靠地进行。除金融类应用外，任何对信任、安全和持久性要求较高的应用场景——比如资产注册、投票、管理和物联网——都会大规模地受到以太坊平台影响。

## 区块链

> 区块链技术是比特币的底层技术，一个区块链是一个分布式计算架构，里面的每个网络节点执行并记录相同的交易，交易被分组为区块。一次只能增加一个区块，每个区块有一个数学证明来保证新的区块与之前的区块保持先后顺序。这样一来，区块链的“分布式数据库”就能和整个网络保持一致。个体用户与总账的互动（交易）受到安全的密码保护。由数学执行并编码到协议中的经济激励因素刺激着维持和验证网络的节点。
>
> 在比特币中，分布式数据库被设想为一个账户余额表，一个总账，交易就是通过比特币的转移以实现个体之间无需信任基础的金融活动。但是随着比特币吸引了越来越多开发者和技术专家的注意，新的项目开始将比特币网络用于有价代币转移之外的其他用途。其中很多都采用了“代币”的形式——以原始比特币协议为基础，增加了新的特征或功能，采用各自加密货币的独立区块链。

## 核心概念

### 账户

- 外部账户（externally owned accounts），由密钥控制。
- 合约账户（contract accounts），由智能合约的代码控制。

![3059F404-FBE5-4113-A245-34965CF32A1C](https://tva1.sinaimg.cn/large/007S8ZIlly1gh86l6ro5qj30cs07u414.jpg)

**账户里有什么和交易过程**

> 以太坊的账户包括四个字段：一个随机数、账户的余额、合约代码（如果有的话）、存储（通常为空）。
>
> 只有合约账户才有代码，其中存储的是 codeHash（这个账户的以太坊虚拟机代码的哈希值）。这个字段在生成后是不可修改的，这意味着智能合约代码是不可修改的。
>
> 外部账户可以触发交易，而合约账户不能主动发起交易，只能在被触发后按预先写的智能合约代码执行。
>
> 合约账户可以设置多重签名，比如一个简单示例是：现有一个合约账户，它要求一个转账由发起转账的人（Alice）和另一个人（Charles）签名均可。因此，当 Alice 通过这个合约向 Bob 转账 20 个 ETH 时，合约会通知 Charles 签名，在他签名后，Bob 才可以收到这 20 个 ETH（如下图）。

​                                       ![以太坊合约账户的多重签名](http://c.biancheng.net/uploads/allimg/190109/1-1Z109153151442.gif)		

**以太坊的交易和它的区块中存的是什么**

> 和比特币一样，以太坊的区块中存储的也是交易（transaction），它包括的字段主要有：接受者（接受的账户）、发送者的签名、发送者发给接受者的以太币金额等。
>
> 与比特币的区块中存储的是交易不同，以太坊的区块中以梅克尔帕特里夏树（Merkle Patricia Tree,MPT）形式存储的是相应的以太坊账户的状态。
>
> 以太坊的交易是所谓的状态转换函数，一个交易触发它的执行，它将相应的账户从一个状态转变成新状态，然后新状态被存储在区块链的数据区块中。

### 钱包

**功能**

> 获取用户余额，管理地址和密钥，转账、智能合约调用。以太坊钱包一般不用在本地维护区块链数据，只需要使用JSON-RPC访问。

**类型**

> Geth：终端命令行；go-ethereum
>
> MetaMask：浏览器插件
>
> Mist：已停止运营
>
> 

**JSON-RPC**

> JSON-RPC，是一个无状态且轻量级的远程过程调用（RPC）传送协议，其传递内容透过 JSON为主。相较于一般的 REST透过网址（如 GET /user）调用远程服务器，JSON-RPC 直接在内容中定义了欲调用的函数名称（如 {"method": "getUser"}），这也令开发者不会陷于该使用 PUT 或者 PATCH 的问题之中。 本规范主要定义了一些数据结构及其相关的处理规则。它允许运行在基于 Socket、HTTP等诸多不同消息传输环境的同一进程中。其使用 JSON作为数据格式。

### Gas

**交易手续费 gas**

> 费用：Gas价格(用以太币计价) * Gas数量

**以太币单位**

> 最小单位: 1Wei (伟)
>
> 10^9 Wei = 1 Gwei
>
> 10^12 Wei = 1 szabo (萨博)
>
> 10^15 Wei = 1 finey(芬尼)
>
> 10^18 Wei = 1 Ether

### 以太坊网络

**主网（生产网络）： **

- 以太坊官方提供；产生真正有价值的 的以太币的网络

- 优点
  1.全球化的，部署在Internet环境上的，
  2.智能合约的代码，执行，区块的调用，都可以清晰的查看到。
  3.部署在生产环境上的智能合约，全世界任何应用都可以调用
- 缺点：
  1.任何合约执行都会消耗真实的以太币，也就是真实的现金。不适合开发、调试和测试，
  2.所有节点是全球化的，速度较慢
  3.且对于部分商业应用来说，只需要一部分节点，例如分布式部署的10-20台服务器即可。而不需要遍布全球的网络。

**测试网络：**

- 以太坊官方提供；专供用户来开发、调试和测试的网络。 上面的合约执行不消耗真实以太币

- 优点
  1.合约执行不消耗真实货币
  2.全球化的，部署在Internet环境上的，
  3.智能合约的代码，执行，区块的调用，都可以清晰的查看到。
  4.部署在测试环境上的智能合约，全世界任何应用都可以调用
  缺点：
  1.所有节点是全球化的，速度较慢
  2.测试网络不可能作为商业应用的实际落地环境

**私有网络：**

- 由用户自己通过Geth创建的私有网络，是一个非常适合开发、调试和测试的网络

- 优点
  1.方便开发者深入理解以太坊的技术底层
  2.因为节点相对较少，速度较快
  3.用户可以随时创建，随时销毁，随时重建一个以太坊网络
  4.随意的增加节点数目，或者删除节点，
  5.既可以在服务器上建立，也可以在自己的windows或者Mac机器上建立，
  6.甚至一台机器可以建立多个节点，在一台机器上实现多节点的私有网络。
- 缺点
  1.因为不是全球化的，只有在私有网络内的节点才能查看智能合约的执行、调用等。

### 区块链分类

**公有链：**

> 是指对全世界所有人开放的，任何人都可以读取数据、发送交易且交易能够获得有效确认的共识区块链。它不受任何人控制，也不归任何人所有，被认为是“完全去中心化”的区块链。比如ETH、EOS、TRON等
>
> 共有链的特性是公开、透明、去中心化，每个人都可以记账；这样，导致“挖矿”的人越来越多，效率变得更低，验证和完成交易需要更多的时间。例如，以太坊目前的交易速度只有20次每秒。而后起之秀TRON（波场）显得更有优势，每秒处理速度达到了2000次。

**联盟链：**

> 联盟链的各个节点通常有与之对应的实体机构组织，通过授权后才能加入与退出网络。各机构组织组成利益相关的联盟，共同维护区块链的健康运转。
>
> 联盟链和私有链类似，由于节点少，处理速度很快。场景不仅限于交易，也可能是行业信息储存共享等。
>
> 例如物流行业，最早有行业的龙头带领建立区块链联盟，有很多行业企业加入联盟，共同组建物流行业的区块链联盟。每个企业都运行一个节点，要使链上每个区块生效，就得获得51%或者更多的企业节点确认，所有加入的节点都在联盟内以有效或者有限的去中心化形式运行。

**私有链：**

> 区别于共有链开放的特性，私有链就更加私密，仅限在一个企业、组织以及机构内的用户访问和交易。如果把公链当做互联网，那私链就是封闭的局域网。在银行等金融机构应用比较多，用来存放账本和数据库。
>
> 私有链能够防止机构内单节点故意篡改数据，即使发生错误，也能够迅速找到来源。它有交易速度快、成本低，隐秘性高，以及无法篡改的优点。但也有其缺点，权限被少数节点控制，不能根本解决作弊问题，背离了去中心化的初衷等。

## Dapp

**简介**

> 传统互联网应用：中心化,容易更新,数据完全掌控
>
> 去中心化应用：去中心化,按规则运行

**去中心化应用架构**

> 把核心数据放在区块链上，用智能合约管理起来
>
> ![465ECA00-D2A9-4603-B970-5CDAAC53E894](https://tva1.sinaimg.cn/large/007S8ZIlly1gh935pxby2j30g508740z.jpg)
>
> 去中心化应用通过http-rpc访问智能合约，发送交易，交易经矿工打包后确认后，记入区块链，并返回响应消息。而常见的web应用的架构与之非常的相似，UI发送http请求，请求的信息，经过web服务后，请求的信息记入数据库，web服务向客户端返回响应的消息。

 **去中心化应用的开发过程**

> 1. 根据业务场景编写智能合约，编写完成把合约发布到区块链上。
>
> 2. 编写Dapp的 UI界面，使用web3js，经过http-rpc协议访问智能合约。
>
> 3. Dapp发送的每一笔交易，导致合约状态变化，会自动永久记录到区块链上。

**Web** **应用开发过程**

> 1.   编写web 服务，发布web服务。
> 2.    编写UI界面。
> 3.   实现数据持久化。在Web服务里，人工开发实现数据持久化到数据库。

**Dapp与Web应用不同点**

> 1. 界面逻辑：dapp实现了http-rpc、web3js与智能合约进行数据交互；而web app 基于ajax库与web服务进行交互。     
>
> 2. 业务逻辑层：智能合约运行在evm上的，其与系统资源完全隔离的，智能合约不能访问系统的文件、网络。而web 服务不但可以访问到文件，网络，甚至可以访问外部的服务。 
>
> 3.  数据持久化：智能合约拥有独立的存储空间，内存和堆栈。合约变量状态自动地被记录区块链上被持久化。而web服务需要人工开发实现数据的持久化。
>
> 4. web 应用不具备区块链技术特性。智能合约一旦发布即不可更改；区块链数据不可篡改、不可伪造；分布式系统共识算法等特点。

**补充：**

> 1. Web3.js是以太坊提供的一个JavaScript库,它封装了以太坊的RPC通信API,提供了一系列与区块链交互方法,使JavaScript与以太坊交互变得简单。
>
>    以太坊节点通过JSON-RPC提供外部访问接口, Web3.js是基于JavaScript和Node.js的JSON-RPC封装。
>
> 2. 去中心化应用案例：预测平台: Augur；谜恋猫: https://www.cryptokitties.co/

## 相关内容

### 智能合约

> 将合约条款代码化
>
> 以太坊上的程序,是代码和数据(状态)的集合
>
> 典型应用：代币: EOS ，游戏：迷恋猫

你愿意和从未谋面的人签合约吗？你会同意把钱借给埃塞俄比亚的农民吗？你愿意投资一个战乱地区由少数人管理的报纸吗？你会不嫌麻烦为了网上一次5美元的购买签一个有法律效力的合约吗？

大多数的答案都是否定的，原因是合约需要的基础太多了：有时需要双方之间互相信任的工作关系，有时要依靠合法的工作体系、警察和律师费用。

在以太坊这些都不需要：**如果合约所必需的要求都能放在区块链中，那么就会放在区块链中，这是一个无需信任基础也几乎不用任何成本的环境**。

 不要想将你现有的合约转移到区块链中会麻烦，想一想那些因为经济上不可行或是没有足够法律保护而被你拒绝的成千上万的小合约吧。

### DAO

> Decentralized Autonomous Organization，简称DAO，一般翻译为去中心化的自治组织。

这里简单地举个例子：想象一下你和朋友有个小生意。律师和会计很贵，完全信任让一个单独的合伙人来看管账簿可能让你精神很紧张（这甚至可能是个诈骗的机会）。你可以尝试一下多个合伙人共同看管账簿，但只要协议没有被严格遵守，就可能导致诈骗发生。

使用智能合约，公司的所有权和基金分配的条款可以在一开始就详细规定。智能合约签署的方式是，只有大部分拥有者批准，合约才可以变更。 这样的智能合约可以像开源软件一样获取，你甚至都不必雇佣自己的程序员来代替会计和律师。

这样的智能合约可以立即按比例决定分配。几个年轻人分配柠檬水站收入，可以像主权基金给拥有基金的亿万公民分配收益一样透明。在这两个案例中，这种透明性带来的花费可能每美元连一美分都不到。

### 工作流程

> 以太坊合并了很多对比特币用户来说十分熟悉的特征和技术，同时自己也进行了很多修正和创新。比特币区块链纯粹是一个关于交易的列表，而以太坊的基础单元是账户。以太坊区块链跟踪每个账户的状态，所有以太坊区块链上的状态转换都是账户之间价值和信息的转移。账户分为两类：外部账户(EOA) 和 合约账户
>
> 外部账户（EOA），由私人密码控制合约账户，由它们的合约编码控制，只能由外部账户“激活” 对于大部分用户来说，两者基本的区别在于外部账户是由人类用户掌控——因为他们能够控制私钥，进而控制外部账户。而合约账户则是由内部编码管控。如果他们是被人类用户“控制”的，那也是因为程序设定它们被具有特定地址的外部账户控制，进而被持有私钥控制外部账户的人控制着。“智能合约”这个流行的术语指的是在合约账户中编码——交易被发送给该账户时所运行的程序。用户可以通过在区块链中部署编码来创建新的合约。
>
> 只有当外部账户发出指令时，合约账户才会执行相应的操作。所以合约账户不可能自发地执行诸如任意数码生成或应用程序界面调用等操作—只有受外部账户提示时，它才会做这些事。这是因为以太坊要求节点能够与运算结果保持一致，这就要求保证严格确定执行。
>
> 和比特币一样，以太坊用户必须向网络支付少量交易费用。这可以使以太坊区块链免受无关紧要或恶意的运算任务干扰，比如分布式拒绝服务（DDoS）攻击或无限循环 。交易的发送者必须在激活的“程序”每一步付款，包括运算和记忆储存。费用通过以太坊自有的有价代币，以太币的形式支付。
>
> 交易费用由节点收集，节点使网络生效。这些“矿工”就是以太坊网络中收集、传播、确认和执行交易的节点。矿工们将交易分组——包括许多以太坊区块链中账户“状态”的更新——分成的组被称为“区块”，矿工们会互相竞争，以使他们的区块可以添加到下一个区块链上。矿工们每挖到一个成功的区块就会得到以太币奖励。这就为人们带来了经济激励，促使人们为以太坊网络贡献硬件和电力。
>
> 和比特币网络一样，矿工们有解决复杂数学问题的任务以便成功地“挖”到区块。这被称为“工作量证明”。一个运算问题，如果在算法上解决，比验证解决方法需要更多数量级的资源，那么它就是工作证明的极佳选择。为防止比特币网络中已经发生的，专门硬件（例如特定用途集成电路）造成的中心化现象，以太坊选择了难以存储的运算问题。如果问题需要存储器和CPU，事实上理想的硬件是普通的电脑。这就使以太坊的工作量证明具有抗特定用途集成电路性，和比特币这种由专门硬件控制挖矿的区块链相比，能够带来更加去中心化的安全分布。

### 客户端

进入到Homestead阶段以后，Go客户端占据了主导地位，但情况并不一直是这样，将来也并不必然如此。除了EthereumH，其他客户端都有Homestead兼容的版本。

| 客户端         | 语言       | 开发者       | 最新版本                        |
| -------------- | ---------- | ------------ | ------------------------------- |
| go-ethereum    | Go         | 以太坊基金会 | go-ethereum-v1.4.9              |
| Parity         | Rust       | Ethcore      | Parity-v1.2.1                   |
| cpp-ethereum   | C++        | 以太坊基金会 | cpp-ethereum-v1.2.9             |
| pyethapp       | Python     | 以太坊基金会 | pyethapp-v1.2.3                 |
| ethereumjs-lib | Javascript | 以太坊基金会 | ethereumjs-lib-v3.0.0           |
| Ethereum(J)    | Java       |              | ethereumJ-v1.3.0-RC3-daoRescue2 |
| ruby-ethereum  | Ruby       | Jan Xie      | ruby-ethereum-v0.9.3            |
| ethereumH      | Haskell    | BlockApps    | 尚无Homestead 版本              |

# Solidity

## 简介

> 静态语言
>
> 以太坊Solidity是一种面向智能合约的高级语言，其语法与JavaScript类似。solidity是用于生成在EVM上执行的机器级代码的工具。solidity编译器获取高级代码并将其分解为更简单的指令。Solidity代码封装在Contracts中。
>

合约是以太坊去中心化应用程序的基本构建模块。所有变量和函数都是合约的一部分，这是所有项目的起点。如下示例：

```csharp
version pragma ^0.4.19;
import "solidity_for_import.sol";

contract MyFirst{
    uint a;
    function setA(uint x) public return(uint){ 
        а=x;
    }
}
```

```csharp
//函数
function 函数名 (参数类型 参数名) {internallexternal} [pure|constant|viewl payable] [returns (返回值类型)]{
    //code here
}
```

## 图示

### 接口设计&调用

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gh9a1ro2vaj313x0na403.jpg)

### 编译源码

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gh9a2h1dtmj31az0jtq41.jpg)

### 合约部署

![在这里插入图片描述](https://tva1.sinaimg.cn/large/007S8ZIlly1gh9a35dfutj318n0hd0v7.jpg)

## 结构

源文件可以包含任意数量的合约定义，包括指令和pragma指令。

![8F57C52B-03F6-4472-A874-1CB77E4589F7](https://tva1.sinaimg.cn/large/007S8ZIlly1gh3abu2ps5j30g70cyq5v.jpg)

### 编译器版本

Version Pragma是定义代码使用的Solidity编译器版本的声明。

```css
version pragma ^0.4.00;
```

注意：上面显示的源文件不会使用早于版本0.4.0的编译器进行编译，也不能在从版本0.5.0开始的编译器上运行。

### 导入

Ethereum Solidity支持与JavaScript中可用的导入语句非常相似的导入语句，尽管Solidity不知道`default export`的概念。在全局级别，可以使用以下形式的import语句：

```cpp
import "filename";
```

```jsx
import * as symbolName from "filename";
```

### 状态变量

状态变量是被永久地保存在合约中。也就是说它们被写入以太币区块链中，可以想象成写入一个数据库。

状态变量不能重新赋值，需要通过交易进行。

```csharp
contract Example {
  // 这个无符号整数将会永久的被保存在区块链中
  uint myUnsignedInteger = 100;
}
```

### 注释

```cpp
// This is a single-line comment.
/*
This is a
multi-line comment
*/
```

## 存储区域

### 变量存储区域

存储Storage：

```css
永久存储在区块链

storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但内容可以被(交易)调用改变。
Solidity 称这个为状态改变，这也是合约级变量称为状态变量的原因。也可以更好的理解为什么状态变量都是storage存储。

storage 在区块链中是用key/value的形式存储
```

内存Memory：

```css
存储在内存，临时存储，当外部函数对某合约调用完成时，内存型变量即被移除

memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。

memory 表现为字节数组
```

memory位置还包含2种类型的存储数据位置，一种是calldata，一种是栈（stack）

> （1）calldata
>
> ```css
> 这是一块只读的，且不会永久存储的位置，用来存储函数参数。 外部函数的参数（非返回参数）的数据位置被强制指定为 calldata ，效果跟 memory 差不多。
> ```
>
> （2） 栈（stack）
>
> ```css
> 保存小的局部变量，但只能保存有限数量的值。
> 
> EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。 值类型的局部变量是存储在栈上。
> ```

### gas消耗比较

storage 会永久保存合约状态变量，开销最大；

memory 仅保存临时变量，函数调用之后释放，开销很小；

stack 保存很小的局部变量，免费使用，但有数量限制(16个变量)；

calldata 的数据包含消息体的数据，其计算需要增加n*68的gas费用；

## 修饰符

| 修饰符                    | 说明                                         |
| ------------------------- | -------------------------------------------- |
| public                    | 公有,任何人(拥有以太坊账户的)都可以调用      |
| private                   | 私有, 只有智能合约内部可以调用               |
| external                  | 仅合约外部可以调用，合约内部需使用this调用   |
| internal                  | 仅合约内部和继承的合约可以调用               |
| view/constant（视图函数） | 函数会读取但是不会修改任何contract的状态变量 |
| pure（纯函数）            | 函数不使用任何智能合约的状态变量             |
| payable                   | 调用函数需要付钱，钱付给了智能合约的账户     |
| returns                   | 返回值函数声明中使用                         |

**注意，所有在合约内的东西对外部的观察者来说都是可见，将某些东西标记为`private`仅仅阻止了其它合约来进行访问和修改，但并不能阻止其它人看到相关的信息。**

## 值类型

值类型是指变量在赋值过程中是将数据完整的拷贝一份，再赋值给新的变量，这种方式需要开辟新的内存空间，效率较低，两个变量完全独立，修改一个不会影响另外一个。

- 布尔(Booleans)
- 整型(Integer)
- 地址(Address)
- 字符串常量（string）
- 定长字节数组(fixed byte arrays)
- 有理数和整型(Rational and Integer Literals，String literals)
- 枚举类型(Enums)
- 函数(Function Types)

![A3521E5D-39CE-47A2-9745-52B0D9206E83](https://tva1.sinaimg.cn/large/007S8ZIlly1gh98j6lwhfj30wt0ij7lh.jpg)

### 布尔

**关键词：bool**

值是常数，即true或false。

### 整型

**关键字：int（有符号整型，有正有负）/uint（无符号整型，无负数）**

以8位为区间，支持int8，int16，int24 至 int256，uint同理

**int默认为int256，uint默认为uint256**

```csharp
contract MySample{
uint UnsignedInt =50;
}
```

### 地址

**关键字：address**

以太坊地址的长度，大小`20个字节`，每个字节8位，20 * 8 = `160位`，所以可以用一个`uint160`编码。地址是所有合约的基础，所有的合约都会继承地址对象，通过合约的地址串，调用合约内的函数。

**地址成员：balance（属性，其余都是方法）与transfer**,send和transfer类似（不建议使用）

可以使用属性balance查询地址的余额，并使用transfer函数将以太币发送到地址。

```kotlin
address x = 0x123;
address myAddress = this;
if  (x.balance < 10 && myAddress.balance > = 10)
x.transfer(10);
//return addr.balance;
//return this.balance; 返回当前合约账户的余额，可以使用this指针，this表示合约自身的地址
```

### 字符串

String：字符串文字用双引号或单引号

与其他语言的区别：字符串常量没有结尾符，不像C语言一样以\0结束，如"abc"只有三个字节，没有结尾符

```cpp
string language ="Solidity";
```

### 枚举类型

枚举可以显式的转换与整数进行转换，但不能进行隐式转换。显式的转换会在运行时检查数值范围，如果不匹配，将会引起异常。

枚举类型应至少有一名成员，枚举元素默认为uint8，当元素数量足够多时，会自动变为uint16，第一个元素默认为0，使用超出范围的数值时会报错。

```csharp
enum WeekDays {
    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
} 
WeekDays currentDay;
WeekDays defaultday = WeekDays.Sunday;
```

### 函数

函数类型也就是我们所说的函数，本身也是一个特殊的变量，它可以`当做变量赋值`，`当做函数参数传递`，`当做返回值`。

- 构造函数

> 合约初始化

- 视图函数( constant/view)

> 不能修改状态变量

- 纯函数( pure)

> 既不能读取状态变量、又不能修改状态变量

- 回退函数

> 无名函数，一个合约只能有一个，避免在此函数写复杂的逻辑（复杂可能会因为发起交易人gas不够而交易失败）
>
> 智能合约需要接受以太币时，就要实现回退函数，被动调用
>
> 被动调用条件：1.给这个合约发送以太币时触发
>
> ​						   2.调用的合约没有相匹配的函数时触发

```csharp
contract Test {
    uint internal data;
    constructor (uint a) public { 
        data =a;
    }//构造函数
    function testView() public constant/view returns (uint) {
        return data;
    }//视图函数
    function f() public pure returns (uint ) {
        return 1 * 2;//return 1 * 2+data  错误
    }//纯函数
    function () public payable {
        emit EVENTA(1);
        var a =1 +2;
    }//回退函数
```

### 定长字节数组

- `bytes1`， … ，`bytes32`，允许值以步长1递增。
- byte默认表示bytes1，byte是类型，bytes是类型，bytes1是内置数组
- bytes1只能存储1个字节，即8位的内容，bytes2最多只能存储2个字节，即16位的内容。以此类推…

- 内置方法：length() --> 返回数组长度
- 存储方式：16进制ascii码

```csharp
bytes3 public b3 = "xy";
uint public len = b3.length;//b3.length = 10;

bytes8 b8 = "12345678";
bytes1 public b8_0 = b8[0];//b8_0返回0x31，即十进制的数字1的ascii值（3*16+1=49）
```



## 引用类型

solidity没有指针，对于复杂的结构进行高效传递方式是使用关键字`storage`进行修饰。

复杂类型，占用空间较大的。在拷贝时占用空间较大。所以考虑通过引用传递。常见的引用类型有：

- 不定长字节数组（bytes）
- 数组（Array）
- 结构体（Structs）

## 运算符

**算术运算符**

+、-、*、/、%、**、<<、>>

```csharp
uint x = 10 **  3; // equal to 10^3 = 1000
```

**算数运算符**

<=, <,==, !=, >=, >

**增量运算符**

a++，a-- ，++a，--a，a+=1，a-=1

**按位运算符**

(按位OR）'|'，（按位异或），（按位求反）'~'，（按位右移）'>>'，（按位左移）'<<'

```css
b << 1 equal to b*2**1，右移两位等于除4，一位等于除2
```

**逻辑运算符**

!（逻辑否定），&&（逻辑和），||（逻辑或）

## 数据结构

### 结构体Structs

structs是自定义类型，可以对多个变量进行分组。

```csharp
pragma solidity ^0.4.0;
contract Ballot {
struct Voter { // Struct
uint weight1, weight2, weight3;
bool voted;
address delegate1, delegate2, delegate3, delegate4;
string name;
uint vote1, vote2, vote3, vote4, vote5;
uint height1, height2, height3   } }
```

注意：结构只能有16个成员，超过该成员可能会发生以下错误：**Stack too Deep 堆栈太深。**

### 数组Arrays

Solidity中的数组可以在编译时固定大小，也可以是动态的。

```csharp
uint[3] fixed;  //固定长度3的数组
uint[] dynamic; //动态数组没有固定大小，可以保持增长
```

还可以创建一个结构数组。使用以前创建的Voter结构：

```css
Voter[] voting;
```

注意：将数组声明为public将自动为其创建getter方法。

```cpp
Voter[] public voting;
```

### 映射mappings

映射可以看作是哈希表，它们被虚拟地初始化，使得每个可能的键都存在并被映射到其字节表示全为零的值：类型的默认值。

映射声明为：

```jsx
//mapping(_Keytype => _ValueType )
mapping(address => uint)
```

注意：_Keytype几乎可以是任何类型，除了动态大小的数组，合约，枚举和结构。

```jsx
contract MappingExample {
    mapping(address => uint) public balances;
    function update(uint newBalance) {
        balances[msg.sender] = newBalance;  }}
contract MappingUser {
    function f() returns (uint) {
        MappingExample m = new MappingExample();
        m.update(100);
        return m.balances(this);
    }}
```

## 控制结构

除了switch和goto（跳转）之外，JavaScript中的大多数控制结构都在Solidity中可用。

所以有：if，else，while，do，for，break，continue，return，？ ：，使用从C或JavaScript中已知的通常语义。

**注意：没有像C和JavaScript那样从非布尔类型到布尔类型的类型转换。**

```csharp
contract ControlStructure {
    address public a;
    function ControlStructure(){
        // if-else can be used like this
        if(input1==2)
            a=1;
        else
            a=0;
        // while can be used like this
        while(input1>=0){
            if(input1==5)
                continue;
            input1=input1-1;
            a++;}
        // for loop can be used like this
        for(uint i=0;i<=50;i++) { a++; if(a==4) break; } 			//do while can be used like this do { a--; } (while 		a>0);
        // Conditional Operator can be used like this
        bool IsTrue = (a == 1)?true: false;
        /*will show an error because
		there is no type conversion from non-boolean to 			boolean*/
        if(1){}
    }
}
```

## 事件

使用event 关键字来定义一个事件

```js
event EventName(address bidder, uint amount); 
```

使用emit触发一个事件使用；事件在合约中同样可以被继承

```js
emit EventName(msg.sender, msg.value); 
```