# 函数概念

函数（function）的定义通常分为传统定义和近代定义，函数的两个定义本质是相同的，只是叙述概念的出发点不同，传统定义是从运动变化的观点出发，而近代定义是从集合、映射的观点出发。

函数的近代定义是给定一个数集A，假设其中的元素为x，对A中的元素x施加对应法则f，记作f（x），得到另一数集B，假设B中的元素为y，则y与x之间的等量关系可以用y=f（x）表示。函数概念含有三个要素：定义域A、值域B和对应法则f。其中核心是对应法则f，它是函数关系的本质特征。

# Lambda表达

Lambda 表达式（*lambda* expression）是一个匿名函数，*Lambda*表达式基于数学中的*λ*演算得名。

Lambda表达式，也可称为闭包，允许用函数作一个参数，使代码更简洁。

## 简单写法

1. 不需要参数，返回值为5：` () -> 5;  `

2. 接收一个参数(数字类型),返回其2倍的值： `x -> 2 * x;`

3. 接受2个参数(数字),并返回他们的差值：` (x, y) -> x – y;`

4. 接收2个int型整数,返回他们的和：`(int x, int y) -> x + y;`

5. 接受一个 string 对象,并在控制台打印,不返回任何值：`(String s) -> System.out.print(s);`

## 用法

**替代匿名类**

定义函数式接口，函数式接口就是只有一个抽象方法的接口，并且用注解@FunctionInterface注解来验证

`Inter inter = （a,b）->a*b`

```java
@FunctionalInterface
intenface MathAdd{
    public int ada(int a,int b);
}

//匿名类实现接口或继承父类
MathAdd mathAdd = new MathAdd() {
    //从add后的（ 开始截取，可得Lambda表达式
    public int add(int a,int b){
        return a+b;
    }
};

//Lambda表达式
MathAdd mathAdd = (int a, int b)-> a+b;
```

## 方法引用

**是方法引用，不是方法调用**

> 它是对Lambda的简化，“ :: ”为方法引用操作符，它所在的表达式称为方法的引用
>
> 当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式

操作符“ :: ”把方法引用分成两边，左边是类名或者某个对象的引用，右边是方法名。引用方法有下面几种方式：

- 方法引用

（1）对象名::实例方法名

（2）类名::静态方法名

（3）类名::实例方法名（引用类型上的实例方法）

若Lambda表达式的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，就可以使用这种方法：

```java
BiPredicate<String, String> b = String::equals;
b.test("abc", "abcd");

Function<String,Integer> function2 = String::length;
System.out.println(function2.apply("123"));//3
```

**补充：**泛型方法引用：`MyArrayOps::<Integer>countMatching`

- 构造方法引用

（4）类名::new*（引用构造器）*

（5）类型[]::new*（引用数组）*：

`int[] :: new 等价于 x -> new int[x]`

```java
import java.util.Arrays;

public class Main {
     static int cmp(String s1, String s2) {
        return s1.compareTo(s2);
    }
    
    public static void main(String[] args) {
        String[] array = new String[] { "Apple", "Orange", "Banana", "Lemon" };
		//匿名类
        Arrays.sort(array, new Comparator<String>() {  //Comparator接口
            public int compare(String s1, String s2) {
                return s1.compareTo(s2);
            }
        });
        //Lambda表达式
        Arrays.sort(array, (s1, s2) -> {
            return s1.compareTo(s2);
        });
        // 方法引用，引用上面的cmp方法
        Arrays.sort(array, Main::cmp);
        System.out.println(String.join(", ", array));
    }
}
```

# 函数式接口

> 有且仅有一个抽象方法，可以有多个非抽象方法

Functional Interface(功能接口)为lambda表达式和方法引用(用冒号`::`来进行方法的调用)提供目标类型。功能接口可以在多个上下文中提供目标类型，例如赋值上下文，方法调用或强制转换上下文：

```java
// Assignment context
Predicate<String> p = String::isEmpty;

// Method invocation context
stream.filter(e -> e.getSize() > 10)...

// Cast context
stream.map((ToIntFunction) e -> e.getSize())...
```

函数式接口可以使用lambda表达式，方法引用或构造函数引用创建功能接口的实例。

`@FunctionalInterface`，用于编译级错误检查，也可以不加，仅用于识别是否是一个函数接口。

- 允许定义默认方法

> default修饰方法只能在接口中使用。引进默认方法目的是为了解决接口的修改与现有的实现不兼容的问题(若接口添加抽象方法，实现类都必须重写一遍)。
>
> 默认方法是实例方法，可被实现类继承。

1. **实现类会继承接口中的default方法**
2. **如果一个类同时实现接口A和B，接口A和B中有相同的default方法，这时，该类必须重写接口中的default方法**（编译器不知道去实现谁）
3. **如果子类继承父类，父类中有b方法，该子类同时实现的接口中也有b方法，那么子类会继承父类的b方法而不是继承接口中的b方法**（类优先于接口）

```java
@FunctionalInterface
public interface HelloWorldService {
    void sayHello(String msg);
    
    default void doSomeWork1() {
        // Method body
    }
```

- 允许定义静态方法

```java
@FunctionalInterface
public interface HelloWorldService {
    void sayHello(String msg);
    
    static void printHello() {
        System.out.println("Hello");
    }
}
```

- 允许定义java.lang.Object的public方法

函数式接口里是可以包含Object里的public方法，这些方法对于函数式接口来说，不被当成是抽象方法（虽然它们是抽象方法）；因为任何一个函数式接口的实现，默认都继承了Object类，包含了来自java.lang.Object里对这些抽象方法的实现；

```java
@FunctionalInterface
public interface HelloWorldService {
    void sayHello(String msg);
	
	@Override
    boolean equals(Object obj);
}
```

## 已有函数接口

JDK1.8之前已有的函数式接口:

- java.lang.Runnable
- java.util.concurrent.Callable
- java.security.PrivilegedAction
- java.util.Comparator
- java.io.FileFilter
- java.nio.file.PathMatcher
- java.lang.reflect.InvocationHandler
- java.beans.PropertyChangeListener
- java.awt.event.ActionListener
- javax.swing.event.ChangeListener

JDK1.8新增加的函数接口:

- java.util.function

## 四大核心接口

> Function、Consumer、Supplier、Predicate

### Function<T, R> 

> 由入参和出参一块完成动作

T：入参类型，R：出参类型

调用方法：R apply(T t); 

定义函数：Function<Integer, Integer> func = p -> p * 10; // 输出入参的10倍

调用函数：func.apply(10);  // 结果100

| 接口方法                                                     | 方法描述                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| R apply(T t)                                                 | 将此参数应用到函数中                                         |
| Function<T, R> andThen(Function<? super R,? extends V> after) | 返回一个组合函数，该函数结果应用到after函数中                |
| Function<T, R> compose(Function<? super V,? extends T> before) | 返回一个组合函数，首先将入参应用到before函数，再将before函数结果应用到该函数中 |
| static \<T> Function<T,T> identity()                         | 返回一个始终返回其输入参数的函数                             |

①apply(T t)

```java
Function<String, String> function = a -> a + " Jack!";
System.out.println(function.apply("Hello")); // Hello Jack!
```

②andThen(Function<? super R,? extends V> after)

```java
Function<String, String> function = a -> a + " Jack!";
Function<String, String> function1 = a -> a + " Bob!";
String greet = function.andThen(function1).apply("Hello");
System.out.println(greet); // Hello Jack! Bob!
```

③compose(Function<? super V,? extends T> before)

```java
Function<String, String> function = a -> a + " Jack!";
Function<String, String> function1 = a -> a + " Bob!";
String greet = function.compose(function1).apply("Hello");
System.out.println(greet); // Hello Bob! Jack!
```



```java
//源码，Function.identity()比x – > x节省内存
static  Function identity() {
    return t -> t;}

Arrays.asList("a", "b", "c")
          .stream()
          .map(Function.identity()) // <- This,
          .map(str -> str)          // <- is the same as this.
          .collect(Collectors.toMap(
                       Function.identity(), // <-- And this,
                       str -> str));        // <-- is the same as this.
```

### Predicate\<T>

> 用于判断---返回boolean
>
> 谓词：描述或判定客体性质、特征或者客体之间关系的词项 --- 这里可理解为断言
>
> 这个谓词是数理逻辑里的谓词，离散数学 --- 命题逻辑与谓词逻辑

T：入参类型；出参类型是Boolean

调用方法：boolean test(T t);

定义函数：Predicate\<Integer> predicate = p -> p % 2 == 0;  // 判断是否、是不是偶数

调用函数：predicate.test(100);  // 运行结果true

| 接口方法                                            | 方法描述                                                  |
| --------------------------------------------------- | --------------------------------------------------------- |
| boolean test(T t)                                   | 根据给定的参数进行判断                                    |
| Predicate and(Predicate<? super T> other)           | 返回一个组合判断，将other以短路与的方式加入到函数的判断中 |
| Predicate or(Predicate<? super T> other)            | 返回一个组合判断，将other以短路或的方式加入到函数的判断中 |
| Predicate negate()                                  | 将函数的判断取反                                          |
| static \<T> Predicate\<T> isEqual(Object targetRef) | 返回一个谓词，该谓词根据对象测试两个参数是否相等          |

①test(T t)

```java
Predicate<Integer> predicate = number -> number != 0;
System.out.println(predicate.test(10));    //true
```

②and(Predicate<? super T> other)

```java
Predicate<Integer> predicate = number -> number != 0;
predicate = predicate.and(number -> number >= 10);
System.out.println(predicate.test(10));    //true
```

③or(Predicate<? super T> other)

```java
Predicate<Integer> predicate = number -> number != 0;
predicate = predicate.or(number -> number != 10);
System.out.println(predicate.test(10));    //true
```

④negate()

```java
Predicate<Integer> predicate = number -> number != 0;
predicate = predicate.negate();
System.out.println(predicate.test(10));    //false
```

④isEqual(Object targetRef)

```java
Predicate<String > predicate = Predicate.isEqual("Jack");
System.out.println(predicate.test("Jack"));    //true
```

### Consumer\<T>

> 由入参完成动作

T：入参类型；没有出参

调用方法：void accept(T t);

定义函数：Consumer\<String> consumer= p -> System.out.println(p);  //

因为没有出参，常用于打印、发送消息等消费动作

调用函数：consumer.accept("18800008888");

| 接口方法                                            | 方法描述                                        |
| --------------------------------------------------- | ----------------------------------------------- |
| void accept(T t)                                    | 对给定的参数执行操作                            |
| default Consumer andThen(Consumer<? super T> after) | 返回一个组合函数，after将会在该函数执行之后应用 |

①accept(T t)

```java
StringBuilder sb = new StringBuilder("Hello ");
Consumer<StringBuilder> consumer = (str) -> str.append("Jack!");
consumer.accept(sb);
System.out.println(sb.toString());	// Hello Jack!
```

②andThen(Consumer<? super T> after)

```java
StringBuilder sb = new StringBuilder("Hello ");
Consumer<StringBuilder> consumer = (str) -> str.append("Jack!");
Consumer<StringBuilder> consumer1 = (str) -> str.append(" Bob!");
consumer.andThen(consumer1).accept(sb);
System.out.println(sb.toString());	// Hello Jack! Bob!
```

### Supplie\<T>

> 提前定义

T：出参类型；没有入参

调用方法：T get();

定义函数：Supplier\<Integer> supplier= () -> 100;  //

常用于业务“有条件运行”时，符合条件再调用获取结果的应用场景；运行结果须提前定义，但不运行。

调用函数：supplier.get();

| 接口方法 | 方法描述   |
| -------- | ---------- |
| T get()  | 获取结果值 |

①get()

```java
Supplier<String> supplier = () -> "Hello Jack!";
System.out.println(supplier.get()); // Hello Jack!
```

## 四大接口扩展

> 对参数进行性扩展、限定；对返回值进行限定

### Function函数

| 序号 | 接口                    | 描述                                         |
| ---- | ----------------------- | -------------------------------------------- |
| 1    | Function<T,R>           | 接收一个参数并返回结果的函数                 |
| 2    | BiFunction<T,U,R>       | 接受两个参数并返回结果的函数                 |
| 3    | DoubleFunction\<R>      | 接收一个double类型的参数并返回结果的函数     |
| 4    | DoubleToIntFunction     | 接收一个double类型的参数并返回int结果的函数  |
| 5    | DoubleToLongFunction    | 接收一个double类型的参数并返回long结果的函数 |
| 6    | IntFunction\<R>         | 接收一个int类型的参数并返回结果的函数        |
| 7    | IntToDoubleFunction     | 接收一个int类型的参数并返回double结果的函数  |
| 8    | IntToLongFunction       | 接收一个int类型的参数并返回long结果的函数    |
| 9    | LongFunction\<R>        | 接收一个long类型的参数并返回结果的函数       |
| 10   | LongToDoubleFunction    | 接收一个long类型的参数并返回double结果的函数 |
| 11   | LongToIntFunction       | 接收一个long类型的参数并返回int结果的函数    |
| 12   | ToDoubleBiFunction<T,U> | 接收两个参数并返回double结果的函数           |
| 13   | ToDoubleFunction\<T>    | 接收一个参数并返回double结果的函数           |
| 14   | ToIntBiFunction<T,U>    | 接收两个参数并返回int结果的函数              |
| 15   | ToIntFunction\<T>       | 接收一个参数并返回int结果的函数              |
| 16   | ToLongBiFunction<T,U>   | 接收两个参数并返回long结果的函数             |
| 17   | ToLongFunction\<T>      | 接收一个参数并返回long结果的函数             |

### Consumer消费者

| 序号 | 接口                  | 描述                                               |
| ---- | --------------------- | -------------------------------------------------- |
| 1    | Consumer\<T>          | 提供一个T类型的输入参数，不返回执行结果            |
| 2    | BiConsumer<T,U>       | 提供两个自定义类型的输入参数，不返回执行结果       |
| 3    | DoubleConsumer        | 表示接受单个double值参数，但不返回结果的操作       |
| 4    | IntConsumer           | 表示接受单个int值参数，但不返回结果的操作          |
| 5    | LongConsumer          | 表示接受单个long值参数，但不返回结果的操作         |
| 6    | ObjDoubleConsumer\<T> | 表示接受object值和double值，但是不返回任何操作结果 |
| 7    | ObjIntConsumer\<T>    | 表示接受object值和int值，但是不返回任何操作结果    |
| 8    | ObjLongConsumer\<T>   | 表示接受object值和long值，但是不返回任何操作结果   |

### Predicate谓词

| 序号 | 接口             | 描述                                                         |
| ---- | ---------------- | ------------------------------------------------------------ |
| 1    | Predicate\<T>    | 对给定的输入参数执行操作，返回一个boolean类型的结果（布尔值函数） |
| 2    | BiPredicate<T,U> | 对给定的两个输入参数执行操作，返回一个boolean类型的结果（布尔值函数） |
| 3    | DoublePredicate  | 对给定的double参数执行操作，返回一个boolean类型的结果（布尔值函数） |
| 4    | IntPredicate     | 对给定的int输入参数执行操作，返回一个boolean类型的结果（布尔值函数） |
| 5    | LongPredicate    | 对给定的long参数执行操作，返回一个boolean类型的结果（布尔值函数） |

### Supplier供应商

| 序号 | 接口            | 描述                                      |
| ---- | --------------- | ----------------------------------------- |
| 1    | Supplier\<T>    | 不提供输入参数，但是返回结果的函数        |
| 2    | BooleanSupplier | 不提供输入参数，但是返回boolean结果的函数 |
| 3    | DoubleSupplier  | 不提供输入参数，但是返回double结果的函数  |
| 4    | IntSupplier     | 不提供输入参数，但是返回int结果的函数     |
| 5    | LongSupplier    | 不提供输入参数，但是返回long结果的函数    |

### Operator操作员

除了Function，Consumer，Predicate，Supplier这几个基本的函数形式，还有其它派生的函数形式，它们扩展了基本的函数形式，包括`UnaryOperator`（extends `Function`）和`BinaryOperator` （extends `BiFunction`）。

| 序号 | 接口                 | 描述                                                       |
| ---- | -------------------- | ---------------------------------------------------------- |
| 1    | UnaryOperator\<T>    | 提供单个类型参数，并且返回一个与输入参数类型一致的结果     |
| 2    | BinaryOperator\<T>   | 提供两个相同类型参数，并且返回结果与输入参数类型一致的结果 |
| 3    | DoubleBinaryOperator | 提供两个double参数并且返回double结果                       |
| 4    | DoubleUnaryOperator  | 提供单个double参数并且返回double结果                       |
| 5    | IntBinaryOperator    | 提供两个int参数并且返回int结果                             |
| 6    | IntUnaryOperator     | 提供单个int参数并且返回int结果                             |
| 7    | LongBinaryOperator   | 提供两个long参数并且返回long结果                           |
| 8    | LongUnaryOperator    | 提供单个long参数并且返回long结果                           |

#### UnaryOperator\<T>

| 接口方法                                                     | 方法描述                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| T apply(T t)                                                 | 将给定参数应用到函数中                                       |
| Function<T, R> andThen(Function<? super R,? extends V> after) | 返回一个组合函数，该函数结果应用到after函数中                |
| Function<T, R> compose(Function<? super V,? extends T> before) | 返回一个组合函数，首先将入参应用到before函数，再将before函数结果应用到该函数中 |

①apply(T t)

```java
UnaryOperator<String> unaryOperator = greet -> greet + " Bob!";
System.out.println(unaryOperator.apply("Hello")); // Hello Bob!
```

②andThen(Function<? super T,? extends T> after)

```java
UnaryOperator<String> unaryOperator = greet -> greet + " Bob!";
UnaryOperator<String> unaryOperator1 = greet -> greet + " Jack!";
String greet = unaryOperator.andThen(unaryOperator1).apply("Hello");
System.out.println(greet); // Hello Bob! Jack!
```

③compose(Function<? super T,? extends T> before)

```java
UnaryOperator<String> unaryOperator = greet -> greet + " Bob!";
UnaryOperator<String> unaryOperator1 = greet -> greet + " Jack!";
String greet = unaryOperator.compose(unaryOperator1).apply("Hello");
System.out.println(greet); // Hello Jack! Bob!
```

#### BinaryOperator\<T>

| 接口方法                                                     | 方法描述                                       |
| ------------------------------------------------------------ | ---------------------------------------------- |
| T apply(T t, T u)                                            | 根据给定参数执行函数                           |
| BiFunction<T,T,T> <br />andThen(Function<? super T,? extends T> after) | 返回一个组合函数，after应用于该函数之后        |
| static \<T> BinaryOperator\<T> maxBy(Comparator<? super T> comparator) | 返回二元操作本身，通过特殊比较器返回最大的元素 |
| static \<T> BinaryOperator\<T> minBy(Comparator<? super T> comparator) | 返回二元操作本身，通过特殊比较器返回最小的元素 |

①apply(T t, T u)

```java
BinaryOperator<String> binaryOperator = (flag, flag1) -> flag + flag1;
System.out.println(binaryOperator.apply("Hello ", "Jack!")); // Hello Jack!
```

②andThen(Function<? super T,? extends T> after)

```java
BinaryOperator<String> binaryOperator = (flag, flag1) -> flag + flag1;
Function<String, String> function = a -> a + "!!!";
System.out.println(binaryOperator.andThen(function).apply("Hello", " Jack")); // Hello Jack!!!
```

③maxBy(Comparator<? super T> comparator)

```java
BinaryOperator<Integer> integerBinaryOperator = BinaryOperator.maxBy(Integer::compareTo);
Integer max = integerBinaryOperator.apply(12, 10);
System.out.println(max); // 12
```

④minBy(Comparator<? super T> comparator)

```java
BinaryOperator<Integer> integerBinaryOperator1 = BinaryOperator.minBy(Integer::compare);
Integer min = integerBinaryOperator1.apply(12, 10);
System.out.println(min); // 10
```

#### DoubleBinaryOperator

| 接口方法                                        | 方法描述               |
| ----------------------------------------------- | ---------------------- |
| double applyAsDouble(double left, double right) | 根据给定的参数执行函数 |

①applyAsDouble(double left, double right)

```java
DoubleBinaryOperator doubleBinaryOperator = (doub1, doub2) -> doub1
	+ doub2;
System.out.println(doubleBinaryOperator.applyAsDouble(1.1, 2.3)); // 3.4
```

#### DoubleUnaryOperator

| 接口方法                                                | 方法描述                                 |
| ------------------------------------------------------- | ---------------------------------------- |
| double applyAsDouble(double operand)                    | 根据给定参数执行函数                     |
| DoubleUnaryOperator andThen(DoubleUnaryOperator after)  | 返回一个组合函数，after应用于该函数之后  |
| DoubleUnaryOperator compose(DoubleUnaryOperator before) | 返回一个组合函数，before应用于该函数之前 |

①applyAsDouble(double operand)

```java
DoubleUnaryOperator doubleUnaryOperator = doub -> doub + 2.5;
System.out.println(doubleUnaryOperator.applyAsDouble(2.6)); // 5.1
```

②andThen(DoubleUnaryOperator after)

```java
DoubleUnaryOperator doubleUnaryOperator = doub -> doub + 2.5;
DoubleUnaryOperator doubleUnaryOperator1 = doub -> doub * 3;
double result = doubleUnaryOperator.andThen(doubleUnaryOperator1)
	.applyAsDouble(10); 
System.out.println(result); // (10 + 2.5) * 3 = 37.5
```

③compose(DoubleUnaryOperator before)

```java
DoubleUnaryOperator doubleUnaryOperator = doub -> doub + 2.5;
DoubleUnaryOperator doubleUnaryOperator1 = doub -> doub * 3;
double result = doubleUnaryOperator.compose(doubleUnaryOperator1)
	.applyAsDouble(10);
System.out.println(result); // 10 * 3 + 2.5 = 32.5
```

# Comparator

- Comparable接口

> 只有一个方法，是抽象方法，不是函数接口
>
> **int compareTo(T o)**
>
> 该对象小于、等于或大于指定对象,则分别返回负整数、零或正整数

```java
public int compareTo(Goods o) {
  double price1=this.getPrice();
  double price2=o.getPrice();
  int n=new Double(price1-price2).intValue();
  return n;
}
```

- Comparator接口

| **方法**                              | **描述**                                       | **分类** |
| ------------------------------------- | ---------------------------------------------- | -------- |
| compare(T, T)                         | 返回负数、0、正数；int                         | 抽象方法 |
| equals (Object)                       | 某个对象是否等于此比较器；boolean              | 基类方法 |
| comparing(Function)                   | 自定义比较器排序；以下方法都返回Comparator\<T> | static   |
| comparing(Function, Comparator)       |                                                |          |
| comparingDouble(ToDoubleFunction)     | 按Double字段排序                               |          |
| comparingInt(ToIntFunction)           | 按Int字段排序                                  |          |
| comparingLong (ToLongFunction)        | 按Long 字段排序                                |          |
| nullsFirst(Comparator)                | null元素排在集合开头                           |          |
| nullsLast(Comparator)                 | null元素排在集合末尾                           |          |
| natural0rder()                        | 自然顺序                                       |          |
| reverse0rder()                        | 逆序                                           |          |
| reversed()                            | 逆序                                           | default  |
| thenComparing(Comparator)             | 在一次排序条件后接着排序                       |          |
| thenComparing(Function)               |                                                |          |
| thenComparing(Function, Comparator)   |                                                |          |
| thenComparingDouble(ToDoubleFunction) |                                                |          |
| thenComparingInt(ToIntFunction)       |                                                |          |
| thenComparingLong (ToLongFunction)    |                                                |          |


- 示例

```java
// 正序
private static void sortBaseTypeByDefaultMode() {
        System.out.println("before sort:");
        PrintUtil.showList(intList);//自定义显示
        Collections.sort(intList);
        System.out.println("after sort:");
        PrintUtil.showList(intList);
    }
// 逆序
private static void sortBaseTypeByIDefineMode() {
        System.out.println("before sort:");
        PrintUtil.showList(intList);
        Collections.sort(intList,new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                // 返回值为int类型，大于0表示正序，小于0表示逆序
                return o2-o1;
            }
        });
        System.out.println("after sort:");
        PrintUtil.showList(intList);
}



//构建列表
Employee e1 = new Employee("John", 25, 3000, 9922001);
Employee e2 = new Employee("Ace", 22, 2000, 5924001);
Employee e3 = new Employee("Keith", 35, 4000, 3924401);
List<Employee> employees = new ArrayList<>();
employees.add(e1);
employees.add(e2);
employees.add(e3);

//comparing(Function, Comparator) 
//相当于两个排序条件

Collections.sort(employees, Comparator.comparing(
  Employee::getName, (s1, s2) -> {
    return s2.compareTo(s1);
  }));//逆序

Collections.sort(employees, Comparator.comparing(
  s ->s.getName(), (s1, s2) -> {
    return s2.compareTo(s1);
  }));//逆序

Collections.sort(employees, Comparator.comparing(
  Employee::getName, 
  Comparator.reverseOrder()));//逆序

Collections.sort(employees, Comparator.comparing(
  Employee::getName, (s1, s2) -> {
    return s2.compareTo(s1);
  }).reversed());//正序

Collections.sort(employees, Comparator.comparing(
  Employee::getName, 
  Comparator.naturalOrder())
                 .thenComparing(Employee::getAge));//正序再以年龄排序

//comparing(Function) 
Collections.sort(employees, Comparator.comparing(Employee::getName)
                 .thenComparing(Employee::getAge));//正序再以年龄排序

//有null值
employees.add(null);
Collections.sort(employees, Comparator.nullsFirst(Comparator.comparing(Employee::getName)));

Collections.sort(employees, Comparator.nullsLast(Comparator.comparing(Employee::getName)));

employees.forEach(System.out::println);
```

# Stream API

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gj6hdqbkurj30r00f00tc.jpg)

## 简介

1. **为什么需要Stream ?**

Java8中的Stream是对容器对象功能的增强，它专注于对容器对象进行各种非常便利、高效的 **聚合操作（aggregate operation）**，或者大批量数据操作 (bulk data operation)。同时，它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用fork/join并行方式来拆分任务和加速处理过程。所以说，Java8中首次出现的 **java.util.stream是一个函数式语言+多核时代综合影响的产物。**

2. **什么是聚合操作？**

在传统的J2EE应用中，Java代码经常依赖于关系型数据库的聚合操作来完成如：

- 客户每月平均消费金额
- 最昂贵的在售商品
- 本周完成的有效订单（排除了无效的）
- 取十个数据样本作为首页推荐

这类的操作。但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而Java的集合API中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用Iterator来遍历集合，完成相关的聚合应用逻辑，这是一种远不够高效、笨拙的方法。在Java7中，如果要发现type为grocery的所有交易，然后返回以交易值降序排序好的交易ID集合，我们需要这样写：

```java
List<Transaction> groceryTransactions = new Arraylist<>();
for(Transaction t: transactions){
  if(t.getType() == Transaction.GROCERY){
    groceryTransactions.add(t);
  }
}

Collections.sort(groceryTransactions, new Comparator(){
  public int compare(Transaction t1, Transaction t2){
    return t2.getValue().compareTo(t1.getValue());
  }
});

List<Integer> transactionIds = new ArrayList<>();
for(Transaction t: groceryTransactions){
  transactionsIds.add(t.getId());
}
```

而 Java 8 使用 Stream，代码更简洁易读；而且使用并发模式，程序执行速度更快。

```java
List<Integer> transactionsIds = transactions.parallelStream()
.filter(t -> t.getType() == Transaction.GROCERY)
.sorted(comparing(Transaction::getValue).reversed())
.map(Transaction::getId).collect(toList());
```

3. **什么是流？**

Stream不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的Iterator。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如，“过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream会隐式地在内部进行遍历，做出相应的数据转换。Stream就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。

而和迭代器又不同的是，Stream可以并行化操作，迭代器只能命令式地、串行化操作。Stream 的另外一大特点是，数据源本身可以是无限的。

4. **流的构成？**

当我们使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换 → 执行操作获取想要的结果。**每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换）**，这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示:　　　　　

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj5nua8nmqj30d30b8q3b.jpg" alt="图 1. 流管道 (Stream Pipeline) 的构成" style="zoom: 67%;" />

## Stream生成

（1）从Collection和数组获得

- Collection.stream()
- Collection.parallelStream()
- Arrays.stream(T array) or Stream.of(array... 多个数组)

------

（2）从BufferedReader获得

- java.io.BufferedReader.lines()

------

（3）静态工厂

- java.util.stream.IntStream.range()
- java.nio.file.Files.walk()

------

（4）自己构建

- java.util.Spliterator

------

（5）其他

- Random.ints()
- BitSet.stream()
- Pattern.splitAsStream(java.lang.CharSequence)
- JarFile.stream()

------

## 流的操作类型

### 分类

> - Intermediate 操作
>
>   map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered
>
> - Terminal 操作
>
>   forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator
>
> - Short-circuiting 操作
>
>   anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit

### 简介

流的操作类型分为两种：

- Intermediate：一个流可以后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。
- Terminal：一个流只能有一个terminal操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以,这必定是流的最后一个操作。Terminal操作的执行，才真正开始流的遍历，并生成一个结果，或者一个side effect（副作用）。

> **1. 执行步骤：**
>
> 在对一个Stream进行多次转换操作(Intermediate 操作)，每次都对Stream的每个元素进行转换，而且是执行多次，这样时间复杂度就是N（转换次数）个for循环里把所有操作都做掉的总和吗？其实是这样的：
>
> `转换操作都是lazy的，多个转换操作只会在Terminal操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在Terminal 操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。`
>
> **2. short-circuiting：**
>
> short-circuiting用以指：对于一个intermediate操作，如果它接受的是一个无限大（infinite/unbounded）的Stream，但返回一个有限的新Stream；对于一个terminal操作，如果它接受的是一个无限大的Stream，但能在有限的时间计算出结果。当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个short-circuiting操作是必要非充分条件。

## 流的使用

**对Stream的使用就是实现一个filter-map-reduce过程，产生一个最终结果，或者导致一个副作用（side effect）。**

------

### 流的构造与转换

#### 构造

```java
// 1. Individual values
Stream stream = Stream.of("a", "b", "c");

// 2. Arrays
String [] strArray = new String[] {"a", "b", "c"};
stream = Stream.of(strArray);
stream = Arrays.stream(strArray);

// 3. Collections
List<String> list = Arrays.asList(strArray);
stream = list.stream();

// 4. concat
// 用于把流组合到一起，合并成为一个流
Stream<String> concat = Stream.concat(stream1, stream2);
```

#### 包装类型Stream

需要注意的是，对于基本数值型，目前有三种对应的包装类型Stream：IntStream、LongStream、DoubleStream。

当然也可以用 Stream\<Integer>、Stream\<Long>和Stream\<Double>，但是boxing/unboxing会很耗时，所以特别为这三种基本数值型提供了对应的Stream。Java8中还没有提供其它数值型Stream。示例：

```java
IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);//1,2,3
IntStream.range(1, 3).forEach(System.out::println);//1,2
IntStream.rangeClosed(1, 3).forEach(System.out::println);//1,2
```

### Intermediate操作

##### parallel

**forEachOrdered可以保证顺序**

```java
Stream.of("AAA,","BBB,","CCC,","DDD,").parallel().forEach(System.out::print);
System.out.println();
Stream.of("AAA,","BBB,","CCC,","DDD").parallel().forEachOrdered(System.out::print);
System.out.println();
Stream.of("DDD,","AAA,","BBB,","CCC").parallel().forEachOrdered(System.out::print);

//CCC,DDD,BBB,AAA,
//AAA,BBB,CCC,DDD
//DDD,AAA,BBB,CCC
```

##### map/flatMap

我们先来看map，它的作用就是把inputStream的每个元素映射成outputStream的另外一个元素，例如：

```java
List<Integer> nums = Arrays.asList(1, 2, 3, 4);
List<Integer> squareNums = nums.stream().map(n -> n * n)
.collect(Collectors.toList());
```

从上面例子可以看出，map生成的是个1:1映射，每个输入元素都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要flatMap，例如：

```java
Stream<List<Integer>> inputStream = Stream.of(
 Arrays.asList(1),
 Arrays.asList(2, 3),
 Arrays.asList(4, 5, 6)
 );
Stream<Integer> outputStream = inputStream.flatMap((childList) -> childList.stream());
outputStream.forEach(System.out::println);//1,2,3,4,5,6
```

flatMap把inputStream中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终output的新Stream里面已经没有List了，都是直接的数字。

------

##### filter

filter对原始Stream进行某项测试，通过测试的元素被留下生成一个新Stream。

```java
// 留下偶数
Integer[] sixNums = {1, 2, 3, 4, 5, 6};
Integer[] evens =
Stream.of(sixNums).filter(n -> n%2 == 0).toArray(Integer[]::new);
```

------

##### limit/skip

limit返回Stream的前面n个元素；skip则是扔掉前n个元素（它是由一个叫 subStream的方法改名而来）。

```java
//limit 和 skip 对运行次数的影响
public void testLimitAndSkip() {
 List<Person> persons = new ArrayList();
 for (int i = 1; i <= 10000; i++) {
 Person person = new Person(i, "name" + i);
 persons.add(person);
 }
List<String> personList2 = persons.stream().
map(Person::getName).limit(10).skip(3).collect(Collectors.toList());
System.out.println(personList2);
}
private class Person {
 public int no;
 private String name;
 public Person (int no, String name) {
 this.no = no;
 this.name = name;
 }
 public String getName() {
 System.out.println(name);
 return name;
 }
}

输出结果为：
name1
name2
name3
name4
name5
name6
name7
name8
name9
name10
[name4, name5, name6, name7, name8, name9, name10]
```

　这是一个有10，000个元素的Stream，但在short-circuiting操作limit和skip的作用下，管道中map操作指定的getName()方法的执行次数为 limit 所限定的10次，而最终返回结果在跳过前3个元素后只有后面7个返回。

　有一种情况是limit/skip无法达到short-circuiting目的的，就是把它们放在Stream的排序操作后，原因跟sorted这个intermediate操作有关：**此时系统并不知道Stream排序后的次序如何，所以sorted中的操作看上去就像完全没有被limit或者skip一样。**

```java
// limit 和 skip 对 sorted 的运行次数无影响
List<Person> persons = new ArrayList();
 for (int i = 1; i <= 5; i++) {
 Person person = new Person(i, "name" + i);
 persons.add(person);
 }
List<Person> personList2 = persons.stream().sorted((p1, p2) -> 
p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());
System.out.println(personList2);

输出结果为：
name2
name1
name3
name2
name4
name3
name5
name4
[stream.StreamDW$Person@816f27d,stream.StreamDW$Person@87aac27]
```

　即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。最后有一点需要注意的是，对一个parallel的Stream 管道来说，如果其元素是有序的，那么limit操作的成本会比较大，因为它的返回对象必须是前n个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用parallel Stream。

------

##### sorted

对Stream的排序通过sorted进行，它比数组的排序更强之处在于你可以首先对Stream进行各类map、filter、limit、skip甚至distinct来减少元素数量后再排序，这能帮助程序明显缩短执行时间。例如：

```java
// 优化：排序前进行 limit 和 skip
List<Person> persons = new ArrayList();
 for (int i = 1; i <= 5; i++) {
 Person person = new Person(i, "name" + i);
 persons.add(person);
 }

List<Person> personList2 = persons.stream().limit(2).sorted((p1, p2) -> p1.getName().compareTo(p2.getName())).collect(Collectors.toList());
System.out.println(personList2);
```

结果会简单很多：

```java
name2
name1
[stream.StreamDW$Person@6ce253f1,stream.StreamDW$Person@53d8d10a]
```

##### distinct

下面的例子则使用distinct来找出不重复的单词。

```java
// 找出全文的单词，转小写，并排序
List<String> words = br.lines().flatMap(line -> Stream.of(line.split(" "))).
 filter(word -> word.length() > 0).map(String::toLowerCase).distinct().sorted()
 .collect(Collectors.toList());
br.close();
System.out.println(words);
```

##### peek

可以实现多次遍历，对每个元素执行操作并返回一个新的 Stream

> peek函数是一种特殊的map函数，当函数没有返回值或者参数就是返回值的时候可以使用peek函数。

```java
// peek 对每个元素执行操作并返回一个新的 Stream
Stream.of("one", "two", "three", "four").filter(e -> e.length() > 3)
 .peek(e -> System.out.println("Filtered value: " + e)).map(String::toUpperCase)
 .peek(e -> System.out.println("Mapped value: " + e)).collect(Collectors.toList());1234
```

---

#### Terminal操作

##### forEach

forEach方法接收一个Lambda表达式，在Stream的每一个元素上执行该表达式。

**注意：forEach 不能修改自己包含的本地变量值，也不能用return/break/continue关键字提前结束循环。**

```java
// 对一个人员集合遍历，找出男性并打印姓名。
roster.stream().filter(p -> p.getGender() == Person.Sex.MALE)
.forEach(p -> System.out.println(p.getName()));
```

当需要为多核系统优化时，可以`parallelStream().forEach()`，只是此时原有元素的次序没法保证，而用Java8以前的for循环代码可能需要加入额外的多线程逻辑。但一般认为，forEach和常规for循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。

　另外一点需要注意，forEach是terminal操作。因此，它执行后，Stream 的元素就被“消费”掉了，你无法对一个Stream进行两次terminal运算。下面的代码是错误的：

```java
stream.forEach(element -> doOneThing(element));
stream.forEach(element -> doAnotherThing(element));
```

上述代码目的，可由peek完成。

---

##### findFirst

这是一个termimal兼short-circuiting操作，它总是返回Stream的第一个元素或者空。**它的返回值类型是Optional**。

```java
// Optional 的两个用例:以下两组示例是等价的

 // Java 8
 Optional.ofNullable(text).ifPresent(System.out::println);

 // Pre-Java 8
 if (text != null) {
 System.out.println(text);
 }

//----------

 // Java 8
return Optional.ofNullable(text).map(String::length).orElse(-1);

// Pre-Java 8
return if (text != null) ? text.length() : -1;};
```

　在更复杂的if (xx != null)的情况中，使用Optional代码的可读性更好，而且它提供的是编译时检查。

　Stream中的findAny、max/min、reduce等方法等返回Optional值。还有例如IntStream.average()返回OptionalDouble等等。

------

##### reduce

> 归约是一种思想、一种方法。通过对原问题的抽象和建模生成一个等价的另一问题，然后通过解决这个新问题来达到解决原问题的目的。

```java
reduce(BinaryOperator)
reduce (T, BinaryOperator) 
reduce(U, BiFunction, Binaryoperator)
```

这个方法的主要作用是把Stream元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面Stream的第一个、第二个、第n个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average都是特殊的reduce。例如Stream的sum就相当于：

```java
Integer sum = integers.reduce(0, (a, b) -> a+b);
```



```java
Integer sum = integers.reduce(0, Integer::sum);
```

也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。

```java
// reduce 的用例

// 字符串连接，concat = "ABCD"
String concat = Stream.of("A", "B", "C", "D").reduce("", String::concat);

// 求最小值，minValue = -3.0
double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); 
double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(-4.0, Double::min);//-4.0

// 求和，sumValue = 10, 有起始值
int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);

// 求和，sumValue = 10, 无起始值
sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();//用get()转换Optional

// 过滤，字符串连接，concat = "ace"
concat = Stream.of("a", "B", "c", "D", "e", "F").
filter(x -> x.compareTo("Z") > 0).
reduce("", String::concat);
```

　上面代码例如第一个示例的reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。

三个参数的情况：最后一个参数是combiner（合并器），用于并行流数据归约。

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gj6lmqcephj30s90fn0u4.jpg)

```java
Integer total=list.parallelStream()
  .reduce(
  Integer.valueOf(1)
  ,(integer,scoreBean)->{
    return integer+scoreBean.getScore();
  }
  ,(integer1,integer2)->{
    return integer1+integer2;
  }
);

Integer total2 = employees
  .parallelStream()
  .map(Employee::getAge)
  .reduce(0,Integer::sum,Integer::sum); 
```



------

##### min/max/distinct

min和max的功能也可以通过对Stream元素先排序，再findFirst来实现，但前者的性能会更好为O(n)，而sorted的成本是O(nlogn)。同时它们作为特殊的reduce方法被独立出来也是因为求最大最小值是很常见的操作。

```java
// 找出最长一行的长度
BufferedReader br = new BufferedReader(new FileReader("c:\\SUService.log"));
int longest = br.lines().mapToInt(String::length).max().getAsInt();
br.close();
System.out.println(longest);
```

------

##### Match

Stream有三个match方法，从语义上说：

> 1).allMatch：Stream 中全部元素符合传入的 predicate，返回 true;
>
> 2).anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true;
>
> 3).noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true.

它们都不是要遍历全部元素才能返回结果。例如allMatch只要一个元素不满足条件，就skip剩下的所有元素，返回false。对清单13中的Person类稍做修改，加入一个age属性和getAge方法。

```java
// 使用 Match
List<Person> persons = new ArrayList();
persons.add(new Person(1, "name" + 1, 10));
persons.add(new Person(2, "name" + 2, 21));
persons.add(new Person(3, "name" + 3, 34));
persons.add(new Person(4, "name" + 4, 6));
persons.add(new Person(5, "name" + 5, 55));

boolean isAllAdult = persons.stream().allMatch(p -> p.getAge() > 18);
System.out.println("All are adult? " + isAllAdult);
boolean isThereAnyChild = persons.stream().anyMatch(p -> p.getAge() < 12);
System.out.println("Any child? " + isThereAnyChild);

输出结果：
All are adult? false
Any child? true
```

##### count

  用于统计Stream流中元素的个数`Long count();`，返回值是Long类型的整数。

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);
Stream<Integer> stream = list.stream();
long count = stream.count();
System.out.println(count);//3
```

##### collect

流也可以转换为其它数据结构：

```java
// 1. Array
String[] strArray1 = stream.toArray(String[]::new);
// 2. Collection
List<String> list1 = stream.collect(Collectors.toList());
List<String> list2 = stream.collect(Collectors.toCollection(ArrayList::new));
Set set1 = stream.collect(Collectors.toSet());
Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));
// 3. String
String str = stream.collect(Collectors.joining()).toString();
```

## 总结

Stream 的特性可以归纳为：

> - 不是数据结构;
> - 它没有内部存储，它只是用操作管道从source（数据结构、数组、generator function、IO channel）抓取数据;
> - 它也绝不修改自己所封装的底层数据结构的数据。例如Stream的filter操作会产生一个不包含被过滤元素的新Stream，而不是从source删除那些元素;
> - 所有Stream的操作必须以lambda表达式为参数;
> - 不支持索引访问;
> - 你可以请求第一个元素，但无法请求第二个，第三个，或最后一个;
> - 很容易生成数组或者List;
> - 惰性化;
> - 很多Stream操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始;
> - Intermediate操作永远是惰性化的;
> - 并行能力;
> - 当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的;
> - 可以是无限的。集合有固定大小，Stream 则不必。limit(n)和findFirst()这类的short-circuiting操作可以对无限的Stream进行运算并很快完成。
>

# Collectors类

```java
public final class Collectors extends Object
```

## collect方法

> stream流的terminal方法

```java
collect (Collector) 

collect(Supplier, Biconsumer, Biconsumer)
```

```java
Integer[] nums = {1, 1, null, 2, 3, 4, null, 5, 6, 7, 8, 9, 10};

List<Integer> numsWithoutNull1 = Arrays.stream(nums).filter(num -> num != null).
  collect(() -> new ArrayList<Integer>(),
          (list, item) -> list.add(item),
          (list1, list2) -> list1.addAll(list2));

List<Integer> numsWithoutNull2 = Arrays.stream(nums).filter(num -> num != null).
  collect(Collectors.toList());
```

## Collector接口

Collector 作为 collect 方法的参数

Collector 本身是一个接口，它是一个可变的汇聚操作，作用是将输入元素累积到一个可变的结果容器中（如ArrayList 是一个可变容器）；（可选操作）它会在所有元素都处理完毕后，将累积的结果转换为一个最终的表示。它支持串行和并行两者方式。

## Collectors工厂类

> Collectors 本身提供了关于 Collector 的常见汇聚实现 
>
> stream流的聚合实现也可在这实现（二次聚合）
>
> 都是静态方法，都返回Collector对象

| 方法                                                         | 描述                                                         | 分类   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |
| averagingDouble(ToDoubleFunction)                            | 它生成应用于输入元素的ToDoubleFunction的算术平均值。如果没有元素，则结果为0 | 平均值 |
| averagingInt(ToIntFunction)                                  |                                                              |        |
| averagingLong(ToLongFunction)                                |                                                              |        |
| collectingAndThen(Collector, Function)                       | 调整Collector收集器以执行其它的结束转换（对结果再操作）      | 叠加   |
| counting()                                                   | 计算输入元素的数量。如果没有元素，则结果为0                  | 计数   |
| groupingBy(Function)                                         | 对输入元素执行"group by"操作，根据分类函数对元素进行分组，并将结果返回到Map<K, List\<T>> | 分组   |
| groupingBy(Function, Collector)                              | 然后使用指定的下游Collector收集器对与给定键关联的值执行缩减操作。 |        |
| groupingBy(Function, Supplier, Collector)                    | 中间添加Supplier操作                                         |        |
| groupingByConcurrent(Function)                               | 并行，无法保证顺序                                           |        |
| groupingByConcurrent(Function, Collector)                    |                                                              |        |
| groupingByConcurrent(Function, Supplier, Collector)          |                                                              |        |
| joining()                                                    | 按遇见顺序将输入元素拼接成String                             | 拼接   |
| joining(CharSequence delimiter)                              | 以指定分隔符连接                                             |        |
| joining(CharSequence delimiter, <br />CharSequence prefix, CharSequence suffix) | 以指定分隔符连接，并在连接后的整体添加前缀、后缀             |        |
| mapping(Function, Collector)                                 | 可将map操作添加到参数                                        | map    |
| maxBy(Comparator)                                            | 根据给定的Comparator比较器生成最大元素                       | 大小   |
| minBy(Comparator)                                            | 根据给定的Comparator比较器生成最小元素                       |        |
| partitioningBy(Predicate)                                    | 它根据Predicate对输入元素进行分区，并将它们组织成`Map<Boolean, List<T>>` | 分区   |
| partitioningBy(Predicate, Collector)                         | 根据另一个Collector收集器减少每个分区中的值，并将它们组织成`Map<Boolean, D>` |        |
| reducing(BinaryOperator)                                     | 在指定的BinaryOperator下执行其输入元素的缩减                 | 归约   |
| reducing(T , BinaryOperator)                                 | 使用提供的标识（初值）在指定的BinaryOperator下执行其输入元素的缩减 |        |
| reducing(U , Functionr, BinaryOperator)                      | 在缩减之前转换元素                                           |        |
| summarizingDouble(ToDoubleFunction)                          | 将ToDoubleFunction应用于每个输入元素，并返回结果值的摘要统计信息 | 统计   |
| summarizingInt(ToIntFunction)                                |                                                              |        |
| summarizingLong(ToLongFunction)                              |                                                              |        |
| summingDouble(ToDoubleFunction)                              | 它生成应用于输入元素的ToDoubleFunction的总和。如果没有元素，则结果为0。 | 求和   |
| summingInt(ToIntFunction)                                    |                                                              |        |
| summingLong(ToLongFunction)                                  |                                                              |        |
| toCollection(Supplier)                                       | 按遇见顺序将输入元素累积到一个新的Collection收集器中         | 收集   |
| toConcurrentMap(Function, Function)                          | 将元素累积到ConcurrentMap中，其键和值是将提供的映射函数应用于输入元素的结果。 |        |
| toConcurrentMap(Function, Function, BinaryOperator)          | 并行操作                                                     |        |
| toConcurrentMap(Function, Function, BinaryOperator, Supplier) |                                                              |        |
| toList()                                                     | 将输入元素累积到一个新的List中，ArrayList                    |        |
| toMap(Function, Function)                                    | 将元素累积到Map中，其键和值是将提供的映射函数应用于输入元素的结果 |        |
| toMap(Function, Function, BinaryOperator)                    | 并行操作                                                     |        |
| toMap(Function, Function, BinaryOperator, Supplier)          |                                                              |        |
| toSet()                                                      | 输入元素累积到一个新的Set中，HashSet                         |        |