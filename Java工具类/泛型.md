# 简介

- 为什么使用泛型？

> 1. 不用进行强制类型转换
>
> 2. 避免运行时异常的安全隐患
>
> 在Java中增加泛型之前,泛型程序设计使用继承来实现（Object）
>
> 缺点：需要强制转换；可向集合中添加任意类型的对象,存在风险

- 泛型的使用

```java
List<String> list=new ArrayList<String>();

Java SE7及以后的版本中,构造方法中可以省略泛型类型。
List<String> list=new ArrayList<>0;
```

- 多态与泛型

```java
class Animal{}
class Cat extends Animal{}

//变量声明的类型必须匹配传递给实际对象的类型
//错误例子：
List<Animal> list=new ArrayList\<Cat>();
List<Object> list=new ArrayList\<String>();
```

# 使用

## 自定义泛型类

> 参数化类型

在继承或实现类或接口时，指定泛型的类型，重载的方法会替换相应的参数类型

泛型不一定是T，其他字母也可以，约定俗成：

> ？ 表示不确定的java类型。
>
> T 表示java类型。
>
> K, V 分别代表java键值中的Key Value。
>
> E 代表Element。

```java
public interface Test<T> {
    T aaa(T t);
}

public class Demo implements Test<Integer> {
    @Override
    public Integer aaa(Integer t) {
        // TODO Auto-generated method stub
        return null;
    }
}
```

## 自定义泛型方法

方法的泛型和类的泛型没有必然的联系，即使不是泛型类，也可以声明泛型方法

这里\<E>是指该方法为泛型的方法，和返回值没有关系，实现类Demo的方法aaa的入参由调用者决定，但是返回值是int

```java
public interface Test {
    <E> int aaa(E e);
}

public class Demo implements Test {
    @Override
    public <E> int aaa(E e) {
        return 0;
    }
}
```

## 同时出现

泛型类和泛型方法同时出现时，泛型T被实现类指定的泛型类型所替换，而参数e是由调用者决定的，当然如果想要返回类型由参数决定，也可以将Integer更改为E

```java
public interface Test<T> {
    <E> T aaa(E e, T t);
}


public class Demo implements Test<Integer> {
    @Override
    public <E> Integer aaa(E e, Integer t) {
        return null;
    }   
}
```

## 补充

> **PECS原则:**
>
> 生产者(Producer)使用extends,消费者(Consumer)使用super。
>
> PESC 这个助记符突出了通配符类型的基本原则 — Get and Put Principl
>
> `如果参数化类型表示一个 T 生产者，就使用 <? extends T>； 如果它表示一个 T 消费者， 就使用 <? super T> `
>
> `<? extends C> 适合大量做获取操作的情景，<? super C> 适合大量做添加操作的情景。`“*装苹果的盘子*”无法转换成“*装水果的盘子*”

<? super T>：类型为T或T的父类 — 上界通配符(Upper Bounds Wildcards）

<? extends U>：类型为U或U的子类 — 下界通配符(Lower Bounds Wildcards)