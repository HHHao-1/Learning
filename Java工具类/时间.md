# 简介

注：IS0-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法

## java.time

> LocalDate、LocalTime、LocalDateTime：
>
> ​	本地时间（人读的时间）
>
> Instant：
>
> ​	时间戳（计算机读的时间）
>
> ​	1970（unix元年）年1月1日0点0分0秒到此时此刻的一个毫秒数
>
> Duration、Period：
>
> ​	计算时间间隔、计算日期间隔
>
> OffsetTime、OffsetDateTime：
>
> ​	时间、日期时间偏移量运算
>
> ​	在ISO-8601日历系统中与UTC/Greenwich有偏移的时间
>
> ​	例如：10:15:30+01:00；2007-12-03T10:15:30+01:00
>
> Enum:
>
> ​	DayOfWeek：星期列表及对星期的操作方法
>
> ​	Month：月份列表及对月份的操作方法

## java.time.chromo

> 日期特殊格式，如：日本时间 台湾时间

## java.time.format

> 格式化时间

## java.time.temporal

> 时间矫正器，对时间运算
>
> 如：下一年，下个周日
>

## java.time.zone

> 对时区进行规范 
>

# 对比

> Java.time包下的时间实例是不可变的，是线程安全的，不管做什么改变都会产生一个新的实例。
>
> java8之前的时间实例可变的，不是线程安全的

- java8之前这样写，线程不安全

```java
public static void main(String[] args) throws Exception{
    SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
    Callable<Date> task = new Callable<Date>() {
        @Override
        public Date call() throws Exception {
            return sdf.parse("20161218");
        }
    };
    ExecutorService pool = Executors.newFixedThreadPool(10);
    List<Future<Date>> results = new ArrayList();
    for (int i = 0; i < 10; i++) {
        results.add(pool.submit(task));
    }
    for (Future<Date> future : results) {
        System.out.println(future.get());

    }
    pool.shutdown();
}
```

- 解决方法：加锁

```java
public class DateFormatThreadLocal {
    private static final ThreadLocal<DateFormat> df =
        ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyyMMdd"));

    public static Date convert(String source) throws ParseException {
        return df.get().parse(source);
    }
}
```

```java
public static void main(String[] args) throws Exception{
    Callable<Date> task = new Callable<Date>() {
        @Override
        public Date call() throws Exception {
            return DateFormatThreadLocal.convert("20161218");
        }
    };
    ExecutorService pool = Executors.newFixedThreadPool(10);
    List<Future<Date>> results = new ArrayList();
    for (int i = 0; i < 10; i++) {
        results.add(pool.submit(task));
    }
    for (Future<Date> future : results) {
        System.out.println(future.get());

    }
    pool.shutdown();
}
```

- java8这样写

```java
public static void main(String[] args) throws Exception{
    DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyyMMdd");
    Callable<LocalDate> task = () -> LocalDate.parse("20161218", dtf);
    ExecutorService pool = Executors.newFixedThreadPool(10);
    List<Future<LocalDate>> results = new ArrayList<>();
    for (int i = 0; i < 10; i++) {
        results.add(pool.submit(task));
    }
    for (Future<LocalDate> future : results) {
        System.out.println(future.get());
    }
}
```

# 使用

## Local*

LocalDate, LocalTime, LocalDateTime

这三个类的方法基本相同

```java
LocalDateTime ldt = LocalDateTime.now();
System.out.println(ldt);
LocalDateTime ldt2 = LocalDateTime.of(2015, 10, 19, 13, 22, 33);
System.out.println(ldt2);
LocalDateTime ldt3 = ldt.plusYears(2);
System.out.println(ldt3);
LocalDateTime ldt4 = ldt.minusMonths(2);
System.out.println(ldt4);

System.out.println(ldt.getYear());
System.out.println(ldt.getMonthValue());
System.out.println(ldt.getDayOfMonth());
System.out.println(ldt.getHour());
System.out.println(ldt.getMinute());
System.out.println(ldt.getSecond());

//        2020-10-02T14:34:24.484360
//        2015-10-19T13:22:33
//        2022-10-02T14:34:24.484360
//        2020-08-02T14:34:24.484360
//        2020
//        10
//        2
//        14
//        34
//        24
```

## Instant

```java
Instant ins1 = Instant.now();//默认获取UTC时区
System.out.println(ins1);
OffsetDateTime odt = ins1.atOffset(ZoneOffset.ofHours(8));
System.out.println(odt);
System.out.println(ins1.toEpochMilli());
Instant ins2 = Instant.ofEpochSecond(60);
System.out.println(ins2);

//        2020-10-02T06:06:07.454623Z
//        2020-10-02T14:06:07.454623+08:00
//        1601618767454
//        1970-01-01T00:01:00Z
```

## Duration&Period

```JAVA
//Duration :计算两个"时间"间的间隔
//Period :计算两个"日期"之间的间隔
Instant ins1 = Instant.now();
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {

}
Instant ins2 = Instant.now();
Duration duration = Duration.between(ins1, ins2);
System.out.println(duration.toMillis());//1002

LocalTime lt1 = LocalTime.now();
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {

}
LocalTime lt2 = LocalTime.now();
System.out.println(Duration.between(lt1, lt2).toMillis());//1001

LocalDate ld1 = LocalDate.of(2015, 1, 1);
LocalDate ld2 = LocalDate.now();
Period period = Period.between(ld1, ld2);
//P5Y9M1D IS0-8601标准 5年9个月1天
System.out.println(period);
```

## temporal

日期的操纵

- Temporaldjuster(函数接口): 时间矫正器。有时我们可能雷要

获取例如:将日期调整到“下个周日”等操作。

| Modifier and Type | Method and Description                                |
| :---------------- | :---------------------------------------------------- |
| Temporal          | adjustInto(Temporal temporal)<br />调整指定的时间对象 |

- TemporalAdjusters :该类通过静态方法提供了大量常用TemporalAdjuster的实现。

```java
//例如获取下个周日:
LocalDate nextSunday = LocalDate.now().with(
        TemporalAdjusters.next(DayOfWeek.SUNDAY)
);
```

```java
//TemporalAdjuster:时间校正器
LocalDateTime ldt = LocalDateTime.now();
System.out.println(ldt);
LocalDateTime ldt2 = ldt.withDayOfMonth(12);
System.out.println(ldt2);
LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));
System.out.println(ldt3);

//自定义：下个工作日
LocalDateTime ldt5 = ldt.with(s -> {
    LocalDateTime ldt4 = (LocalDateTime)s;
    DayOfWeek dow = ldt4.getDayOfWeek();
    if(dow.equals(DayOfWeek.FRIDAY)){
        return ldt4.plusDays(3);
    }
    if(dow.equals(DayOfWeek.SUNDAY)){
        return ldt4.plusDays(2);
    }else {
        return ldt4.plusDays(1);
    }
});
System.out.println(ldt5);

//        2020-10-02T14:56:42.864482
//        2020-10-12T14:56:42.864482
//        2020-10-04T14:56:42.864482
//        2020-10-05T14:56:42.864482
```

## format

```java
//DateTimeFormatter :格式化时间/日期
DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE;
LocalDateTime ldt = LocalDateTime.now();
String strDate = ldt.format(dtf);
System.out.println(strDate);
DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");
String strDate2 = dtf2.format(ldt);
System.out.println(strDate2);

LocalDateTime newDate = ldt.parse(strDate2, dtf2);
System.out.println(newDate);

//        2020-10-02
//        2020年10月02日 15:07:35
//        2020-10-02T15:07:35
```

## zone

ZonedDate, ZonedTime, ZonedDateTime

其中每个时区都对应着ID,地区ID都为“区域)/城市)”的格式，如: Asia/Shanghai等

Zoneld:该类中包含了所有的时区信息

> ​	getAvailablezonelds() :可以获取所有时区时区信息
>
> ​	of(id) :用指定的时区信息获取Zoneld对象

```java
Set set = ZoneId.getAvailableZoneIds();
set.stream().forEach(System.out::println);

LocalDateTime ldt = LocalDateTime.now(ZoneId.of("Europe/Tallinn"));
System.out.println(ldt);
ZonedDateTime zdt= ldt.atZone(ZoneId.of("Asia/Shanghai"));
System.out.println(zdt);

//        ......
//        US/Pacific
//        Europe/Monaco
//        2020-10-02T10:21:40.826512
//        2020-10-02T10:21:40.826512+08:00[Asia/Shanghai]
```

