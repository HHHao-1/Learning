# 集合框架

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1giy1cblrv6j31040fqjtx.jpg" alt="image-20200921095415282" style="zoom:50%;" />

![Pasted Graphic 1](https://tva1.sinaimg.cn/large/007S8ZIlly1giy1f81ki4j31oe0sydj1.jpg)

**序列（List）、队列（Queue），集合（Set，无序、不允许重复）**

# 数据结构

**数组**：其实所谓的数组指的就是一组相关类型的变量集合，并且这些变量彼此之间没有任何的关联。存储区间连续，占用内存严重，数组有下标，查询数据快，但是增删比较慢；

**链表**：一种常见的基础数据结构，是一种线性表，但是不会按照线性的顺序存储数据，而是每一个节点里存到下一个节点的指针。存储区间离散，占用内存比较宽松，使用链表查询比较慢，但是增删比较快；

**哈希表**：Hash table 既满足了数据的快速查询（根据关键码值key value 而直接进行访问的数据结构），也不会占用太多的内存空间，十分方便。哈希表是**数组加（链表或红黑树）**组成。

（1）ArrayList：

> 优点：操作读取操作效率高，基于数组实现的，可以为null值，可以允许重复元素，有序，异步。
>
> 缺点：由于它是由动态数组实现的，不适合频繁的对元素的插入和删除操作，因为每次插入和删除都需  要移动数组中的元素。

（2）LinkedList:

> 优点：LinkedList由双链表实现，增删由于不需要移动底层数组数据，其底层是链表实现的，只需要修改链表节点指针，对元素的插入和删除效率较高。
>
> 缺点： 遍历效率较低。HashMap和双链表也有关系。

## HashMap

### 节点

HashMap是一个集合，键值对的集合,源码中每个节点用Node<K,V>表示

```java
static class Node<K,V> implements Map.Entry<K,V> {
   final int hash;
   final K key;
   V value;
   Node<K,V> next;
```

Node是个内部类，有：key的hash值，key为键，value为值，next指向下一个元素

### 数据结构

HashMap的数据结构为 **数组+(链表或红黑树)**：

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gj8we729s3j30wf0famxt.jpg)

为什么采用这种结构来存储元素呢？

**数组的特点：查询效率高，插入，删除效率低**。

**链表的特点：查询效率低，插入删除效率高**。

在HashMap底层使用数组加（链表或红黑树）的结构完美的解决了数组和链表的问题，使得查询和插入，删除的效率都很高。

### 存储元素过程

```java
HashMap<String,String> map = new HashMap<String,String>();
map.put("刘德华","张惠妹");
map.put("张学友","大S");
```

现在我要把键值对 “刘德华”,”张惠妹”存入map:

> **第一步：计算出键“刘德华”的hashcode，该值用来定位要将这个元素存放到数组中的什么位置。**

**什么是hashcode？**

在Object类中有一个方法:

```java
public native int hashCode();
```

该方法用native修饰，所以是一个本地方法，所谓本地方法就是非java代码，这个代码通常用c或c++写成，在java中可以去调用它。

调用这个方法会生成一个int型的整数，我们叫它哈希码，哈希码和调用它的对象地址和内容有关.

**哈希码的特点是:**

**对于同一个对象如果没有被修改（使用equals比较返回true）那么无论何时它的hashcode值都是相同的**

**对于两个对象如果他们的equals返回false,那么他们的hashcode值也有可能相等**

**通过hashcode值和数组长度取模我们可以得到元素存储的下标**

刘德华的`hashcode为20977295`数组长度为 16则要存储在数组索引为20977295%16 = 1的地方

> **第二步：找到数组中的位置后，有两种情况**

这时有两种情况:

1. 数组索引为1的地方是空的，这种情况很简单，直接将元素放进去就好了。

2. 已经有元素占据了索引为1的位置，这种情况下我们需要判断一下该位置的元素和当前元素是否相等，使用equals来比较。

如果使用默认的规则是比较两个对象的地址。也就是两者需要是同一个对象才相等，当然我们也可以重写equals方法来实现我们自己的比较规则最常见的是通过比较属性值来判断是否相等。

**如果两者相等则直接覆盖**，**如果不等则在原元素下面使用链表的结构存储该元素**

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gj8wihvy9vj30fe06tt90.jpg)

每个元素节点都有一个next属性指向下一个节点，这里由数组结构变成了数组+链表结构,红黑树又是怎么回事呢？

因为链表中元素太多的时候会影响查找效率，所以当链表的元素个数达到8的时候使用链表存储就转变成了使用红黑树存储，原因就是**红黑树是平衡二叉树，在查找性能方面比链表要高**.

### 两个重要参数

**HashMap中有两个重要的参数：**

> 初始容量大小和加载因子**，初始容量大小是创建时给数组分配的容量大小，默认值为16，**用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用rehash方法将数组容量增加到原来的两倍，专业术语叫做扩容**.

**在做扩容的时候会生成一个新的数组，原来的所有数据需要重新计算哈希码值重新分配到新的数组，所以扩容的操作非常消耗性能.**

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gj8wjjt2txj30e307sq3v.jpg)

创建HashMap时我们可以通过合理的设置初始容量大小来达到尽量少的扩容的目的。加载因子也可以设置，但是除非特殊情况不建议设置.

# Collection

```java
public interface Collection<E>extends Iterable<E>
```

| **序号** | **方法**                | **描述**                                 | **分类** |
| -------- | ----------------------- | ---------------------------------------- | -------- |
| 1        | add (E)                 | 添加元素                                 | 增       |
| 2        | addAll (Collection)     | 添加一个集合的所有元素                   |          |
| 3        | remove(Object)          | 移除一个元素                             | 删       |
| 4        | removeAll(Collection)   | 移除一个集合内包含的所有元素             |          |
| 5        | removeIf(Predicate)     | 对移除操作用谓词进行判断                 |          |
| 6        | retainAll(Collection)   | 仅保留参数所包含的元素                   |          |
| 7        | clear()                 | 清除所有元素                             |          |
| 8        | contains (Object)       | 是否包含一个元素                         | 判断     |
| 9        | containsAll(Collection) | 是否包含一个集合内包含的所有元素         |          |
| 10       | equals (Object)         | 将指定的对象与此集合进行比较以获得相等性 |          |
| 11       | isEmpty()               | 是否为空                                 |          |
| 12       | toArray()               | 返回数组Object[]                         | 返回值   |
| 13       | toArray (T[])           | 返回指定类型数组                         |          |
| 14       | toArray (IntFunction)   | JDK8之后；                               |          |
| 15       | iterator()              | 返回此集合中的元素的迭代器               |          |
| 16       | parallelStream()        | 返回并行流                               |          |
| 17       | size()                  | 返回大小int                              |          |
| 18       | spliterator()           | 返回Spliterator\<E>(可拆分迭代器对象)    |          |
| 19       | stream()                | 返回流                                   |          |
| 20       | hashCode ()             | 返回此集合的哈希码值                     |          |

- 集合补充

> **获取数据：** 
>
> - List、Queue --- get()
> - Set --- 无序表，无法获取第n个元素，通过遍历获取或转换成数组获取
>
> **修改数据：**
>
> - List、Queue --- set（index，value）
> - Set --- 遍历删除指定元素，再添加
>
> **关于Set：**
>
> - set在读取数据时不允许删除操作，加break（既只能移除一个）；移除多个用removeall移除一个集合
>

```java
for (Cat cat : set) {
 if ("花花".equals(cat.getName()) {
    set. remove(cat); 
		break;
  }
}
Set<Cat> set1=new HashSet<Catx();
for (Cat cat : set) {
   if (cat.getMonth()<5) {
      //set.remove(cat);
      set1.add(cat);
  }
} 
set.removeAll(set1);        
```

- hashCode&equal

<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1giy4tb38ktj31bm0ni7e6.jpg" alt="Pasted Graphic 2" style="zoom: 15%;" />          <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gj1zshvhn5j31iw0qumzu.jpg" alt="Pasted Graphic 3" style="zoom: 13%;" />    

> 1. 内存中开辟三个区域进行存储
>
> 数据放到哪个桶，需要规则，规则如：n%3
>
> 2. 查找数据时：
>
> 使用hashCode()得到的相同哈希吗值的对象在同一个桶中，而要继续区分同一个桶中的不同对象，需要使用equals()方法；（hashcode相同不一定是同一个对象）
>
> 3. 重写equals()方法，通常有必要重写hashCode()方法
>
> 数值、字符串排序：数字升序、字符ascii码升序

```java
//hashCode()
public int hashCode() { 
  final int prime = 31;
  int result = 1;
  result = prime * result + age;
  result = prime * result + ((name == null) ? 0 : name.hashCode());
  result = prime * result + ((species == null) ? 0 : species.hashCode());
  return result;
}

//equals()
public boolean equals(Object obj){
  if(this == obj)
    return true;
  if(obj.getClass()==Cat.class){
    Cat cat=(Cat)obj;
    return cat.getName().equals(name)&&(cat.getAge()==age)
      &&cat.getSpecies().equals(species);
  }
  return false;
}
```

- toArray

```java
List<String> a = new ArrayList<>();
a.add("qqq");
a.add("www");

Object[] o = a.toArray();

String[] z = a.toArray(new String[2]);

//java8之后
String[] y = a.toArray(String[]::new);
//java8，String[]::new means size -> new String[size]
String[] x = a.stream().toArray(s -> new String[s]);
```

# Map

```java
public interface Map<K,V>
```

| **序号** | **方法**                        | 分类     |
| -------- | ------------------------------- | -------- |
| 1        | put(K, v)                       | 增/改    |
| 2        | putAl1 (Map)                    |          |
| 3        | putIfAbsent (K, v)              |          |
| 4        | remove(Object)                  | 删       |
| 5        | remove (Object, Object)         |          |
| 6        | clear()                         |          |
| 7        | replace(K, v)                   | 改       |
| 8        | replace(K, V, V)                | 判断修改 |
| 9        | replaceAll(BiFunction)          |          |
| 10       | compute (K, BiFunction)         |          |
| 11       | computelfAbsent(K, Function)    |          |
| 12       | computelfPresent(K, BiFunction) |          |
| 13       | merge (K, V, BiFunction)        |          |
| 14       | get (Object)                    | 查       |
| 15       | getOrDefault(Object, v)         |          |
| 16       | entrySet()                      |          |
| 17       | keySet()                        |          |
| 18       | values ()                       |          |
| 19       | forEach(Biconsumer)             | 循环     |
| 20       | isEmpty()                       | 判断     |
| 21       | equals (Object)                 |          |
| 22       | containsKey (Object)            |          |
| 23       | containsValue (Object)          |          |
| 24       | hashCode ()                     | 返回值   |
| 25       | size()                          |          |

- 示例

```java
Map<String,String> map = new HashMap<>();
map.put("key", "1");

/*
 * 判断插入
 */
//如果map.get(key)==null则map.put(key, value)
String value1 = map.putIfAbsent("key", "123");
String value2 = map.computeIfAbsent("key", k -> "123");
//如果map.get(key)!=null则map.put(key, value)
String value3 = map.computeIfPresent("key", (k,v) -> "123");
//对value进行操作，这里相当于map.put(key, value)
String value4 = map.compute("key", (k,v) -> "123");
map.compute("key", (k, v) -> (v == null) ? "123" : v.concat("123"));

/*
 * merge
 */
//这里1是oldValue
map.put("name", "1");
//这里1是newValue
map.merge("name", "1", (oldValue, newValue) -> oldValue + newValue);
//这里1是newValue，oldValue是null
map.merge("count", "1", (oldValue, newValue) -> oldValue + newValue);
//Map统计总成绩
List<StudentScore> list = new ArrayList<>();
list.add(new StudentScore(1, "chinese", 110));
list.add(new StudentScore(1, "english", 120));
list.add(new StudentScore(1, "math", 135));
list.add(new StudentScore(1, "chinese", 99));
......
Map<Integer, Integer> map = new HashMap<>();
list.stream().forEach(studentScore -> map.merge(studentScore.getSid(), studentScore.getScore(), Integer::sum));

/*
 * 迭代
 */
// 传统的Map迭代方式
for (Map.Entry<String, Object> entry : infoMap.entrySet()) {
    System.out.println(entry.getKey() + "：" + entry.getValue());
}
// JDK8的迭代方式
infoMap.forEach((key, value) -> {
    System.out.println(key + "：" + value);
});

/*
 * 判断替换，replaceAll
 */
map.put("12","3");
map.replaceAll((s1, s2) -> {
    if (s1.length() <= 3) {
        s2 = "123";
    }
    return s2;
});
System.out.println(map.get("12"));//123
```

# Iterable

```java
public interface Iterable<T>
```

| 方法               | 描述                     |
| ------------------ | ------------------------ |
| forEach (Consumer) | 对每个元素执行给定的操作 |
| iterator()         | 返回迭代器对象           |
| spliterator()      | 返回可拆分迭代器对象     |

- forEach

```java
default void forEach(Consumer<? super T> action)

//The default implementation behaves as if:
for (T t : this)
  action.accept(t);
```

# Iterator

```java
public interface Iterator<E>
```

| 方法                       | 描述                                   |
| -------------------------- | -------------------------------------- |
| forEachRemaining(Consumer) | 对每个剩余元素执行给定的操作           |
| hasNext ()                 | 如果迭代具有更多元素，则返回 true      |
| next()                     | 返回迭代中的下一个元素                 |
| remove ()                  | 从集合中删除此迭代器返回的最后一个元素 |

```java
Iterator <String> it=set.iterator();
while(ithasNext()){
  System.out.print(it.next)+" ");
}
```

# 排序

> 集合中的基本数据类型排序 --- 自然顺序，数字升序
>
> 集合中的字符串排序 --- 自然顺序，字符ascii码升序，字符串首字母ascii码升序
>
> Comparator接口 --- 对象排序
>
> Comparable接口 --- 对象排序

- **Arrays、Collections的sort方法**

> 基本数据类型&字符串排序

```java
//数组排序
int[]] arr={15,31,23,46,65,12};
Arrays.sort(arr);

//工具类Collections排序
//使用Collections类的sort()方法：sort(List<T> list)
//根据元素的自然顺序对指定列表按升序进行排序
Collections.sort(list);
```

- **Comparator和Comparable比较**

| Comparator                            | Comparable                              |
| ------------------------------------- | --------------------------------------- |
| 位于java.util包                       | 位于java.lang包                         |
| 在要比较的类的外部实现该接口          | 在要比较的类上实现该接口                |
| 集合调用sort方法时,要指定Comparator的 | 调用sort方法时,只需指定集合名即可实现类 |

- **Comparable接口**

> 只有一个方法，是抽象方法
>
> **int compareTo(T o)**
>
> 该对象小于、等于或大于指定对象,则分别返回负整数、零或正整数

```java
public int compareTo(Goods o) {
  double price1=this.getPrice();
  double price2=o.getPrice();
  int n=new Double(price1-price2).intValue();
  return n;
}
```

- **Comparator接口**

> int compare(T o1, T o2)，抽象方法
>
> 方法返回值含义（重写需满足,若降序则代码中取反即可）：
>
> 1. 如果o1<o2,返回负整数
>
> 2. 如果o1==o2,返回0
>
> 3. 如果o1>o2,返回正整数

```java
@Override
public int compare(Cat o1, Cat o2) {//按名字升序排序
  String name1 = o1.getName();
  String name2 = o2.getName();
  int n = name1.compareTo(name2);
  return n;
}

@Override
public int compare(Cat o1, Cat o2) {//按年龄降序排序
  int age1 = o1.getMonth();
  int age2 = o2.getMonth();
  return age2-age1;
}
```

