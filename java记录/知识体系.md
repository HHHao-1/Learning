# JAVA基础

## JDK

JDK (Java Development Kit) 包含：
> - 基本类库
> - 开发工具
>   - jar：打包工具
>   - javac：编译
>   - javap：反编译
>   - javadoc：文档生成器
>   - jdb – debugger：查错工具 
>   - java：运行编译后的java程序
>   - Jconsole: 系统调试和监控工具
>   - Javah：产生可以调用Java过程的C过程、或建立能被Java程序调用的C过程的头文件
>   - appletviewer：小程序浏览器，执行HTML文件上的Java小程序的Java浏览器
> - 运行环境
>   - JRE (Java Runtime Environment)
>     - 核心类库
>     - 字节码编译
>       - JVM

## equals和==

==：

> - 基本类型: 比较引用地址是否相同
>
> - 引用类型：看引用的对象是否是同一个!
>

equals:

> - 重写object方法：自己定义规则
>
>   - 常见的对象都已经重写了比较代码（如：比较内容是否相同）
>
>   - equals的重写伴随着hashcode的重写
>
> - 不重写：比较引用地址是否相同，等同==
>

## 递归

> 方法自已调用自己

**递归的分类：2种**

①直接递归称为方法自身调用自己

②间接递归可以使用A方法调用B方法，B方法调用C方法，C方法再调用A方法

**注意事项：**

1.**递归一定要有条件限定**，保证能停止下来，否则会发生栈内存溢出

2.在递归虽然有限定条件，但是**递归次数不能太多**。否则也会发生栈内存溢出

3.**构造方法，禁止递归**

**示例：**

```java
//使用递归计算5!
public class Test {
    public static void main(String[] args) {
        int s = f(100);
        System.out.println(s);
    }

    private static int f(int n) {
        if(n==1){
            return 1;
        }
        return n*f(n-1);
    }
}
```

![Pasted Graphic 17](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjdgy2s3g0j30f90fgacj.jpg)

# JAVA进阶

## 动态代理

> 代理模式：就是调用者通过代理类访问具体对象
>
> 动态代理：
>
> - 将代理类从编译期间放到运行期间，运行期间自动根据不同的本体生成不同的代理类
>
> - 两种实现方法：JDK，CGLIB
>   - JDK被代理类没有实现接口，不能实现动态代理，而CGLIB可以

![Pasted Graphic 6](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjdi9p78ucj30oe0a10wg.jpg)

![代理模式](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjdj2k1r6hj30k10dymyd.jpg)



```java
public interface Speaker {
    void speak();
}
```

```java
public class ASpeaker implements Speaker{
    @Override
    public void speak() {
        System.out.println("我要赔偿1");
    }
}
```

```java
public class BSpeaker implements Speaker{
    @Override
    public void speak() {
        System.out.println("我要赔偿2");
    }
}
```

```java
public class StaticProxy implements Speaker {

    ASpeaker aSpeaker = new ASpeaker();

    @Override
    public void speak() {
        System.out.println("引用法律条文");
        System.out.println("我要赔偿");
        System.out.println("引用道德伦理");
    }
}
```

```java
public class JDKDynamicProxy implements InvocationHandler {

    private  Object object;

    public JDKDynamicProxy(Object object) {
        super();
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object obj = null;
        if(method.getName().equals("speak")){
            System.out.println("引用法律条文");
            obj = method.invoke(object,args);
            System.out.println("引用道德伦理");
        }
        return obj;
    }

    public  Object getProxyInstance(){
        //属性是接口对象的话，第二个参数可以这样：new Class[]{Test.class}
        return Proxy.newProxyInstance(object.getClass().getClassLoader(),
                                      object.getClass().getInterfaces(),this);
    }
}
```

```java
public class CGLIBDynamicProxy implements MethodInterceptor {
    private  Object object;

    public CGLIBDynamicProxy(Object object) {
        super();
        this.object = object;
    }
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        Object obj = null;
        if(method.getName().equals("speak")){
            System.out.println("引用法律条文");
            obj = method.invoke(object,args);
            System.out.println("引用道德伦理");
        }
        return obj;
    }

    public  Object getProxyInstance(){
        return Enhancer.create(object.getClass(),this);
    }
}
```

```java
public class DemoTest {

    @Test
    //静态代理
    public void judgeTest1(){
        System.out.println("你要干嘛");
        Speaker speaker = new StaticProxy();
        speaker.speak();

    }

    @Test
    //动态代理：JDK
    public void judgeTest2(){
        System.out.println("你要干嘛");
        ASpeaker aSpeaker = new ASpeaker();
        JDKDynamicProxy JDKDynamicProxy = new JDKDynamicProxy(aSpeaker);
        Speaker A = (Speaker) JDKDynamicProxy.getProxyInstance();
        A.speak();
        System.out.println("---------");
        BSpeaker bSpeaker = new BSpeaker();
        Speaker B = (Speaker) JDKDynamicProxy.getProxyInstance();
        B.speak();
    }

    @Test
    //动态代理：CGLIB
    public void judgeTest3(){
        System.out.println("你要干嘛");
        ASpeaker aSpeaker = new ASpeaker();
        CGLIBDynamicProxy cglibDynamicProxy = new CGLIBDynamicProxy(aSpeaker);
        Speaker A = (Speaker) cglibDynamicProxy.getProxyInstance();
        A.speak();
    }
}
```

# JAVA web

## Web架构&框架

![16C4FE27-AD2B-4411-A547-6807A1FF292B](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmxnb5021j30m80arjt0.jpg)

![image-20200831145016862](https://tva1.sinaimg.cn/large/007S8ZIlly1gi9zvwkk9mj30lx0egab0.jpg)

### 三层架构

> 1.表示层（web层） ：包含JSP, Servlet等web相关的内容
>
> 2.业务逻辑层（Service）：处理业务,
>
> 3.数据层（DAO Data Access object）：也叫持久层,封装了对数据库的访问细节,一般写DAO类

### MVC框架

> Model（模型）： 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
>
> View（视图）：视图代表模型包含的数据的可视化。
>
> Controller（控制器）：控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开来。


