# java.lang

> java.lang包是Java语言的核心类库，包括了运行Java程序必不可少的系统类，系统都会在运行时自动地引入java.lang包，所以这个包的加载是缺省的。
>
> language，语言包，XML和HTML中语言属性也都叫lang

# AWT

(Abstract Window Toolkit)：抽象窗口工具包

> ​		该包提供了一套与本地图形界面进行交互的接口，是建立和设置Java的图形用户界面的基本工具。AWT中的图形函数与操作系统所提供的图形函数之间有着一一对应的关系，称之为peers，当利用AWT编写图形用户界面时，实际上是在利用本地操作系统所提供的图形库。由于不同操作系统的图形库所提供的样式和功能是不一样的，在一个平台上存在的功能在另一个平台上则可能不存在。为实现“一次编写，到处运行”，AWT通过牺牲功能来实现平台无关性，也即AWT所提供的图形功能是各种操作系统所提供的图形功能的交集。

# Java采用unicode编码

2个字节表示一个字符

# ""，\u0000， NULL 

> "" ：空字符串
>
> \u0000 ：空格
>
> NULL：表示空

# 发布版本说明

> alphal--内部测试版
>
> beta--外部测试版
>
> release--最终正式发布版

# String[] args

> String[] args是main函数的形式参数,可以用来获取命令行用户输入进去的参数
>
> args是arguments的缩写默认名

```java
public class test {
  public static void main(String[] args) {
    for (int i = 0; i < args.length; i++) {
      System.out.println(args[i]);}}}
```

```js
➜  java测试 java test.java 测试1 测试2
测试1
测试2
```

# Serializable

> java序列化机制是通过类的serialVersionUID来验证版本一致性的。在反序列化时，jvm会把传来的字节流中的serialVersionUID和本地相应实体类的serialVersionUID进行比较，如果相同就认为一致，可以进行反序列化，否则出现InvalidCastException异常
>
> serialVersionUID有两种显式生成方式：
>
> 1.默认的1L，比如：private static final long serialVersionUID = 1L;
>
> 2.根据类名、接口名、成员方法、属性等来生成一个64位的哈希字段 = xxxL;
>
> 当实现Serializable接口对象没有显式定义一个serialVersionUID时，java序列化会根据编译的Class自动生成一个serialVersionUID，这种情况下只要class文件发生变化，serialVersionUID就会改变，否则一直不变

```java
//作用：给实体增加一个持久化的能力
public class User implements Serializable {}
```

# Scanner

```java
Scanner sc = new Scanner(System.in)
sc.close()
```

# 标签

```java
loop1: for(;;) {
   inner: for(;;) {
     break loop1;
   }
}
   
for循环中的loop是continue和break的标记，可以在for前面写任意的标记；∑
比如loop1，loop2，在循环中可以break loop1；continue loop1
```

# jpcap

> java自带的类库能够实现网络层及以上层次的编程，但是对于数据链路层无能为力。jpcap是一个能够帮助java程序实现对数据链路层操作的jar包。值得一提的是，jpcap是基于winpcap或者libpcap的，winpcap是windows系统的，而libpcap是linux系统的（包括ubuntu等衍生系统），jpcap是中间部件，通过调用winpcap/libpcap的方法实现对网卡的操作。java通过使用jpcap屏蔽了底层系统的差异。

# 获取文件路径

> 工程名为TEST为例：
>
> (1)得到包含工程名的当前页面全路径：request.getRequestURI()
> 结果：/TEST/test.jsp
>
> (2)得到工程名：request.getContextPath()
> 结果：/TEST
>
> (3)得到当前页面所在目录下全名称：request.getServletPath()
> 结果：如果页面在jsp目录下 /TEST/jsp/test.jsp
>
> (4)得到页面所在服务器的全路径：application.getRealPath("页面.jsp")
> 结果：D:\resin\webapps\TEST\test.jsp
>
> (5)得到页面所在服务器的绝对路径：absPath=new java.io.File(application.getRealPath(request.getRequestURI())).getParent();
> 结果：D:\resin\webapps\TEST

# bit和byte

```shell
1. 名称不同:

> bit是比特，是英文 binary digit的缩写。而Byte是字节又叫bait。

2. 意义不同:

> bit：是表示信息的最小单位，是二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量。一般来说，比特的信息量可以表现出2的n次方种选择。
> Byte：是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位，也表示一些计算机编程语言中的数据类型和语言字符。

3. 大小不同:

> bit：是表示信息的最小单位，只有两种状态：0和1。
> Byte：数据类型（字节型）用一个字节（Byte）储存，可区别256个数字，取值范围：0到255。 Byte是从0-255的无符号类型，所以不能表示负数。

4. 其他方面:

> 数据存储是以“字节”（Byte）为单位，数据传输大多是以“位”（bit，又名“比特”）为单位，一个位就代表一个0或1（即二进制），每8个位（bit，简写为b）组成一个字节（Byte，简写为B），是最小一级的信息单位。
> 也就是说实际上普通的计算机系统是无法精确读取和定位到比特(bit)级的信息。
```

# BigDecimal

> 用来对超过16位有效位的数进行精确的运算。

# resource下的文件路径

```java
//获取路径并解决乱码
URL url = this.getClass().getClassLoader().getResource("annex.json");
try {
  String filePath = URLDecoder.decode(url.getPath(), "UTF-8");
} catch (UnsupportedEncodingException e) {
  e.printStackTrace();
}
```

> 注：如果取不到
>
> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1giw6kp5z5hj30pg0ikdmy.jpg" alt="2E65ED16-097B-429C-8257-DB0DB88C7768" style="zoom:50%;" />

# @Value的使用

Springboot通过@Value注解将配置文件中的属性注入到容器内组件中

可用在@Controller @Service @Configuration @Component等Spring托管的类中

**1.普通字符串注入**

配置文件中：`name: zs`

@Value注入

```java
@Value("${name}")
public String name;
```

```java
@Value("${name:zch}") //带默认值，若name=  ，则为zch
public String name;// 此时，若配置文件中没有name这个key，变量name的值为zch
```

**2.常用的int、boolean类型**

port: 8888

flag: true

@Value注入

```java
@Value("${port}")
public int port;

@Value("${flag}")
public boolean flag;
```

**3.数组类型**

id: 1,2,3

@Value注入

```java
@Value("${id}")
public int[] idArray;
```

**4.list类型**

id: 1,2,3

@Value注入

```java
@Value("#{'${id}'.split(',')}")
public List<String> idList;
```

**5.map类型**

```yml
user: "{name: 'zs',age: '23'}" #注意此值用双引号包裹
```

@Value注入

```java
@Value("#{${user}}") 
public Map<String,String> userInfo;
```

# 接口实现Object类吗？

> 接口是用来描述行为的。**类是实体，接口是行为**，这就好像在说“游泳是鱼”，“吃饭是人”

# 静态方法能否被继承？

> 不能。因为静态方法只与类相关，不与具体实现相关

# java中的虚方法

> Java中虽然没有virtual关键字，但是java方法默认就是虚函数，而特例才是final，不允许继承者重写。派生类大部分情况都为了通过重写方法实现代码的扩展，少数才是例外

# 内部类调用外部类对象

> 类名.this.方法/属性

# Bean注解

Spring的注解形式：@Repository、@Service、@Controller，它们分别对应存储层Bean，业务层Bean，和展示层Bean。（@Repository用在DAO层实现类）

@Repository、@Service、@Controller 和 @Component 将类标识为Bean。

@Component 是一个泛化的概念，仅表示一个组件 (Bean) ，可以作用在任何层次。

# native关键字

native 是用做java 和其他语言（如c++）进行协作时用的，也就是native 后的函数的实现不是用java写的

# 多态

父类引用指向子类对象，这就叫多态

# URI、URL、URN

URL、URN是URI的子集，说明了怎样标识资源

使用 `URI` 管理 `URL` 的编码和解码，并使用 `URI.toURL()` 和 `URL.toURI()` 进行转换。

![image-20201007173055000](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjgwggb0xkj30m70aeadb.jpg)

![image-20201007173125615](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjgwgxrmq7j30lk08cn1x.jpg)

# try-with-resources

`try-with-resources`会自动关闭`try()`中的资源，并且将先关闭后声明的资源。

`try-with-resources` 声明要求其中定义的变量类型实现 AutoCloseable 接口。

```java
try (InputStream in = new FileInputStream(src);
     OutputStream out = new FileOutputStream(dst)) {
    byte[] buff = new byte[1024];
    int n;
    while ((n = in.read(buff)) >= 0) {
        out.write(buff, 0, n);
    }
```

