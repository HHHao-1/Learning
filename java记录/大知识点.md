#  Object类

| 方法描述                                 |                                                              | 分类     |
| ---------------------------------------- | ------------------------------------------------------------ | -------- |
| String toString()                        | 返回对象的字符串表示形式。                                   | 常用     |
| boolean <br />equals(Object obj)         | 比较两个对象的值是否相等。                                   |          |
| int hashCode()                           | 返回对象的哈希码值。                                         |          |
| protected Object clone()                 | 创建并返回此对象的副本。                                     | 副本     |
| Class<?> getClass()                      | 返回此对象的运行时的类。                                     | 反射     |
| protected void finalize()                | 当垃圾回收器确定不再有对该对象的引用时，由垃圾回收器在对象上调用。 | 回收     |
| void wait()                              | 使当前线程等待，直到另一个线程为此对象<br />调用notify（）方法或notifyAll（）方法。 | 线程相关 |
| void <br />wait(long timeout)            | 使当前线程等待，直到另一个线程为此对象<br />调用notify（）方法或thenotifyAll（）方法，<br />或者经过指定的时间。 |          |
| void <br />wait(long timeout, int nanos) | 使当前线程等待，直到另一个线程为此对象<br />调用notify（）方法或notifyAll（）方法，<br />或其他线程中断了当前线程，或经过了一定的时间。 |          |
| void notify()                            | 唤醒正在此对象的监听器上等待的单个线程。                     |          |
| void notifyAll()                         | 唤醒正在此对象的监视器上等待的所有线程。                     |          |

# 递归

> 方法自已调用自己

**递归的分类：2种**

①直接递归称为方法自身调用自己

②间接递归可以使用A方法调用B方法，B方法调用C方法，C方法再调用A方法

**注意事项：**

1.递归一定要有条件限定，保证能停止下来，否则会发生栈内存溢出

2.在递归虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出

3.构造方法，禁止递归

**示例：**

```java
public class Test01 {

 public static void main(String[] args) {
     //a();
     b(1);
 }

 /**
	 * 在递归中虽然有限定条件，但是递归次数不能太多，否同也会发生栈内存溢出

	 */
    private static void b(int i) {
        System.out.println(i);
        if(i==200000){
            return ;
        }
        b(++i);
    }

    /**
	 * 递归一定要有条件限定，保证能够停止下来，否则会发生
	 * Exception in thread "main" java.lang.StackOverflowError
	 */
    private static void a() {
        System.out.println("a方法");
        a();
    }

    /**
	 * 构造方法禁止递归
	 *  编译错误，构造方法是创建对象使用的，一直递归会导致内存中有无数多个对象
	 */
    public Test01(){
        //Test01();
    }
}
```

**使用递归计算1-n之间的和：**

```java
public class Test02 {
    public static void main(String[] args) {
        int s = sum(100);
        System.out.println(s);
    }

    /**
	 * 定义一个方法，使用递归计算1-n之间的和
	 *  1+2+3+..n
	 *  n+(n-1) +(n-1)+..1;
	 *  已知 最大值n  最小值1
	 *  使用递归必需明确
	 *  	1.递归的结束条件：获取到1的时候结束
	 *  	2.递归的目标：获取下一个被加的数字(n-1)
	 */
    private static int sum(int n) {
        //获取到1的时候
        if(n==1){
            return 1;
        }
        //获取下一个被加的数字 (n-1)
        return n+sum(n-1);
    }
}
```

# 判空

依赖包：commons-lang3

这个包为我们提供了两个判空的方法，分别是

> StringUtils.isEmpty(CharSequence cs)
>
> StringUtils.isBlank(CharSequence cs)

1. StringUtils.isEmpty

这个方法判断的是字符串是否为null或者其长度是否为零。

isEmpty的源码如下：

```java
public static boolean isEmpty(CharSequence cs) { 
    return cs == null ll cs.length() == 0;
}
```

2. StringUtils.isBlank

这个方法除了判断字符串是否为null和长度是否为零，还判断了是否为空格，如果是空格也返回true。

isBlank的源码如下：

```java
public static boolean isBlank(CharSequence cs) { 
    int strLen = length(cs);
    if (strLen == 0) { 
        return true;
    }else {
        for(int i=0; i < strLen; ++i) {
            if (!Character. iswhitespace(cs.charAt(i))) { 
                return false;
            }
        }
        return true;
    }
}
```

length(cs)的方法如下：

```java
public static int length(CharSequence cs) { 
    return cs == null ? 0 : cs.length();
}
```

CharSequence：

```
CharSequence是个接口
实现了这个接口的类有：CharBuffer、String、StringBuffer、StringBuilder这四个类。
```

3. 总结

- isEmpty：如果是null或者“”则返回true。
- isBlank：如果是null或者“”或者空格则返回true。**「isBlank判空更加准确」**。

4. 扩展

- 在实际开发中，除了isBlank判空的几种情况之外，其实“null”字符串我们也会当作空字符串处理。

- 我们需要判断几个字段同时不能为空，如果还用isBlank就显得有点累赘了。我们可以使用String的可变参数提供如下工具类。

  > 这个工具类的优点很明显，一方面判断了字符串“null”，另一方面对参数个数无限制，只要有一个参数是空则返回true

```java
public class StringTool {
    public static boolean isNullStr(String... args) {
        boolean flag = false;
        for (String arg : args) {
            if (Stringutils. isBlank(arg) || arg.equals("null")) {
                flag = true;
                return falg;
            }
        }
        return flag;
    }
}
```

# DO/DTO/VO

**1.为什么会出现这些 O？**

> 一，随着编程工业化的发展，需要有一套合理的体系出现。于是 MVC、MVP、MVVM 等编程模型就出现了，为了搭配这些编程模型的使用，需要对 Object 的功能进行划分。
>
> 二，在团队协作编码中，一个好的命名方式是可以节约很多时间成本的。就比如`getItemById`一眼看去就知道是通过 id 获取一个 item 对象，`ItemVO`一眼看去就知道是前端需要的 json 对应的对象。
>
> 三，如此划分，可以让项目结构更加清楚。尽可能避免了在多人协作时对象混乱的情况。
>
> 总的来说，这一切都是为了让软件编程更加合理、更加规范、更加高效。

**2.常见O**

> 以下内容参考阿里巴巴 Java 开发手册

- DO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。

- PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象

- DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。

- BO（ Business Object）：业务对象。由 Service 层输出的封装业务逻辑的对象。

- AO（ Application Object）：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。

- VO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。

- POJO（ Plain Ordinary Java Object）：POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。

- DAO（Data Access Objects）：数据访问对象，和上面那些 O 不同的是，其功能是用于进行数据操作的。通常不会用于描述数据实体。

**3.数据的流向**

![6DE53A75-E813-4C9E-9033-CEB1D846420D](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmv5xmb68j30pz0690tz.jpg)

我们知道，一般情况下，前端是不会凭空造出数据的，因此最后前端展示的数据一定是从数据库中来的，数据的流向通常也是从数据库流向页面。我将其分成三个部分：数据访问、业务处理和业务解释。

> 1.数据访问：这一部分是用于从数据库中读取数据，将数据记录转换成数据实体也就是 Java 对象，便于操作。
>
> 2.业务处理：这一部分是数据流的核心，几乎所有数据的操作都是在这一部分完成的。
>
> 3.业务解释：这一部分是用于展示给前端的数据，解释业务体现在某些字段/值是需要经过处理(如：json)的才会呈现的。

**4.关键点**

- DAO：是用于**操作数据**而不是描述数据的。

- PO/DO/Entity：其数据结构对应数据表中的一条记录，因此是同一类别的。

- BO：可以理解为 PO 的组合，举个简单的例子，假设 PO 是一条交易记录，BO 就可以是一个人全部的交易记录集合对象。

- DTO：用于传输数据，可能传递给前端，也有可能传递给其他系统。用于**承载数据**。

- VO，这个最好理解，前端最后需要的数据长什么样，对应的对象就是 VO。（如：`ItemVO`是前端需要的 json 对应的对象）

**5.如何使用这些 O？**

> **教条主义？**
>
> 首先，这几个概念很完整，但是我们在用的时候是必须按这个来做吗？答案当然不是的，规矩是死的，人是活的。
>
> **省略方案：**
>
> 1.不管你是叫 PO 还是 DO 还是 Entity，用于描述数据库记录的对象一定要存在，不可省略。
>
> 2.DTO 和 BO 在一般情况下，如果业务系统不是非常复杂，可以考虑省略。
>
> 3.VO 和 DTO，DTO 可以用于将数据传递给前端，如果你不需要删减字段的话，VO 可以考虑省略。

**6.具体命名**

- 数据对象：xxxDO，xxx 即为数据表名。

- 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。

- 展示对象：xxxVO，xxx 一般为网页名称。

- POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。

**示例：**

```java
//Controller层:
public <ListsUserVo> getUsers (UserDTO userDto);

//Service层:
Lists<UserDTO> getUsers (UserDTO userDto);

//DAO层:
List<UserDTO> getUsers (UserDo userDo);
(报销但基本信息+报销单条目信息[交通\餐饮等])在表现层,DTO弥补DO/entity的不足，再为entity封装了一层功能
```

# Web架构&框架

三层架构：

> 1.表示层（web层） ：包含JSP, Servlet等web相关的内容
>
> 2.业务逻辑层（Service）：处理业务,
>
> 3.数据层（DAO Data Access object）：也叫持久层,封装了对数据库的访问细节,一般写DAO类

MVC框架：

> Model（模型）： 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
>
> View（视图）：视图代表模型包含的数据的可视化。
>
> Controller（控制器）：控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开来。



![16C4FE27-AD2B-4411-A547-6807A1FF292B](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmxnb5021j30m80arjt0.jpg)

![image-20200831145016862](https://tva1.sinaimg.cn/large/007S8ZIlly1gi9zvwkk9mj30lx0egab0.jpg)

# Fork/Join 框架

## 简介

从JDK1.7开始，Java提供Fork/Join框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。

> 这种思想和MapReduce很像（input --> split --> map --> reduce --> output）
>
> MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念"Map（映射）"和"Reduce（归约）"，是它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。

主要有两步：

- 第一、任务切分；
- 第二、结果合并

它的模型大致是这样的：线程池中的每个线程都有自己的工作队列（PS：这一点和ThreadPoolExecutor不同，ThreadPoolExecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务），当自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。

## 示例

```java
public class ForkJoinTaskDemo {

  private class SumTask extends RecursiveTask<Integer> {

    private static final int THRESHOLD = 20;

    private int arr[];
    private int start;
    private int end;

    public SumTask(int[] arr, int start, int end) {
      this.arr = arr;
      this.start = start;
      this.end = end;
    }
		
    //小计
    private Integer subtotal() {
      Integer sum = 0;
      for (int i = start; i < end; i++) {
        sum += arr[i];
      }
      System.out.println(Thread.currentThread().getName() + ": ∑(" + start + "~" + end + ")=" + sum);
      return sum;
    }

    @Override
    protected Integer compute() {

      if ((end - start) <= THRESHOLD) {
        return subtotal();
      }else {
        int middle = (start + end) / 2;
        SumTask left = new SumTask(arr, start, middle);
        SumTask right = new SumTask(arr, middle, end);
        left.fork();
        right.fork();

        return left.join() + right.join();}}
  }

  public static void main(String[] args) throws ExecutionException, InterruptedException {
    int[] arr = new int[100];
    for (int i = 0; i < 100; i++) {
      arr[i] = i + 1;
    }

    ForkJoinPool pool = new ForkJoinPool();
    ForkJoinTask<Integer> result = pool.submit(new ForkJoinTaskDemo().new SumTask(arr, 0, arr.length));
    System.out.println("最终计算结果: " + result.invoke());
    pool.shutdown();}
}
```

# Maven相关

## 依赖的scope

去除部署不需要的jar包

```xml
<dependency>

    < groupId>javax.servlet</groupId>

    < artifactId>jsp-api</artifactId>

    < version>2.0</version>

    < scope>provided</scope>

< /dependency>
```

> **compile** 默认的scope，表示 dependency 都可以在生命周期中使用。而且，这些dependencies 会传递到依赖的项目中。适用于所有阶段，会随着项目一起发布 
>
> **provided** 跟compile相似，但是表明了dependency 由JDK或者容器提供，例如Servlet AP和一些Java EE APIs。这个scope 只能作用在编译和测试时，同时没有传递性。     
>
> **runtime** 表示dependency不作用在编译时，但会作用在运行和测试时，如JDBC驱动，适用运行和测试阶段。 
>
> **test** 表示dependency作用在测试时，不作用在运行时。 只在测试时使用，用于编译和运行测试代码。不会随项目发布。 
>
> **system** 跟provided 相似，但是在系统中要以外部JAR包的形式提供，maven不会在repository查找它。

```css
你通过maven引入的jar包，里面的类，都是已经编译好的字节码，跟runtime或者provided没关系。

简单来说，compile、runtime和provided的区别，需要在执行mvn package命令，且打包格式是war之类（而不是默认的jar）的时候才能看出来。

通过compile和provided引入的jar包，里面的类，你在项目中可以直接import进来用，编译没问题，但是runtime引入的jar包中的类，项目代码里不能直接用，用了无法通过编译，只能通过反射之类的方式来用。

通过compile和runtime引入的jar包，会出现在你的项目war包里，而provided引入的jar包则不会。
```

