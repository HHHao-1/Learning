# 判空

## 工具包

apache的 commons-lang3工具包

> StringUtils.isEmpty(CharSequence cs)：如果是 null 者 “” 则返回true。
>
> StringUtils.isBlank(CharSequence cs)：如果是 null 或 “” 或 空格 则返回true。

> 加入对字符串“null”的判断
>
> 参数个数无限制，只要有一个参数是空则返回true

```java
public class StringTool {
    public static boolean isNullStr(String... args) {
        boolean flag = false;
        for (String arg : args) {
            if (Stringutils. isBlank(arg) || arg.equals("null")) {
                flag = true;
                return falg;
            }
        }
        return flag;
    }
}
```

## Optional

一个可能包含也可能不包含非null值的容器对象。 若存在值，isPresent() 返回true，get() 返回该值。

```java
// 对象属性层层判空
public String testSimple(Test4 test) {
  if (test == null) {
    return "";
  }
  if (test.getTest3() == null) {
    return "";
  }
  if (test.getTest3().getTest2() == null) {
    return "";
  }
  if (test.getTest3().getTest2().getInfo() == null) {
    return "";
  }
  return test.getTest3().getTest2().getInfo();
}

// 使用Optional
public String testOptional(Test test) {
  return Optional.ofNullable(test).flatMap(Test::getTest3)
    .flatMap(Test3::getTest2)
    .map(Test2::getInfo)
    .orElse("");
}
/*
1.Optional.ofNullable(test)，如果test为空，则返回一个单例空Optional对象，如果非空则返回一个Optional包装对象，Optional将test包装；
2.flatMap(Test::getTest3)判断test是否为空，如果为空，继续返回第一步中的单例Optional对象，否则调用Test的getTest3方法；
3.flatMap(Test3::getTest2)同上调用Test3的getTest2方法；
4.map(Test2::getInfo)同flatMap类似，但是flatMap要求Test3::getTest2返回值为Optional类型，而map不需要，flatMap不会多层包装，map返回会再次包装Optional；
5.orElse("");获得map中的value，不为空则直接返回value，为空则返回传入的参数作为默认值。
*/
```



# VO、DTO、DO、PO

## 简介 

**1.为什么会出现这些 O？**

> 一，随着编程工业化的发展，需要有一套合理的体系出现。于是 MVC、MVP、MVVM 等编程模型就出现了，为了搭配这些编程模型的使用，需要对 Object 的功能进行划分。
>
> 二，在团队协作编码中，一个好的命名方式是可以节约很多时间成本的。就比如`getItemById`一眼看去就知道是通过 id 获取一个 item 对象，`ItemVO`一眼看去就知道是前端需要的 json 对应的对象。
>
> 三，如此划分，可以让项目结构更加清楚。尽可能避免了在多人协作时对象混乱的情况。
>
> 总的来说，这一切都是为了让软件编程更加合理、更加规范、更加高效。

**2.常见O**

以下内容参考阿里巴巴 Java 开发手册：

- DO（ Data Object）：数据对象，与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。

- PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象

- DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。

- BO（ Business Object）：业务对象。由 Service 层输出的封装业务逻辑的对象。

- AO（ Application Object）：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。

- VO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。

- POJO（ Plain Ordinary Java Object）：POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。

- DAO（Data Access Objects）：数据访问对象，和上面那些 O 不同的是，其功能是用于进行数据操作的。通常不会用于描述数据实体。

**3.关键点**

- DAO：是用于**操作数据**而不是描述数据的。

- PO/DO/Entity：其数据结构对应数据表中的一条记录，因此是同一类别的。

- BO：可以理解为 PO 的组合，举个简单的例子，假设 PO 是一条交易记录，BO 就可以是一个人全部的交易记录集合对象。

- DTO：用于传输数据，可能传递给前端，也有可能传递给其他系统。用于**承载数据**。

- VO，这个最好理解，前端最后需要的数据长什么样，对应的对象就是 VO。（如：`ItemVO`是前端需要的 json 对应的对象）

**4.具体命名**

- 数据对象：xxxDO，xxx 即为数据表名。

- 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。

- 展示对象：xxxVO，xxx 一般为网页名称。

- POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。

## 应用

### 示例

下面以一个时序图建立简单模型来描述上述对象在三层架构应用中的位置

![image-20201002185706480](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjb6uogynsj30it09u74r.jpg)

- 用户发出请求（如：填写表单），表单的数据在展示层被匹配为VO（由Controller接收）。
- 展示层（Controller）把VO转换为服务层对应方法所要求的DTO，传送给服务层（Service）。
- 服务层首先根据DTO的数据构造（或重建）一个DO，调用DO的业务方法完成具体业务（既DO在各服务层之间传递）。
- 服务层把DO转换为持久层对应的PO（可以使用ORM工具，也可以不用），调用持久层的持久化方法，把PO传递给它，完成持久化操作。
- 对于一个逆向操作，如读取数据，也是用类似的方式转换和传递。

### VO与DTO

在设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的DTO，不应该出现与表现形式的耦合。

例如：语义上定义：1-男性，2-女性，0-未指定。而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。这时据需要DTO转换为VO

### DTO与DO

DTO是展示层和服务层之间的数据传输对象（可以认为是两者之间的协议），而DO是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如UserInfo和User，对于一个getUser方法来说，本质上它永远不应该返回用户的密码，因此UserInfo至少比User少一个password的数据。DO不是简单的POJO，它具有领域业务逻辑。

### DO与PO的区别

DO和PO在绝大部分情况下是一一对应的，PO是只含有get/set方法的POJO类，但某些场景还是能反映出两者在概念上存在本质的区别：

- DO在某些场景下不需要进行显式的持久化，例如利用策略模式设计的商品折扣策略，会衍生出折扣策略的接口和不同折扣策略实现类，这些折扣策略实现类可以算是DO，但它们只驻留在静态内存，不需要持久化到持久层，因此，这类DO是不存在对应的PO的。
- 同样的道理，某些场景下，PO也没有对应的DO，例如老师Teacher和学生Student存在多对多的关系，在关系数据库中，这种关系需要表现为一个中间表，也就对应有一个TeacherAndStudentPO的PO，但这个PO在业务领域没有任何现实的意义，它完全不能与任何DO对应上。

由于ORM框架的功能非常强大而大行其道，而且JavaEE也推出了JPA规范，现在的业务应用开发，基本上不需要区分DO与PO，PO完全可以通过ORM框架的Annotations/xml隐藏在DO之中。虽然如此，但有些问题我们还必须注意：

对于DO中不需要持久化的属性，需要通过ORM显式的声明，如：在Mybatis中，可以利用\<resultMap>。

### 注意

**分析设计层面和实现层面完全是两个独立的层面，即使实现层面通过某种技术手段可以把两个完全独立的概念合二为一，在分析设计层面，我们仍然（至少在头脑中）需要把概念上独立的东西清晰的区分开来，这个原则对于做好分析设计非常重要（工具越先进，往往会让我们越麻木）。**

# Fork/Join 框架

## 简介

从JDK1.7开始，Java提供Fork/Join框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。

> 这种思想和MapReduce很像（input --> split --> map --> reduce --> output）
>
> MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念"Map（映射）"和"Reduce（归约）"，是它们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。

主要有两步：

- 第一、任务切分；
- 第二、结果合并

它的模型大致是这样的：线程池中的每个线程都有自己的工作队列（PS：这一点和ThreadPoolExecutor不同，ThreadPoolExecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务），当自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。

## 示例

```java
public class ForkJoinTaskDemo {

  private class SumTask extends RecursiveTask<Integer> {

    private static final int THRESHOLD = 20;

    private int arr[];
    private int start;
    private int end;

    public SumTask(int[] arr, int start, int end) {
      this.arr = arr;
      this.start = start;
      this.end = end;
    }
		
    //小计
    private Integer subtotal() {
      Integer sum = 0;
      for (int i = start; i < end; i++) {
        sum += arr[i];
      }
      System.out.println(Thread.currentThread().getName() + ": ∑(" + start + "~" + end + ")=" + sum);
      return sum;
    }

    @Override
    protected Integer compute() {

      if ((end - start) <= THRESHOLD) {
        return subtotal();
      }else {
        int middle = (start + end) / 2;
        SumTask left = new SumTask(arr, start, middle);
        SumTask right = new SumTask(arr, middle, end);
        left.fork();
        right.fork();

        return left.join() + right.join();}}
  }

  public static void main(String[] args) throws ExecutionException, InterruptedException {
    int[] arr = new int[100];
    for (int i = 0; i < 100; i++) {
      arr[i] = i + 1;
    }

    ForkJoinPool pool = new ForkJoinPool();
    ForkJoinTask<Integer> result = pool.submit(new ForkJoinTaskDemo().new SumTask(arr, 0, arr.length));
    System.out.println("最终计算结果: " + result.invoke());
    pool.shutdown();}
}
```

# Maven相关

## 依赖的scope

去除部署不需要的jar包

```xml
<dependency>

    < groupId>javax.servlet</groupId>

    < artifactId>jsp-api</artifactId>

    < version>2.0</version>

    < scope>provided</scope>

< /dependency>
```

> **compile** 默认的scope，表示 dependency 都可以在生命周期中使用。而且，这些dependencies 会传递到依赖的项目中。适用于所有阶段，会随着项目一起发布 
>
> **provided** 跟compile相似，但是表明了dependency 由JDK或者容器提供，例如Servlet AP和一些Java EE APIs。这个scope 只能作用在编译和测试时，同时没有传递性。     
>
> **runtime** 表示dependency不作用在编译时，但会作用在运行和测试时，如JDBC驱动，适用运行和测试阶段。 
>
> **test** 表示dependency作用在测试时，不作用在运行时。 只在测试时使用，用于编译和运行测试代码。不会随项目发布。 
>
> **system** 跟provided 相似，但是在系统中要以外部JAR包的形式提供，maven不会在repository查找它。

```css
你通过maven引入的jar包，里面的类，都是已经编译好的字节码，跟runtime或者provided没关系。

简单来说，compile、runtime和provided的区别，需要在执行mvn package命令，且打包格式是war之类（而不是默认的jar）的时候才能看出来。

通过compile和provided引入的jar包，里面的类，你在项目中可以直接import进来用，编译没问题，但是runtime引入的jar包中的类，项目代码里不能直接用，用了无法通过编译，只能通过反射之类的方式来用。

通过compile和runtime引入的jar包，会出现在你的项目war包里，而provided引入的jar包则不会。
```

# 不可变机制

> JAVA不可变类(immutable)机制与String的不可变性
>
> 基本类型包装类、String类

## 简介

**不可变类**：所谓不可变类指这个类的实例一旦创建完成后，就不能改变其成员变量值。

**可变类**：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。

**优点：**不可变特性主要为了满足常量池、线程安全、类加载的需求。合理使用不可变类可以带来极大的好处。

**缺点：**这种特性使得不可变类提供了线程安全的特性但同时也带来了对象创建的开销，每更改一个属性都是重新创建一个新的对象。

**是否真的不可变？**

虽然String对象将value设置为final,并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。如：

```java
//创建字符串"Hello World"， 并赋给引用s
String s = "Hello World"; 
System.out.println("s = " + s);	//Hello World

//获取String类中的value字段
Field valueFieldOfString = String.class.getDeclaredField("value");
//改变value属性的访问权限
valueFieldOfString.setAccessible(true);

//获取s对象上的value属性的值
char[] value = (char[]) valueFieldOfString.get(s);
//改变value所引用的数组中的第5个字符
value[5] = '_';
System.out.println("s = " + s);  //Hello_World
```

## 不可变类设计

**1. 类添加final修饰符，保证类不被继承**。

**2. 保证所有成员变量必须私有，并且加上final修饰**

**3. 不提供改变成员变量的方法，包括setter**

**4.通过构造器初始化所有成员，进行深拷贝(deep copy)**

如果构造器传入的对象直接赋值给成员变量，还是可以通过对传入对象的修改进而导致改变内部变量的值

```java
public final class MyImmutableDemo {  
  private final int[] myArray;  
  public MyImmutableDemo(int[] array) {  
    //this.myArray = array; // wrong 
    this.myArray = array.clone(); //这里要改写成深拷贝  
  }   
}
```

**5.在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝**

这种做法也是防止对象外泄，防止通过getter获得内部可变成员对象后对成员变量直接操作，导致成员变量发生改变。

## String

> - String对象的不可变性

String源码：

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence
{
    /** The value is used for character storage. */
    private final char value[];
    /** The offset is the first index of the storage that is used. */
    private final int offset;
    /** The count is the number of characters in the String. */
    private final int count;
    /** Cache the hash code for the string */
    private int hash; // Default to 0
    ....
    public String(char value[]) {
         this.value = Arrays.copyOf(value, value.length); // deep copy操作
     }
    ...
     public char[] toCharArray() {
     // Cannot use Arrays.copyOf because of class initialization order issues
        char result[] = new char[value.length];
        System.arraycopy(value, 0, result, 0, value.length);
        return result;
    }
    ...
}
```

1. String类被final修饰，不可继承
2. String内部所有成员都设置为私有变量
3. 不存在value的setter
5. 当传入可变数组value[]时，进行copy而不是直接将value[]赋值(引用)给内部变量.
6. 获取value时不是直接返回对象引用，而是返回对象的copy.

> - String对象的不可变性的优缺点

优点：

**1.字符串常量池的需要**.

字符串常量池可以将一些字符常量放在常量池中重复使用，避免每次都重新创建相同的对象、节省存储空间。但如果字符串是可变的，此时相同内容的String还指向常量池的同一个内存空间，当某个变量改变了该内存的值时，其他遍历的值也会发生改变。所以不符合常量池设计的初衷。

**2. 线程安全考虑**。

同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。

**3. 类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载**。

如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。

**4. 支持hash映射和缓存。**

因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。

缺点：

**1. 如果有对String对象值改变的需求，那么会创建大量的String对象。**

# 多线程概念

## 线程与进程

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线

3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见。

4. 调度和切换：线程上下文切换比进程上下文切换要快得多

- **为何不使用多进程而是使用多线程？**

  线程廉价，线程启动比较快，退出比较快，对系统资源的冲击也比较小。而且线程彼此分享了大部分核心对象(File Handle)的拥有权

  如果使用多进程，则不可预期，且测试困难

## 线程安全

- 线程安全：

指多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的，不存在执行程序时出现意外结果。

- 线程不安全：

是指不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。

- 举例说明：

假设售票系统有1000张票，A和B同时来买票，如果是线程不安全，那么可能售票系统可能出现1000-1去同时执行的情况，最终结果是A和B都买完后剩下999张票，而不是998张。

- 引起线程安全问题的原因：

线程安全问题都是由全局变量及静态变量引起的。

若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

- 解决多线程并发访问资源安全问题的方法：

（1）synchronized

synchronized关键字，就是用来控制线程同步的，保证我们的线程在多线程环境下，不被多个线程同时执行，确保我们数据的完整性，使用方法一般是加在方法上。

（2）Lock

Lock是在Java1.6被引入进来的，Lock的引入让锁有了可操作性，是指我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，从使用上synchronized使用起来比Lock更方便。

## 线程同步

### 简介

在并发程序设计中，各进程对公共变量的访问必须加以制约，这种制约称为同步。

线程同步的方式：

临界区（Critical Section）、互斥对象（Mutex）：主要用于互斥控制；都具有拥有权的控制方法，只有拥有该对象的线程才能执行任务，所以拥有，执行完任务后一定要释放该对象。

信号量（Semaphore）、事件对象（Event）：事件对象是以通知的方式进行控制，主要用于同步控制！

### 临界区

临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。

   通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻**只允许一个**线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。

### 互斥量

互斥量一般指互斥锁。在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为" 互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。

只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。互斥量比临界区复杂。

### 信号量

信号量(Semaphore)：有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。

它允许多个线程在**同一时刻访问同一资源**，但是需要限制在同一时刻访问此资源的最大线程数目。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源。

### 事 件

事件类似于前面的信号量，一个事件有两种状态：激发状态和未激发状态。也称有信号状态和无信号状态。

事件又分两种类型：手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒“一个”等待中的线程，然后自动恢复为未激发状态。

### 区别

#### 临界区与互斥量

互斥量与临界区的作用非常相似，但**互斥量是可以命名**的，也就是说它可以**跨越进程使用**。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。

#### 互斥量与信号量

（1）. 互斥量用于线程的互斥，信号量用于线程的同步。

这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。

互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。

**Note：**信号量可以用来实现互斥量的功能、并且线程有序、可指定同一时刻线程访问数目。

（2）. 互斥量值只能为0/1，信号量值可以为非负整数。

也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。

（3）. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到

####  可跨进程的方式

互斥量（Mutex），信号灯（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作。

## 同步与异步

同步和异步关注的是**消息通信机制**。

同步，就是调用某个东西时，调用方得等待这个调用返回结果才能继续往后执行。

异步，和同步相反 调用方不会立即得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状态来通知调用者，或者通过回掉函数来处理这个调用。

## 高并发

1. 高并发指：短时间，大量请求，可能导致系统数据不正确、产生脏数据的现象。

并发指：使用多个线程或进程，同时处理不同的操作。

2. 处理高并发的方法

**工具层面：**

使用高性能服务器、高性能数据库、高效率编程语言、还有高性能Web容器

**编程层面：**

（1）动静分离。静态资源请求与动态请求分离，项目中需要访问的图片、声音、js/css等静态资源需要有独立的存放位置，便于将来实现静态请求分离时直接剥离出来，比如nginx可以直接配置图片文件直接访问目录，而不需要经过tomcat。这样tomcat就可以专注处理动态请求，操作数据库数据之类的。静态请求代理服务器性能比tomcat高很多。

（2）引入缓存。数据库缓存、页面缓存，这东西好用不复杂，搞明白什么地方适用最重要。简单的例子是频繁读取，不修改的地方最适用。也是后续集群做数据共享的一个方式之一，集群环境下，经常会碰到数据共享问题。

（3）如果将来数据量大，单一数据库成为瓶颈时，数据库的读写分离来了。数据库集群，读写分离，分表分区。

# 前后端数据传输格式

## 向后端发送请求的方式

- 浏览器地址栏输入url回车（GET/POST请求）

- a便签的href属性（GET）

- form表单（GET/POST请求）

  默认是GET请求`method='get'`

  修改`method='post'`朝后端发送的是post请求

- ajax（GET/POST请求）

  默认是GET请求`type='get'`

  修改`type='post'`发送post请求

## 传输数据的三种编码格式

- Urlencoded
- Formdata
- Json

### form表单默认编码方式

**默认编码格式：**urlencoded

**数据格式：**username=tom&password=111,跟get请求url问号后携带数据的格式相同

### AJAX默认编码方式

**默认编码格式：**urlencoded

**数据格式：**username=tom&password=111

**注意：**form表单无法发送json格式数据。

### AJAX传输文件

ajax在发送文件时需要借助与js内置对象FormDate获取一个formDate对象，然后往对象内append属性，添加属性的时既可以添加普通的键值对也可以添加文件对象，ajax数据部分直接放formDate对象即可。

**发送文件必须指定的两个参数：**

- `contentType:false`：告诉后端不要使用任何的编码方式编码，django后端会自动识别formDate对象
- `process:false`：告诉浏览器不要对数据进行任何的处理。

### AJAX传输json数据

```js
$('.btn').click(function () {
  $.ajax({
    url:'',
    data:JSON.stringify({'username':'jason','age':25}),  //将字段序列化成json格式的字符串
    type:'post',
    contentType:'application/json',  // 修改编码格式为json格式
    dataType:'json',
    success:function () {
    }
  })
})
```

