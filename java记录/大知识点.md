#  Object类

| Modifier and Type  | Method and Description                                       |
| :----------------- | :----------------------------------------------------------- |
| `protected Object` | `clone()`<br />创建并返回此对象的副本。                      |
| `boolean`          | `equals(Object obj)`<br />比较两个对象的值是否相等。         |
| `protected void`   | `finalize()`<br />当垃圾回收器确定不再有对该对象的引用时，由垃圾回收器在对象上调用。 |
| `Class<?>`         | `getClass()`<br />返回此对象的运行时的类。                   |
| `int`              | `hashCode()`<br />返回对象的哈希码值。                       |
| `void`             | `notify()`<br />唤醒正在此对象的监听器上等待的单个线程。     |
| `void`             | `notifyAll()`<br />唤醒正在此对象的监视器上等待的所有线程。  |
| `String`           | `toString()`<br />返回对象的字符串表示形式。                 |
| `void`             | `wait()`<br />使当前线程等待，直到另一个线程为此对象调用notify（）方法或notifyAll（）方法。 |
| `void`             | `wait(long timeout)`<br />使当前线程等待，直到另一个线程为此对象调用notify（）方法或thenotifyAll（）方法，或者经过指定的时间。 |
| `void`             | `wait(long timeout, int nanos)`<br />使当前线程等待，直到另一个线程为此对象调用notify（）方法或notifyAll（）方法，或者某个其他线程中断了当前线程，或者经过了一定的实时时间。 |

# 递归

> 方法自已调用自己

**递归的分类：2种**

①直接递归称为方法自身调用自己

②间接递归可以使用A方法调用B方法，B方法调用C方法，C方法再调用A方法

**注意事项：**

1.递归一定要有条件限定，保证能停止下来，否则会发生栈内存溢出

2.在递归虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出

3.构造方法，禁止递归

**示例：**

```java
public class Test01 {

 public static void main(String[] args) {
     //a();
     b(1);
 }

 /**
	 * 在递归中虽然有限定条件，但是递归次数不能太多，否同也会发生栈内存溢出

	 */
    private static void b(int i) {
        System.out.println(i);
        if(i==200000){
            return ;
        }
        b(++i);
    }

    /**
	 * 递归一定要有条件限定，保证能够停止下来，否则会发生
	 * Exception in thread "main" java.lang.StackOverflowError
	 */
    private static void a() {
        System.out.println("a方法");
        a();
    }

    /**
	 * 构造方法禁止递归
	 *  编译错误，构造方法是创建对象使用的，一直递归会导致内存中有无数多个对象
	 */
    public Test01(){
        //Test01();
    }
}
```

**使用递归计算1-n之间的和：**

```java
public class Test02 {
    public static void main(String[] args) {
        int s = sum(100);
        System.out.println(s);
    }

    /**
	 * 定义一个方法，使用递归计算1-n之间的和
	 *  1+2+3+..n
	 *  n+(n-1) +(n-1)+..1;
	 *  已知 最大值n  最小值1
	 *  使用递归必需明确
	 *  	1.递归的结束条件：获取到1的时候结束
	 *  	2.递归的目标：获取下一个被加的数字(n-1)
	 */
    private static int sum(int n) {
        //获取到1的时候
        if(n==1){
            return 1;
        }
        //获取下一个被加的数字 (n-1)
        return n+sum(n-1);
    }
}
```

# 判空

依赖包：commons-lang3

这个包为我们提供了两个判空的方法，分别是

> StringUtils.isEmpty(CharSequence cs)
>
> StringUtils.isBlank(CharSequence cs)

1. StringUtils.isEmpty

这个方法判断的是字符串是否为null或者其长度是否为零。

isEmpty的源码如下：

```java
public static boolean isEmpty(CharSequence cs) { 
    return cs == null ll cs.length() == 0;
}
```

2. StringUtils.isBlank

这个方法除了判断字符串是否为null和长度是否为零，还判断了是否为空格，如果是空格也返回true。

isBlank的源码如下：

```java
public static boolean isBlank(CharSequence cs) { 
    int strLen = length(cs);
    if (strLen == 0) { 
        return true;
    }else {
        for(int i=0; i < strLen; ++i) {
            if (!Character. iswhitespace(cs.charAt(i))) { 
                return false;
            }
        }
        return true;
    }
}
```

length(cs)的方法如下：

```java
public static int length(CharSequence cs) { 
    return cs == null ? 0 : cs.length();
}
```

CharSequence：

```
CharSequence是个接口
实现了这个接口的类有：CharBuffer、String、StringBuffer、StringBuilder这四个类。
```

3. 总结

- isEmpty：如果是null或者“”则返回true。
- isBlank：如果是null或者“”或者空格则返回true。**「isBlank判空更加准确」**。

4. 扩展

- 在实际开发中，除了isBlank判空的几种情况之外，其实“null”字符串我们也会当作空字符串处理。

- 我们需要判断几个字段同时不能为空，如果还用isBlank就显得有点累赘了。我们可以使用String的可变参数提供如下工具类。

  > 这个工具类的优点很明显，一方面判断了字符串“null”，另一方面对参数个数无限制，只要有一个参数是空则返回true

```java
public class StringTool {
    public static boolean isNullStr(String... args) {
        boolean flag = false;
        for (String arg : args) {
            if (Stringutils. isBlank(arg) || arg.equals("null")) {
                flag = true;
                return falg;
            }
        }
        return flag;
    }
}
```

# 对象命名

**1.为什么会出现这些 O？**

> 一，随着编程工业化的发展，需要有一套合理的体系出现。于是 MVC、MVP、MVVM 等编程模型就出现了，为了搭配这些编程模型的使用，需要对 Object 的功能进行划分。
>
> 二，在团队协作编码中，一个好的命名方式是可以节约很多时间成本的。就比如`getItemById`一眼看去就知道是通过 id 获取一个 item 对象，`ItemVO`一眼看去就知道是前端需要的 json 对应的对象。
>
> 三，如此划分，可以让项目结构更加清楚。尽可能避免了在多人协作时对象混乱的情况。
>
> 总的来说，这一切都是为了让软件编程更加合理、更加规范、更加高效。

**2.常见O**

> 以下内容参考阿里巴巴 Java 开发手册

- DO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。

- PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象

- DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。

- BO（ Business Object）：业务对象。由 Service 层输出的封装业务逻辑的对象。

- AO（ Application Object）：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。

- VO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。

- POJO（ Plain Ordinary Java Object）：POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。

- DAO（Data Access Objects）：数据访问对象，和上面那些 O 不同的是，其功能是用于进行数据操作的。通常不会用于描述数据实体。

**3.数据的流向**

![6DE53A75-E813-4C9E-9033-CEB1D846420D](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmv5xmb68j30pz0690tz.jpg)

我们知道，一般情况下，前端是不会凭空造出数据的，因此最后前端展示的数据一定是从数据库中来的，数据的流向通常也是从数据库流向页面。我将其分成三个部分：数据访问、业务处理和业务解释。

> 1.数据访问：这一部分是用于从数据库中读取数据，将数据记录转换成数据实体也就是 Java 对象，便于操作。
>
> 2.业务处理：这一部分是数据流的核心，几乎所有数据的操作都是在这一部分完成的。
>
> 3.业务解释：这一部分是用于展示给前端的数据，解释业务体现在某些字段/值是需要经过处理(如：json)的才会呈现的。

**4.关键点**

- DAO：是用于**操作数据**而不是描述数据的。

- PO/DO/Entity：其数据结构对应数据表中的一条记录，因此是同一类别的。

- BO：可以理解为 PO 的组合，举个简单的例子，假设 PO 是一条交易记录，BO 就可以是一个人全部的交易记录集合对象。

- DTO：用于传输数据，可能传递给前端，也有可能传递给其他系统。用于**承载数据**。

- VO，这个最好理解，前端最后需要的数据长什么样，对应的对象就是 VO。（如：`ItemVO`是前端需要的 json 对应的对象）

**5.如何使用这些 O？**

> **教条主义？**
>
> 首先，这几个概念很完整，但是我们在用的时候是必须按这个来做吗？答案当然不是的，规矩是死的，人是活的。
>
> **省略方案：**
>
> 1.不管你是叫 PO 还是 DO 还是 Entity，用于描述数据库记录的对象一定要存在，不可省略。
>
> 2.DTO 和 BO 在一般情况下，如果业务系统不是非常复杂，可以考虑省略。
>
> 3.VO 和 DTO，DTO 可以用于将数据传递给前端，如果你不需要删减字段的话，VO 可以考虑省略。

**6.具体命名**

- 数据对象：xxxDO，xxx 即为数据表名。

- 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。

- 展示对象：xxxVO，xxx 一般为网页名称。

- POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。

**示例：**

```java
//Controller层:
public <ListsUserVo> getUsers (UserDTO userDto);

//Service层:
Lists<UserDTO> getUsers (UserDTO userDto);

//DAO层:
List<UserDTO> getUsers (UserDo userDo);
(报销但基本信息+报销单条目信息[交通\餐饮等])在表现层,DTO弥补DO/entity的不足，再为entity封装了一层功能
```

# Web架构&框架

三层架构：

> 1.表示层（web层） ：包含JSP, Servlet等web相关的内容
>
> 2.业务逻辑层（Service）：处理业务,
>
> 3.数据层（DAO Data Access object）：也叫持久层,封装了对数据库的访问细节,一般写DAO类

MVC框架：

> Model（模型）： 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
>
> View（视图）：视图代表模型包含的数据的可视化。
>
> Controller（控制器）：控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开来。



![16C4FE27-AD2B-4411-A547-6807A1FF292B](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmxnb5021j30m80arjt0.jpg)

