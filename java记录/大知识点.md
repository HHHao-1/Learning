#  Object类

| Modifier and Type  | Method and Description                                       |
| :----------------- | :----------------------------------------------------------- |
| `protected Object` | `clone()`：创建并返回此对象的副本。                          |
| `boolean`          | `equals(Object obj)`：比较两个对象的值是否相等。             |
| `protected void`   | `finalize()`：当垃圾回收器确定不再有对该对象的引用时，由垃圾回收器在对象上调用。 |
| `Class<?>`         | `getClass()`：返回此对象的运行时的类。                       |
| `int`              | `hashCode()`：返回对象的哈希码值。                           |
| `void`             | `notify()`：唤醒正在此对象的监听器上等待的单个线程。         |
| `void`             | `notifyAll()`：唤醒正在此对象的监视器上等待的所有线程。      |
| `String`           | `toString()`：返回对象的字符串表示形式。                     |
| `void`             | `wait()`：使当前线程等待，直到另一个线程为此对象调用notify（）方法或notifyAll（）方法。 |
| `void`             | `wait(long timeout)`：使当前线程等待，直到另一个线程为此对象调用notify（）方法或thenotifyAll（）方法，或者经过指定的时间。 |
| `void`             | `wait(long timeout, int nanos)`：使当前线程等待，直到另一个线程为此对象调用notify（）方法或notifyAll（）方法，或者某个其他线程中断了当前线程，或者经过了一定的实时时间。 |

# 递归

> 方法自已调用自己

**递归的分类：2种**

①直接递归称为方法自身调用自己

②间接递归可以使用A方法调用B方法，B方法调用C方法，C方法再调用A方法

**注意事项：**

1.递归一定要有条件限定，保证能停止下来，否则会发生栈内存溢出

2.在递归虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出

3.构造方法，禁止递归

**示例：**

```java
public class Test01 {

 public static void main(String[] args) {
     //a();
     b(1);
 }

 /**
	 * 在递归中虽然有限定条件，但是递归次数不能太多，否同也会发生栈内存溢出

	 */
    private static void b(int i) {
        System.out.println(i);
        if(i==200000){
            return ;
        }
        b(++i);
    }

    /**
	 * 递归一定要有条件限定，保证能够停止下来，否则会发生
	 * Exception in thread "main" java.lang.StackOverflowError
	 */
    private static void a() {
        System.out.println("a方法");
        a();
    }

    /**
	 * 构造方法禁止递归
	 *  编译错误，构造方法是创建对象使用的，一直递归会导致内存中有无数多个对象
	 */
    public Test01(){
        //Test01();
    }
}
```

**使用递归计算1-n之间的和：**

```java
public class Test02 {
    public static void main(String[] args) {
        int s = sum(100);
        System.out.println(s);
    }

    /**
	 * 定义一个方法，使用递归计算1-n之间的和
	 *  1+2+3+..n
	 *  n+(n-1) +(n-1)+..1;
	 *  已知 最大值n  最小值1
	 *  使用递归必需明确
	 *  	1.递归的结束条件：获取到1的时候结束
	 *  	2.递归的目标：获取下一个被加的数字(n-1)
	 */
    private static int sum(int n) {
        //获取到1的时候
        if(n==1){
            return 1;
        }
        //获取下一个被加的数字 (n-1)
        return n+sum(n-1);
    }
}
```

# 判空

依赖包：commons-lang3

这个包为我们提供了两个判空的方法，分别是

> StringUtils.isEmpty(CharSequence cs)
>
> StringUtils.isBlank(CharSequence cs)

1. StringUtils.isEmpty

这个方法判断的是字符串是否为null或者其长度是否为零。

isEmpty的源码如下：

```java
public static boolean isEmpty(CharSequence cs) { 
    return cs == null ll cs.length() == 0;
}
```

2. StringUtils.isBlank

这个方法除了判断字符串是否为null和长度是否为零，还判断了是否为空格，如果是空格也返回true。

isBlank的源码如下：

```java
public static boolean isBlank(CharSequence cs) { 
    int strLen = length(cs);
    if (strLen == 0) { 
        return true;
    }else {
        for(int i=0; i < strLen; ++i) {
            if (!Character. iswhitespace(cs.charAt(i))) { 
                return false;
            }
        }
        return true;
    }
}
```

length(cs)的方法如下：

```java
public static int length(CharSequence cs) { 
    return cs == null ? 0 : cs.length();
}
```

CharSequence：

```
CharSequence是个接口
实现了这个接口的类有：CharBuffer、String、StringBuffer、StringBuilder这四个类。
```

3. 总结

- isEmpty：如果是null或者“”则返回true。
- isBlank：如果是null或者“”或者空格则返回true。**「isBlank判空更加准确」**。

4. 扩展

- 在实际开发中，除了isBlank判空的几种情况之外，其实“null”字符串我们也会当作空字符串处理。

- 我们需要判断几个字段同时不能为空，如果还用isBlank就显得有点累赘了。我们可以使用String的可变参数提供如下工具类。

  > 这个工具类的优点很明显，一方面判断了字符串“null”，另一方面对参数个数无限制，只要有一个参数是空则返回true

```java
public class StringTool {
    public static boolean isNullStr(String... args) {
        boolean flag = false;
        for (String arg : args) {
            if (Stringutils. isBlank(arg) || arg.equals("null")) {
                flag = true;
                return falg;
            }
        }
        return flag;
    }
}
```

# DO/DTO/VO

**1.为什么会出现这些 O？**

> 一，随着编程工业化的发展，需要有一套合理的体系出现。于是 MVC、MVP、MVVM 等编程模型就出现了，为了搭配这些编程模型的使用，需要对 Object 的功能进行划分。
>
> 二，在团队协作编码中，一个好的命名方式是可以节约很多时间成本的。就比如`getItemById`一眼看去就知道是通过 id 获取一个 item 对象，`ItemVO`一眼看去就知道是前端需要的 json 对应的对象。
>
> 三，如此划分，可以让项目结构更加清楚。尽可能避免了在多人协作时对象混乱的情况。
>
> 总的来说，这一切都是为了让软件编程更加合理、更加规范、更加高效。

**2.常见O**

> 以下内容参考阿里巴巴 Java 开发手册

- DO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。

- PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象

- DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。

- BO（ Business Object）：业务对象。由 Service 层输出的封装业务逻辑的对象。

- AO（ Application Object）：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。

- VO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。

- POJO（ Plain Ordinary Java Object）：POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。

- DAO（Data Access Objects）：数据访问对象，和上面那些 O 不同的是，其功能是用于进行数据操作的。通常不会用于描述数据实体。

**3.数据的流向**

![6DE53A75-E813-4C9E-9033-CEB1D846420D](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmv5xmb68j30pz0690tz.jpg)

我们知道，一般情况下，前端是不会凭空造出数据的，因此最后前端展示的数据一定是从数据库中来的，数据的流向通常也是从数据库流向页面。我将其分成三个部分：数据访问、业务处理和业务解释。

> 1.数据访问：这一部分是用于从数据库中读取数据，将数据记录转换成数据实体也就是 Java 对象，便于操作。
>
> 2.业务处理：这一部分是数据流的核心，几乎所有数据的操作都是在这一部分完成的。
>
> 3.业务解释：这一部分是用于展示给前端的数据，解释业务体现在某些字段/值是需要经过处理(如：json)的才会呈现的。

**4.关键点**

- DAO：是用于**操作数据**而不是描述数据的。

- PO/DO/Entity：其数据结构对应数据表中的一条记录，因此是同一类别的。

- BO：可以理解为 PO 的组合，举个简单的例子，假设 PO 是一条交易记录，BO 就可以是一个人全部的交易记录集合对象。

- DTO：用于传输数据，可能传递给前端，也有可能传递给其他系统。用于**承载数据**。

- VO，这个最好理解，前端最后需要的数据长什么样，对应的对象就是 VO。（如：`ItemVO`是前端需要的 json 对应的对象）

**5.如何使用这些 O？**

> **教条主义？**
>
> 首先，这几个概念很完整，但是我们在用的时候是必须按这个来做吗？答案当然不是的，规矩是死的，人是活的。
>
> **省略方案：**
>
> 1.不管你是叫 PO 还是 DO 还是 Entity，用于描述数据库记录的对象一定要存在，不可省略。
>
> 2.DTO 和 BO 在一般情况下，如果业务系统不是非常复杂，可以考虑省略。
>
> 3.VO 和 DTO，DTO 可以用于将数据传递给前端，如果你不需要删减字段的话，VO 可以考虑省略。

**6.具体命名**

- 数据对象：xxxDO，xxx 即为数据表名。

- 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。

- 展示对象：xxxVO，xxx 一般为网页名称。

- POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。

**示例：**

```java
//Controller层:
public <ListsUserVo> getUsers (UserDTO userDto);

//Service层:
Lists<UserDTO> getUsers (UserDTO userDto);

//DAO层:
List<UserDTO> getUsers (UserDo userDo);
(报销但基本信息+报销单条目信息[交通\餐饮等])在表现层,DTO弥补DO/entity的不足，再为entity封装了一层功能
```

# Web架构&框架

三层架构：

> 1.表示层（web层） ：包含JSP, Servlet等web相关的内容
>
> 2.业务逻辑层（Service）：处理业务,
>
> 3.数据层（DAO Data Access object）：也叫持久层,封装了对数据库的访问细节,一般写DAO类

MVC框架：

> Model（模型）： 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
>
> View（视图）：视图代表模型包含的数据的可视化。
>
> Controller（控制器）：控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开来。



![16C4FE27-AD2B-4411-A547-6807A1FF292B](https://tva1.sinaimg.cn/large/007S8ZIlly1ghmxnb5021j30m80arjt0.jpg)

# Lambda表达

Lambda 表达式（*lambda* expression）是一个匿名函数，*Lambda*表达式基于数学中的*λ*演算得名

Lambda 表达式，也可称为闭包，允许把函数作为一个参数，使代码更简洁。

## 简单写法

1. 不需要参数，返回值为5：` () -> 5;  `

2. 接收一个参数(数字类型),返回其2倍的值： `x -> 2 * x;`

3. 接受2个参数(数字),并返回他们的差值：` (x, y) -> x – y;`

4. 接收2个int型整数,返回他们的和：`(int x, int y) -> x + y;`

5. 接受一个 string 对象,并在控制台打印,不返回任何值：`(String s) -> System.out.print(s);`

## 用法

**替代匿名类**

定义函数式接口，函数式接口就是只有一个抽象方法的接口，并且用注解@FunctionInterface注解来验证

`Inter inter = （a,b）->a*b`

```java
@FunctionalInterface
intenface MathAdd{
    public int ada(int a,int b);
}

//匿名类实现接口或继承父类
MathAdd mathAdd = new MathAdd() {
    //从add后的（ 开始截取，可得Lambda表达式
    public int add(int a,int b){
        return a+b;
    }
};

//Lambda表达式
MathAdd mathAdd = (int a, int b)-> a+b;
```

## 方法引用

**是方法引用，不是方法调用**

它是对Lambda的简化，“ :: ”为方法引用操作符，它所在的表达式称为方法的引用

操作符“ :: ”把方法引用分成两边，左边是类名或者某个对象的引用，右边是方法名。引用方法有下面几种方式：

> （1）对象引用*（对象实例）*::实例方法名
>
> （2）类名::静态方法名
>
> （3）类名::实例方法名
>
> （4）类名::new*（引用构造器）*
>
> （5）类型[]::new*（引用数组）*
>
> ​		  -- 等价于 lambda 表达式 x -> new int[x]。其中类型可以为基本类型也可以是类。

```java
import java.util.Arrays;

public class Main {
     static int cmp(String s1, String s2) {
        return s1.compareTo(s2);
    }
    
    public static void main(String[] args) {
        String[] array = new String[] { "Apple", "Orange", "Banana", "Lemon" };
		//匿名类
        Arrays.sort(array, new Comparator<String>() {  //Comparator接口
            public int compare(String s1, String s2) {
                return s1.compareTo(s2);
            }
        });
        //Lambda表达式
        Arrays.sort(array, (s1, s2) -> {
            return s1.compareTo(s2);
        });
        // 方法引用，引用上面的cmp方法
        Arrays.sort(array, Main::cmp);
        System.out.println(String.join(", ", array));
    }
}
```

## 缺点

1. 可读性太差，代码越长越差（事物都有两面性，既是优点也是缺点）；

2. 难调试，没办法将代码运行中出现的问题输出到日志等；

3. 有条件限制，JDK1.8后才可以用，好多公司的产品所用的JDK版本还是1.6、1.7，有些朋友可能觉得这个很简单就升级一下JDK嘛，其实中间会有很多问题，使得他们不敢轻易升级；

# Mavenx相关

## 依赖的scope

去除部署不需要的jar包

```xml
<dependency>

    < groupId>javax.servlet</groupId>

    < artifactId>jsp-api</artifactId>

    < version>2.0</version>

    < scope>provided</scope>

< /dependency>
```

> **compile** 默认的scope，表示 dependency 都可以在生命周期中使用。而且，这些dependencies 会传递到依赖的项目中。适用于所有阶段，会随着项目一起发布 
>
> **provided** 跟compile相似，但是表明了dependency 由JDK或者容器提供，例如Servlet AP和一些Java EE APIs。这个scope 只能作用在编译和测试时，同时没有传递性。     
>
> **runtime** 表示dependency不作用在编译时，但会作用在运行和测试时，如JDBC驱动，适用运行和测试阶段。 
>
> **test** 表示dependency作用在测试时，不作用在运行时。 只在测试时使用，用于编译和运行测试代码。不会随项目发布。 
>
> **system** 跟provided 相似，但是在系统中要以外部JAR包的形式提供，maven不会在repository查找它。

```css
你通过maven引入的jar包，里面的类，都是已经编译好的字节码，跟runtime或者provided没关系。

简单来说，compile、runtime和provided的区别，需要在执行mvn package命令，且打包格式是war之类（而不是默认的jar）的时候才能看出来。

通过compile和provided引入的jar包，里面的类，你在项目中可以直接import进来用，编译没问题，但是runtime引入的jar包中的类，项目代码里不能直接用，用了无法通过编译，只能通过反射之类的方式来用。

通过compile和runtime引入的jar包，会出现在你的项目war包里，而provided引入的jar包则不会。
```

