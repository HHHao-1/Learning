谈谈你对ava的理解
平台无关性
◆面向对象
◆GC
◆类库
◆语言特性
◆异常处理

平台无关性的实现

![image-20210115183518155](https://tva1.sinaimg.cn/large/008eGmZEly1gmoka9yl9sj3140068n0g.jpg)

![image-20210115183808423](https://tva1.sinaimg.cn/large/008eGmZEly1gmokd66g0tj31cw0ieakg.jpg)

在非静态方法中， aload_0 表示对this的操作，在static 方法中，aload_0表示对方法的第一参数的操作。

![image-20210115185133901](/Users/chenghao/Library/Application Support/typora-user-images/image-20210115185133901.png)

![image-20210115190213373](https://tva1.sinaimg.cn/large/008eGmZEly1gmol2821cxj31ao0han5v.jpg)

jvm内存结构模型与GC

jvm：内存中的虚拟机

jvm由以下四个部分组成

Execution Engine：对class中的指令进行解析后提交到操作系统运行

java执行性能没c，c++ 高

主流jvm基于c++实现

在需要较高执行性能的操作时可在java里调用c/c++程序

Native Interface：本地接口--->加载本地接口 

以下是个native方法

![image-20210115193115647](https://tva1.sinaimg.cn/large/008eGmZEly1gmolwg36o1j30zm0aqteu.jpg)

![image-20210115193202390](https://tva1.sinaimg.cn/large/008eGmZEly1gmolx9c0g9j31dx0u07wh.jpg)

谈谈反射
JAVA反射机制是在运行状态中,对于任意一个类,都
能够知道这个类的所有属性和方法;对于任意一个对象,
都能够调用它的任意方法和属性;这种动态获取信息以
及动态调用对象方法的功能称为java语言的反射机制。

getdeclaredmethod：获取类的所有方法，不能获取到继承及实现接口的方法

getmethod：获取pubic方法，包括继承的方法和实现接口的方法

反射就是把java类中的各个成分映射成一个个java对象。

![image-20210118181631348](/Users/chenghao/Library/Application Support/typora-user-images/image-20210118181631348.png)

![image-20210118181703533](https://tva1.sinaimg.cn/large/008eGmZEly1gms0m5ykd9j317e0ec7da.jpg)

![image-20210118181947298](https://tva1.sinaimg.cn/large/008eGmZEly1gms0ozxsg7j31xc0u0wsb.jpg)

![image-20210118182001334](https://tva1.sinaimg.cn/large/008eGmZEly1gms0p8w4vhj315r0u0h19.jpg)



javax：*javax*的x是extension的意思，也就是扩展包

extclassloader也可以加载外部或自定义jar包

ext和appclassloader是用户可见的，既java编写，可查看，boot需要看jvm代码

app加载classpath（类路径）下的内容 

 Navigate---> class-->查找类源码

![image-20210118185010515](https://tva1.sinaimg.cn/large/008eGmZEly1gms1km5pabj31j80u04dd.jpg)

![image-20210118185142790](https://tva1.sinaimg.cn/large/008eGmZEly1gms1m7wkvhj31ml0u04pk.jpg)

```
public class MyClassLoader extends ClassLoader {
    private String path;
    private String classLoaderName;

    public MyClassLoader(String path, String classLoaderName) {
        this.path = path;
        this.classLoaderName = classLoaderName;
    }

    //用于寻找类文件
    @Override
    public Class findClass(String name) {
        byte[] b = loadClassData(name);
        return defineClass(name, b, 0, b.length);
    }

    //用于加载类文件
    private byte[] loadClassData(String name) {
        name = path + name + ".class";
        InputStream in = null;
        ByteArrayOutputStream out = null;
        try {
            in = new FileInputStream(new File(name));
            out = new ByteArrayOutputStream();
            int i = 0;
            while ((i = in.read()) != -1) {
                out.write(i);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                out.close();
                in.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return out.toByteArray();
    }
    
    
    public class MyClassLoader extends ClassLoader {
    private String path;
    private String classLoaderName;

    public MyClassLoader(String path, String classLoaderName) {
        this.path = path;
        this.classLoaderName = classLoaderName;
    }

    //用于寻找类文件
    @Override
    public Class findClass(String name) {
        byte[] b = loadClassData(name);
        return defineClass(name, b, 0, b.length);
    }

    //用于加载类文件
    private byte[] loadClassData(String name) {
        name = path + name + ".class";
        InputStream in = null;
        ByteArrayOutputStream out = null;
        try {
            in = new FileInputStream(new File(name));
            out = new ByteArrayOutputStream();
            int i = 0;
            while ((i = in.read()) != -1) {
                out.write(i);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                out.close();
                in.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return out.toByteArray();
    }
```

