# 类相关

## 类的加载

1. 类的加载：将类的.class文件读入到内存。

2. 类加载的最终产品是位于堆区中的Class对象。

3. Class对象封装了类在方法区内的数据结构，并向java程序员提供了访问方法区内的数据结构的接口。

4. 有两种类型的类加载器:

   > - java虚拟机自带的加载器
   >
   >   *根类加载器（Bootstrap）：使用C++编写，程序员无法再java代码中获得该类。*
   >
   >   *扩展类加载器（Extension）：使用java代码实现、系统类加载器（System）。*
   >
   > - 用户自定义的类加载器
   >
   >   *java.lang.ClassLoader的子类，用户可以定制类的加载方式*
   >
   > - 类加载器父亲委托机制
   >
   >   *用来把类加载到Java虚拟机中。类的加载过程采用父亲委托机制，这种机制能更好地保证java平台的安全。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父类加载器。当java程序请求加载器loader加载类时，loader1首先委托自己的父加载器去加载，若父加载器能加载，则由父加载器加载任务，否则才由本身加载。*

5. JVM规范运行类加载器在预料到某个类将要被使用时就预先加载它;

   如果在预先加载的过程中遇到.class文件缺失或者存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。

6. 主动使用：

   - 创建类的实例

   - 访问类或接口的静态变量

   - 调用类的静态方法、反射、初始化一个类的子类、启动类

## 类的连接

>    类被加载后，进入连接阶段，连接就是将已读入内存的类的二进制数据合并到虚拟机运行时环境中。

1. 类的内容验证

​     验证阶段：类文件的结构检查、语义检查、字节码验证、二进制兼容性的验证

2. 类的准备

​     准备阶段：java虚拟机为类的静态变量分配内存，并设置默认的初始值。

3. 类的解析

​     解析阶段：java虚拟机会把类的二进制数据中的符号引用替换为直接引用。

4. 补充：

   ```js
   - 符号引用(Symbolic References)
   
   符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件中。
   
   - 直接引用(Direct References)
   
   直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。** 如果有了直接引用，那引用的目标必定已经在内存中存在。**
   ```

## 类的初始化

>    在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。

1. 在静态变量的声明处进行初始化。

2. 在静态代码块中进行初始化

3. 类的初始化步骤：

​				  1）假如这个类还没有被加载和连接，那就先进行加载和连接

​                  2）假如类存在直接的父类，并且这个父类还没有被初始化，那就先初始化直接的父类。

​                  3）假如类中存在初始化语句，那就依次执行这些初始化语句

4. 类的初始化时机

   当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口

   在初始化一个类时，并不会先初始化它实现的接口

   在初始化一个接口时，并不会先初始化它的父接口

   只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。

---

**初始化示例：**

> **父类的静态字段——>父类静态代码块——>子类静态字段——>子类静态代码块——>**
>
> **父类非静态字段——>父类非静态代码块——>父类构造器——>**
>
> **子类非静态代码块——>子类非静态代码块——>子类构造器**
>
> 注意：父类必须有无参构造方法，子类不管是有参实例化还是无参实例化都会调用父类无参构造方法。

**类加载触发条件：**

- 实例化：静态字段-->静态代码块-->非静态字段-->非静态代码块-->构造方法

- 静态字段：静态字段-->静态代码块（加载类）

- 静态方法：静态字段-->静态代码块-->静态方法（加载类+静态方法）

- 反射：

  ```java
  Class.forName("com.company.main.B");//只加载类：静态字段-->静态代码块
  Class.forName("com.company.main.B").newInstance();//实例化
  Class.forName("com.company.main.B", true, this.getClass().getClassLoader());// 第二个参数为true则加载类，
  /*
  Class cls = Class.forName("ClassDemo");
  ClassLoader cLoader = cls.getClassLoader();
  Class cls2 = Class.forName("java.lang.Thread", true, cLoader);
  */
  ```

  

