# 基本概念

> - IBM贡献的超级账本框架
> - 利用现有成熟的技术来组合而成的一个区块链技术的实现
> - 允许可插拔实现各种功能的的模块化架构
> - 支持各种主流语言编写智能合约

## 技术架构

> - 分为网络层模块、权限管理模块、区块链应用模块，通过SDK和CLI对应用开发者提供服务

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqa16bniq8j30x30m1780.jpg)

## Gossip

Gossip数据传输协议有三项功能：

1. 管理节点和发现通道成员
2. 在通道上的所有节点间广播账本数据
3. 在通道上的所有节点间同步账本数据

## 账本

### 账本结构

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqb791mpf1j319i0kaadh.jpg)

### 区块结构

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqb7d3nywyj311u0h040c.jpg)

区块包含：区块头、区块数据、区块元数据

> - 区块头包含三个属性（**区块号**、**当前区块哈希**、**前一个区块的哈希**），当一个区块被创建时写入。
> - 区块数据包含的是**排序后的交易列表**。当区块被ordering service创建时写入。
> - 区块元数据包括区块的**写入时间，以及区块写入者的证书、公钥和签名。**

### 账本子系统

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqb7ehgnfnj31300hiwfs.jpg)

> - Fabric账本子系统包含两个组件：**世界状态和交易日志（区块）**
> - 每一个参与者有一份他们参与的每个Fabric网络的账本的副本
> - 世界状态组件描述了一个给定时间点的账本状态。它是账本的数据库，存储的是**账本当前值**
> - 交易日志组件记录所有导致世界状态当前值的交易。**它是世界状态的更新历史**

### 状态数据库

Fabric目前可以支持的世界状态数据库有两种：

> - LevelDB：嵌入在 Peer 中的默认键值对（key-value）状态数据库。
> - CouchDB：是一种可选的替代 levelDB 的状态数据库。与 LevelDB 键值存储一样。
>   - CouchDB不仅可以根据key进行相应的查询，**还可以根据不同的应用场景需求实现复杂查询。**

下图是一个世界状态例图，记录CAR1和CAR2的信息。应用程序可以调用智能合约来put和delete状态。

*世界状态中有一个属性——版本号，版本号从0开始，每当状态更新时版本号就递增。状态更新时会首先检查版本号，以确保当前状态的版本与背书时的版本一致（避免并发更新）----- 类似乐观锁。*

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqb7fwfwptj31320hgq6h.jpg)

## 链码

> - chaincode在区块链外部应用程序要和账本发生交易的时候被外部应用程序调用
> - 大多数情况下，链码只和账本的数据库组件（**世界状态**）交互，而不和交易日志交互

### 初始化

- 所有的链码都需要有一个 Init 方法。默认情况下，该方法不会被执
- 但可以在链码定义中请求执行 Init 方法来初始化链码

### 安装

- 将链码放到 一个或多个Peer 节点文件系统的过程

### 实例化

- 在特定通道上启动和初始化链码应用的过程
- 实例化完成后，装有链码的节点可以接受链码调用

### 调用

- 客户端应用通过向背书节点发送交易提案来调用链码
- 节点会执行链码并向客户端应用返回一个背书提案
- 客户端应用会收集充足的提案响应来判断是否符合背书策略
- 之后再将交易结果递交到排序、验证和提交
- 客户端应用可以选择不提交交易结果。比如，调用只查询账本，通常情况下，客户端应用是不会提交这种只读性交易的，除非基于审计目的，需要记录访问账本的日志。
- 调用包含了通道标识符，调用的链码函数，以及一个包含参数的数组

## 交易

### 交易概念

> - 在fabric指对**链代码的操作**
> - 交易分为两种，**部署交易和调用交易**。
>   - 部署交易指的是**创建新的链码**，当一个部署交易成功执行时，链码就被安装到区块链上了。
>   - 调用交易指的是**运行链码**，链代码执行时可能会修改相应的状态，并返回输出。

### 交易结构

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqa2681gtbj30jj0ay0u2.jpg)

- **交易头**：包含交易的元数据，如**链码名称、版本**等
- **交易签名**：包含由客户端应用程序创建的**加密签名**，作用是判断交易是否被篡改
- **交易提案**：作用是对由应用程序提供给智能合约的输入参数进行编码。当智能合约运行时，提案**负责将参数传递过去**
- **交易响应**：是**智能合约的输出**，包含的是世界状态在交易前后的值，以读写集的形式展示。

### 交易流程

#### 完整流程

- ![img](https://tva1.sinaimg.cn/large/008i3skNly1gqb1y5np37j311y0reacf.jpg)

#### 调用流程

- ![img](https://tva1.sinaimg.cn/large/008i3skNly1gqb55q03a3j30tc0a0aba.jpg)

- 注意：
  - 此流程前提假设是各节点已经提前颁发好证书，且已正常启动，并加入已经创建好的通道
  - 此流程介绍的是在已经实例化了的链码通道上从发起一个调用交易到最终结账的全过程

> 1. 提交交易提案
>    - 第一：应用程序（客户端节）点构造好**交易提案（交易提案中包含本次交易要调用的合约标识、合约方法和参数信息以及客户端签名等）**请求
>    - 第二：根据背书策略选择背书节点执行交易提案并进行背书签名。背书节点是链代码中背书策略指定的节点。正常情况下背书节点执行后的结果是一致的，只有背书节点对结果的签名不一样。
> 2. 模拟执行提案并进行背书
>    - 第一：背书节点在收到交易提案后会进行一些验证
>    - 第二：验证通过后，背书节点会根据当前账本数据模拟执行链码中的业务逻辑并生成读写集
>      - 模拟执行时不会更新账本数据
>    - 第三：**背书节点对这些读写集进行签名生成提案响应**，然后返回给应用程序。
> 3. 收集交易的背书（返回模拟执行结果）
>    - 第一：应用程序收到proposal response（提案响应）后会对背书节点的签名进行验证**（所有节点接收到任何消息时都需要先验证消息的合法性）**
>    - 第二：
>      - 如果链码只进行账本查询操作，应用程序只需要检查查询响应，并不会将交易提交给排序服务节点
>      - 如果链码对账本进行了invoke操作，则需要提交交易给排序服务进行账本更新（提交前会判断背书策略是否满足）。
> 4. 构造交易请求并发送给排序服务节点
>    - 第一：应用程序接收到所有背书节点的签名后，根据背书签名调用SDK生成交易
>      - 其中生成交易的过程很简单，只需要确认所有背书节点的执行结果完全一致，再将交易提案、提案响应和背书签名打包生成交易即可。
>    - 第二：广播给排序服务节点
> 5. 排序服务节点对交易进行排序并生成区块
>    - 第一：排序服务节点接收到网络中所有通道发出的交易信息
>    - 第二：读取交易信封获取通道名称，按各个通道上交易的接收时间顺序对交易信息进行排序（多通道隔离）
>    - 第三：生成区块
>      - （在这整个过程中，排序服务节点不会关心交易是否正确，只是负责排序和打包。交易的有效性在第7步进行验证）
> 6. 排序服务节点广播区块给主节点
>    -  第一：排序服务节点生成区块后会广播给通道上不同组织的主节点
> 7. 记账节点验证区块内容并写入到账本
>    - 所有的peer节点都是记账节点，记录的是节点已加入通道的账本数据
>    - 第一：记账节点接收到的排序服务节点生成的区块
>    - 第二：验证区块交易的有效性
>    - 第三：提交到本地账本并产生一个生成区块的事件
>    - 第四：监听区块事件的应用程序会进行后续的处理
>      - （如果接收的是配置区块，则会更新缓存的配置信息）
> 8. 主节点在组织内部同步最新的区块
>    - 第一：如果交易是无效的，也会更新区块，但不会更新世界状态
>      - ==（区块存储的是操作语句，而世界状态存储的是被处理的数据）==

## 系统链

> - 由在系统层面定义网络的配置区块组成
> - 系统链存在于排序服务中，与通道类似，具有包含以下信息的初始配置：MSP（成员服务提供者）信息、策略和配置详情
> - 全网中的任何变化（例如新的组织加入或者新的排序节点加入）将导致新的配置区块被添加到系统链中。
> - 系统链可看做是一个或一组通道的公用绑定。例如，金融机构的集合可以形成一个财团（表现为系统链）， 然后根据其相同或不同的业务计划创建通道

## 配置区块

> - 包含为系统链或通道定义成员和策略的配置数据
> - 对某个通道或整个网络的配置修改
>   - （比如，成员离开或加入）都将导致生成一个新的配置区块并追加到适当的链上
> - 这个配置区块会包含创始区块的内容，再加上增量

## 创世区块

> - 初始化排序服务的的配置区块，也是整个联盟链上的第一个区块
> - 每个通道都有一个由通道配置区块构成的初始区块

## 节点

是区块链的通信实体，是一个逻辑概念，不同类型的多个节点可以运行在同一个物理服务器上

### 逻辑结构图

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqa307tq5mj30ft0g9q3v.jpg)

### 客户端节点

> - 客户端必须连接到某一个peer节点或排序服务节点上才能与区块链网络进行通信
> - **客户端向背书节点**提交交易提案**，收集到足够背书后，**向排序节点广播交易提案，进行排序，生成区块

### peer节点

根据所承担角色可分为记账节点(committer)、背书节点(endorser)、主节点(leader)、锚节点(anchor)。

####  committer

> 验证交易并记账

- 所有的peer节点都是记账节点（committer）
- 负责验证排序服务节点区块里的交易，维护账本状态、维护副本
- 定期从orderer节点获取包含交易的区块，对这些区块进行核发验证之后，把这些区块加入到区块链中
- 无法通过配置文件配置，**需要在当前客户端或者命令行发起交易请求的时候手动指定相关的committer节点**。记账节点可以有多个

#### endorser

> 执行交易并对结果进行签名背书

- 背书节点是动态的角色，是与具体链码绑定的。每个链码在实例化的时候都会设置背书策略，指定哪些节点对交易背书后交易才是有效的
- 只有应用程序向它发起交易背书请求的时候才是背书节点，其他时候都是普通的记账节点
- **背书节点也无法通过配置文件指定，而是由发起交易请求的客户端指定**。背书节点可以有多个

#### anchor 

> 负责代表组织和其他组织进行信息交换

- **每个组织都有一个锚节点，锚节点对组织非常重要，锚节点出现问题，当前组织会与其他组织失去联系。**
- 锚节点的配置信息是在configtxgen模块的配置文件configtx.yaml中配置的。锚节点只能有一个。

#### leader

> 与排序服务节点通信，负责从排序节点获取最新的区块并在组织内部同步

- 主节点在整个组织中只能有一个
- Fabric 提供两种方式指定主节点：
  - 静态指定：系统管理员可以自定义配置一个或多个节点作为该组织的主节点；
  - 动态选举：节点可以通过选举选择一个节点作为主节点。

### orderer节点

> - 接收包含背书签名的交易
> - 对未打包的交易进行排序生成区块
> - 广播给peer节点
>   - 排序服务提供的是原子广播，保证同一个链上的节点接收到相同的信息，并且有相同的逻辑顺序

### ca节点

> - 用于向网络成员组织和他们的用户发行基于 PKI 的证书。
> - CA 向每一个成员发行一个根证书（rootCert）并向每一个授权的用户发行一个注册证书（ECert）。
> - Fabric的证书颁发机构由服务器和客户端组成
> - **CA节点是服务器，接收客户端(peer)的注册申请，返回注册密码用于用户登录，以便获取身份证书**
> - 区块链上的所有操作都需要验证用户身份

## 组织

> - Fabric系统是通过org来划分的
> - 每个组织内都有承担不同功能的peer节点，同时每个组织都有自己对应的fabric-ca服务器
> - fabric系统中所有的组织共用一个orderer集群
> - fabric中的组织在现实世界中可以是一个公司、一个企业，或者一个协会
> - 在fabric中，组织是承担着数据信用责任的区块链系统参与方
> - 在设计一个fabric系统时
>   - 第一就是要确定系统的参与方
>   - 第二从这些参与者中选出组织（生成对应的组织编号、域名、证书等）
>   - 第三确认组织的管理方式
>     - 组织的管理方式是指组织在遇到问题时的协作方式（如新组织的加入）

## 通道

> - Fabric的数据存储结构是多账本体系
> - 每个账本在fabric中被称为channel
>   - 每个通道中都有一个完全独立的账本，同一个通道中的所有peer节点都保存一份相同的数据
> - 通道由成员（组织）、每个成员的锚节点、账本、链码应用程序和排序服务节点定义
> - 网络上的每个交易都是在一个通道上执行的
>   - 在该通道上，每一方都必须经过身份验证和授权才能在该通道上进行交易
>   - 加入通道的每一个peer都有其自己的身份，由成员服务提供者（MSP）提供
> - 通道是由配置区块来定义的。

## MSP

- Membership Service Provider，负责联盟链成员的证书管理
- 定义了哪些RCA以及ICA在链里是可信任的
- 每个组织都有自己的CA及MSP
  - CA给每个peer颁发证书
  - MSP授权，赋予相应权限策略
  - **peer节点必须拥有CA和MSP才能访问链网**
  - 一个MSP下含有以下结构
  - ![img](https://tva1.sinaimg.cn/large/008i3skNly1gqa7o8mffxj30na09jmyb.jpg)
- 每个管理协作企业的组织都可以拥有自己的MSP
  - 如下图所示，ORG1拥有的MSP叫ORG1.MSP；而组织ORG2业务复杂，所以维护了3个MSP
  - ![img](https://tva1.sinaimg.cn/large/008i3skNly1gqa7plpeslj30r80blabu.jpg)

## PKI

> - Public Key Infrastructure，一种遵循标准的利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范。
> - 底层采用P2P网络和gRPC协议实现对**分布式账本结构的连通**。通过Gossip协议**进行状态同步、数据分发和成员探测。**

## 共识

- Fabric区块链的网络节点本质上是**互相复制的状态机**，节点之间需要保持相同的账本状态。
- 为实现分布式节点的一致性，各个节点需要**通过共识过程，对账本状态的变化达成一致性的认同。**

> Fabric区块链的共识过程包括3个阶段：背书、排序、校验

### 背书

- 在背书阶段中：
  - 第一：背书节点对客户端发来的交易提案进行合法性校验
  - 第二：模拟执行链码得到交易结果
  - 第三：根据设定的背书逻辑判断是否支持该交易提案
  - 第四：如果背书逻辑决定支持交易提案，会把交易提案签名后发回给客户端
- 客户端通常需要根据链码的背书策略，向一个或者多个成员的背书节点发出背书请求
- 背书策略会定义需要哪些节点背书交易才有效
  - 例如需要5个成员的背书节点中至少3个同意；或者某个特殊身份的成员支持等
- 客户端只有在收集足够多的背书节点的交易提案签名，交易才能被视为有效

### 排序

- 排序阶段就是由排序服务节点对交易进行排序，确定交易之间的时序关系
- 采用排序共识方式，各个成员收到的是一组发生顺序相同的交易，**从而保证了所有节点的数据一致性。**
- 排序服务：
  - 第一：把一段时间内收到的交易进行排序
  - 第二：把排序后的批量交易打包成区块
  - 第三：再把区块广播给通道中的成员
- 排序算法：
  - 目前，Fabric正式版支持三种交易排序算法：Solo、Kafka和Raft（非拜占庭故障共识算法）
    - Fabric提供可插拔式的共识插件，可使用SBFT等拜占庭共识插件
    - Solo：只有一个排序服务节点负责接收交易信息并排序，是最简单的一种排序算法，**一般用于开发测试环境中。Solo共识模式属于中心化的处理方式，不支持拜占庭容错。**
    - Kafka：Kafka是Apache的一个开源项目，主要提供分布式的消息处理／分发服务，每个Kafka集群由多个服务节点组成。Hyperledger Fabric利用Kafka对交易信息进行排序处理，提供高吞吐、低延时的处理能力，并且在集群内部**支持节点故障容错，但不支持拜占庭容错。**
    - Raft：Raft一致性算法是一种为了管理复制日志的一致性算法。它提供了和Paxos算法相同的功能和性能，但是它的算法结构和Paxos不同，使得Raft算法更加容易理解并更容易构建实际的系统。
      - 一致性算法就是允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。其中，Paxos算法统治着一致性算法这一领域：绝大多数的实现都是基于 Paxos 或者受其影响。

- 所有交易都要通过排序服务的排序才可以达成全网共识，因此**排序服务要避免成为网络上的性能瓶颈**。

### 校验

- 校验阶段是节点对排序后的交易进行一系列的检验

- 包括交易数据的完整性检查、是否重复交易、背书签名是否符合背书策略的要求、交易的读写集是否符合多版本并发控制MVCC（Multiversion Concurrency Control）的校验等

  - 读写集：

  - 提交者使用读-写集的读集部分来检查事务的有效性

  - 使用读写集的写集部分更新受影响的键的版本和值

  - 在验证阶段，如果在事务读集中每一个key的版本都能够与world state中的key版本一致，那么该条事务则被认为是有效的。如果读写集还包含一个或多个查询信息，则需要执行额外的验证。

  - ```xml
    <!- 一个简易读写集示例 ->
    <TxReadWriteSet>
      <NsReadWriteSet name="chaincode1">
        <read-set>
          <read key="K1", version="1">
          <read key="K2", version="1">
        </read-set>
        <write-set>
          <write key="K1", value="V1">
          <write key="K3", value="V2">
          <write key="K4", isDelete="true">
        </write-set>
      </NsReadWriteSet>
    <TxReadWriteSet>
    ```

- 当交易通过了所有校验后，将被标注为合法并写入账本中

- 因为所有的确认节点都按照相同的顺序检验交易，并且把合法的交易依次写入账本中，因此不同确认节点的状态能够始终保持一致。

# Fabric开发

## 工作分类

Fabric联盟链的开发人员主要分为三类：

- 底层系统运维：负责系统的部署与维护
- 组织管理：负责证书、MSP权限管理、共识机制等
- 业务开发：他们负责编写chaincode、创建维护channel、执行transaction交易等

![img](https://tva1.sinaimg.cn/large/008i3skNly1gqb7w166ykj30qo0gejtt.jpg)

## 业务开发

- 我们的开发流程主要包括写智能合约，以及通过SDK调用智能合约，及订阅各类事件，如图所示：

  ![img](https://tva1.sinaimg.cn/large/008i3skNly1gqb7y2hd0aj30go0fd40c.jpg)

Hyperledger Fabric的共识算法和比特币有很大不同，首先，前者是由permissioned节点组成的分布式系统，所有记账节点都是可信的（不会恶意伪造交易信息），所以，不需要POW算力证明。同时，Hyperledger Fabric的各个节点的交易信息统一由排序服务节点（orderer service node）处理，保证每个节点上的交易顺序一致，天然避免了分叉问题。目前，Hyperledger Fabric提供两种排序算法，SOLO和Kafka，其中SOLO模式只有一个order服务节点负责接收交易信息并排序，这是最简单的一种排序算法，不适合大规模的实际生产环境，一般用在实验室测试环境中。