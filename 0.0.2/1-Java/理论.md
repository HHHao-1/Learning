# 进制表达

## 表达

- 2进制：0b开头，最大值0b11111111
  - int a = 0b00110000  -->48
- 8进制：0开头，最大0377
  - int a = 0060  -->48
- 16进制：0x开头，最大值0xFF
  - int a = 0x30  -->48

## 转换

`public static Integer valueOf(String s,int radix) throws NumberFormatException`

`public static int parseInt(String s,int radix) throws NumberFormatException`

`public static String toString(int i,int radix)`

```java
Integer a = Integer.valueOf("FF", 16);//255
int b = Integer.parseInt("FF", 16);//255
String c = Integer.toString(255, 16);//ff
```

# 数据类型

## 默认类型

- 整数不加L默认是int，int转为long安全，能编译通过
  - 当不加L，给long赋值一个超过int范围的值的时候，不能编译通过
- float浮点数不加F默认是double类型，double转float可能损失精度，不能编译通过

## 内存占用

| 对象类型 | 内存占用/byte |
| -------- | ------------- |
| boolean  | 1             |
| byte     | 1             |
| short    | 2             |
| char     | 2             |
| int      | 4             |
| float    | 4             |
| long     | 8             |
| double   | 8             |

# 深/浅拷贝

## 概念

- **浅复制**：在堆内存中不分配新的空间，新的对象和之前的对象指向相同的堆空间。
- **深复制**：在堆内存中分配新空间，将之前的对象中的内容拷贝到新的堆空间中。

> 通过  **=**  号简单的复制，复制的是对象的引用

## 应用

### clone()

object.clone()：返回一个新的实例对象，对象属性是浅拷贝。

- x.clone()!=x为true

- x.clone().getClass()==x.getClass()为true

- > ① Object类的 clone() 方法是native方法，效率一般远高于非native方法。
  >
  > ② **实现Cloneable接口或重写clone方法，才能在外部调用clone()**

### arraycopy()

- Arrays.copyOf(T[ ] original, int newLength)
- System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 
- 返回一个新的实例对象，从指定源数组中复制一个数组。

> 相对数组对象是深拷贝，相对数组元素是浅拷贝。

```java
src-源数组。
srcPos-源数组中的起始位置。
dest-目标数组。
destPos-目标数据中的起始位置。
length-要复制的数组元素的数量。
```

# 线程/进程

## 线程状态

![img](https://tva1.sinaimg.cn/large/008eGmZEly1gn3gyutounj30jg0dc0v9.jpg)

**线程共包括以下 5 种状态:**

1. **新建状态(New):** 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。
2. **就绪状态(Runnable):** 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。
3. **运行状态(Running):** 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入运行状态。
4. **阻塞状态(Blocked):** 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
   - 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。
   - 同步阻塞 -- 线程获取synchronized同步锁失败(锁被其它线程占用)，会进入同步阻塞状态。
   - 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或超时、或者I/O处理完毕时，线程重新转入就绪状态。
5. **死亡状态(Dead):** 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

## 并发与并行

- 并发就是在单核处理中同时处理多个任务.(这里的同时指的是逻辑上的同时)

- 并行就是在多核处理器中同时处理多个任务.(这里的同时指的就是物理上的同时)

## 线程与进程

线程：

- 假设你经营着一家物业管理公司。最初，事事亲力亲为。给老张家修完暖气管道，立马再去老李家换电灯泡——这叫**单线程，所有的工作都得顺序执行**。
- 后来业务拓展了，你雇佣了几个工人，这样，你的物业公司就可以同时为多户人家提供服务了——这叫**多线程**，你是主线程。
- 工人们使用的工具，是物业管理公司提供的，这些工具由大家共享，并不专属于某一个人——这叫**多线程资源共享**。
- 工人们在工作中都需要管钳，可是管钳只有一把——这叫**冲突**。解决冲突的办法有很多，比如排队等候、等同事用完后的微信通知等——这叫**线程同步**。
- 你给工人布置任务——这叫**创建线程**。之后你还得要告诉他，可以开始了，不然他会一直停在那儿不动——这叫**启动线程（start）**。
- 如果某个工人（线程）的工作非常重要，你（主线程）也许会亲自监工一段时间，如果不指定时间，则表示你会一直监工到该项工作完成——这叫**线程参与（join）**。
- 下班时间一到，你群发微信，所有的工人不管手头的工作是否完成，都跟你走人。因此如果有必要，你得避免不要在工人正忙着的时候发下班的通知——这叫**线程守护属性设置和管理**。

进程：

- 再后来，你的公司规模扩大，同时为很多生活社区服务，在每个生活社区设置分公司，分公司由分公司经理管理，运营机制和你的总公司几乎一模一样——这叫**多进程**，总公司叫主进程，分公司叫子进程。
- 总公司和分公司，以及各个分公司之间，工具都是独立的，不能借用、混用——这叫**进程间不能共享资源**。各个分公司之间可以通过专线电话联系——这叫**管道**。各个分公司之间还可以通过公司公告栏交换信息——这叫**进程间共享内存**。另外，各个分公司之间还有各种协同手段，以便完成更大规模的作业——这叫**进程间同步**。分公司可以跟着总公司一起下班，也可以把当天的工作全部做完之后再下班——这叫**守护进程设置**。

## 守护线程

- 有一种特别的线程叫做守护线程。这种线程的优先级非常低，通常在程序里没有其他线程运行时才会执行它。当守护线程是程序里唯一在运行的线程时，JVM会结束守护线程并终止程序。

- 根据这些特点，守护线程通常用于在同一程序里给用户线程提供服务。它们通常无限循环的等待服务请求或执行线程任务。它们不能做重要的任务，因为我们不知道什么时候会被分配到CPU时间片，并且只要没有其他线程在运行，它们可能随时被终止。JAVA中最典型的这种类型代表就是垃圾回收器。

  - ```java
    //上帝，守护线程
    class God implements Runnable{
        @Override
        public void run() {
            while (true) {
                System.out.println("上帝守护着你");
            }
        }
    }
    //凡人，用户线程
    class Person implements Runnable{
        @Override
        public void run() {
            for (int i = 0; i <100 ; i++) {
                System.out.println("凡人在数数：" + i);
            }
            System.out.println("==========数数完毕！===========");
        }
    }
    ```

## 守护进程

守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。一般的生命周期是系统启动到系统停止运行，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。

守护进程是脱离于终端并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。

**Linux 的大多数服务器**就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。

# HashMap

> hashMap结构：hashMap是由数组和链表组成；
>
> hashMap存储：Key存储在数组的哪个位置由hashCode & (HashMap容量-1)算法得出；再根据Key的equals方法匹配链表中的对象；
>
> hashcode 对于HashMap：如果没有hashcode就意味着HashMap存储的时候是没有规律可寻的，那么每当我们map.get()方法的时候，就要把map里面的对象一一拿出来进行equals匹配，效率会超级慢；

- 示例：

```
// 存值规则：Key的hashCode与HashMap容量取余得出数组下标（这里算法做了简化）
//定义一个容量大小为3的hashMap（默认为16）
HashMap map=new HashMap(3);

map.put("a",1); 得到key 为“a” 的hashcode 值为97，98%3得到存储位到数组下标为1;

map.put("b",2); 得到key 为“b” 的hashcode 值为98,98%3到存储位到数组下标为2;

map.put("c",3); 得到key 为“c” 的hashcode 值为99，99%3到存储位到数组下标为0;

map.put("d",4); 得到key 为“d” 的hashcode 值为100，100%3到存储位到数组下标为1;

map.put("e",5); 得到key 为“e” 的hashcode 值为101，101%3到存储位到数组下标为2;

map.put("f",6); 得到key 为“f” 的hashcode 值为102，102%3到存储位到数组下标为0;
```

![img](https://tva1.sinaimg.cn/large/008eGmZEly1gn5yb557spj30hs0aj74h.jpg)

