> - 进程：程序的一次执行
>
> - 线程：CPU的基本调度单位

# 临时

什么是内存泄露？

大白话讲，就是我自己创建的对象，在一系列操作后，我访问不到该对象了，我认为它已经被回收掉了，但该对象却一直存在与内存中。



1. 类变量（类里面static修饰的变量）保存在“方法区”
2. 实例变量（类里面的普通变量）保存在“堆”
3. 局部变量（方法里声明的变量）“虚拟机栈”

“方法区”和“堆”都属于线程共享数据区，“虚拟机栈”属于线程私有数据区。

既：类变量和实例变量可能出现线程安全问题

## CAS机制

CAS  compare and swap 在没有锁的情况下保障线程一致性的对一个值进行更新

ABA问题，A值变为B再变为A，解决：每一个值加上版本号，既知道修改过程

![image-20210126152009869](https://tva1.sinaimg.cn/large/008eGmZEly1gn17r7ifepj30ym0mojtl.jpg)

通过引入低级别的原子化语义命令（比如compare-and-swap (CAS)），从而能在保证效率的同时保证原子性。

一个标准的CAS包含三个操作：

1. 将要操作的内存地址M。
2. 现有的变量A。
3. 新的需要存储的变量B。

CAS将会先比较A和M中存储的值是否一致，一致则表示其他线程未对该变量进行修改，则将其替换为B。 否则不做任何操作。

使用CAS可以不用阻塞其他的线程，但是我们需要自己处理好当更新失败的情况下的业务逻辑处理情况。

# 锁机制

## 乐观锁&悲观锁

synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。

CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。

CAS的缺点：

1.CPU开销较大
 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。

2.不能保证代码块的原子性
 CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。

CAS并不是无阻塞，只是阻塞并非在语言、线程方面，而是在硬件层面，这样的操作更快更高效！

## 可重入锁

- synchronized
- ReentrantLock

什么是 “可重入”，可重入就是可以重复获取相同的锁而不会出现死锁。

可重入降低了编程复杂性

例如：当一个线程执行到某个synchronized方法时，比如说对象1的method1，而在对象1的method1中会调用另外一个synchronized方法对象1的method2，此时线程不必重新去申请锁，已有此对象的锁，而是可以直接执行方法method2；若是不可重入，重新获取。

## 可中断锁

　　顾名思义，可中断锁就是可以响应中断的锁。在Java中，synchronized就不是可中断锁，而Lock是可中断锁。
　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。在前面演示tryLock(long time, TimeUnit unit)和lockInterruptibly()的用法时已经体现了Lock的可中断性。

## 公平锁

　　公平锁即 尽量 以请求锁的顺序来获取锁。比如，同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。而非公平锁则无法保证锁的获取是按照请求锁的顺序进行的，这样就可能导致某个或者一些线程永远获取不到锁。

　　在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。而对于ReentrantLock 和 ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁